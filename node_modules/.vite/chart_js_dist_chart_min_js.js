import {
  __commonJS
} from "./chunk-ZAZH7SVW.js";

// node_modules/chart.js/dist/chart.min.js
var require_chart_min = __commonJS({
  "node_modules/chart.js/dist/chart.min.js"(exports, module) {
    !function(t, e) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).Chart = e();
    }(exports, function() {
      "use strict";
      const t = typeof window == "undefined" ? function(t2) {
        return t2();
      } : window.requestAnimationFrame;
      function e(e2, i2, n2) {
        const o2 = n2 || ((t2) => Array.prototype.slice.call(t2));
        let s2 = false, a2 = [];
        return function(...n3) {
          a2 = o2(n3), s2 || (s2 = true, t.call(window, () => {
            s2 = false, e2.apply(i2, a2);
          }));
        };
      }
      function i(t2, e2) {
        let i2;
        return function() {
          return e2 ? (clearTimeout(i2), i2 = setTimeout(t2, e2)) : t2(), e2;
        };
      }
      const n = (t2) => t2 === "start" ? "left" : t2 === "end" ? "right" : "center", o = (t2, e2, i2) => t2 === "start" ? e2 : t2 === "end" ? i2 : (e2 + i2) / 2, s = (t2, e2, i2) => t2 === "right" ? i2 : t2 === "center" ? (e2 + i2) / 2 : e2;
      var a = new class {
        constructor() {
          this._request = null, this._charts = new Map(), this._running = false, this._lastDate = void 0;
        }
        _notify(t2, e2, i2, n2) {
          const o2 = e2.listeners[n2], s2 = e2.duration;
          o2.forEach((n3) => n3({ chart: t2, initial: e2.initial, numSteps: s2, currentStep: Math.min(i2 - e2.start, s2) }));
        }
        _refresh() {
          const e2 = this;
          e2._request || (e2._running = true, e2._request = t.call(window, () => {
            e2._update(), e2._request = null, e2._running && e2._refresh();
          }));
        }
        _update(t2 = Date.now()) {
          const e2 = this;
          let i2 = 0;
          e2._charts.forEach((n2, o2) => {
            if (!n2.running || !n2.items.length)
              return;
            const s2 = n2.items;
            let a2, r2 = s2.length - 1, l2 = false;
            for (; r2 >= 0; --r2)
              a2 = s2[r2], a2._active ? (a2._total > n2.duration && (n2.duration = a2._total), a2.tick(t2), l2 = true) : (s2[r2] = s2[s2.length - 1], s2.pop());
            l2 && (o2.draw(), e2._notify(o2, n2, t2, "progress")), s2.length || (n2.running = false, e2._notify(o2, n2, t2, "complete"), n2.initial = false), i2 += s2.length;
          }), e2._lastDate = t2, i2 === 0 && (e2._running = false);
        }
        _getAnims(t2) {
          const e2 = this._charts;
          let i2 = e2.get(t2);
          return i2 || (i2 = { running: false, initial: true, items: [], listeners: { complete: [], progress: [] } }, e2.set(t2, i2)), i2;
        }
        listen(t2, e2, i2) {
          this._getAnims(t2).listeners[e2].push(i2);
        }
        add(t2, e2) {
          e2 && e2.length && this._getAnims(t2).items.push(...e2);
        }
        has(t2) {
          return this._getAnims(t2).items.length > 0;
        }
        start(t2) {
          const e2 = this._charts.get(t2);
          e2 && (e2.running = true, e2.start = Date.now(), e2.duration = e2.items.reduce((t3, e3) => Math.max(t3, e3._duration), 0), this._refresh());
        }
        running(t2) {
          if (!this._running)
            return false;
          const e2 = this._charts.get(t2);
          return !!(e2 && e2.running && e2.items.length);
        }
        stop(t2) {
          const e2 = this._charts.get(t2);
          if (!e2 || !e2.items.length)
            return;
          const i2 = e2.items;
          let n2 = i2.length - 1;
          for (; n2 >= 0; --n2)
            i2[n2].cancel();
          e2.items = [], this._notify(t2, e2, Date.now(), "complete");
        }
        remove(t2) {
          return this._charts.delete(t2);
        }
      }();
      const r = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, l = "0123456789ABCDEF", c = (t2) => l[15 & t2], h = (t2) => l[(240 & t2) >> 4] + l[15 & t2], d = (t2) => (240 & t2) >> 4 == (15 & t2);
      function u(t2) {
        var e2 = function(t3) {
          return d(t3.r) && d(t3.g) && d(t3.b) && d(t3.a);
        }(t2) ? c : h;
        return t2 ? "#" + e2(t2.r) + e2(t2.g) + e2(t2.b) + (t2.a < 255 ? e2(t2.a) : "") : t2;
      }
      function f(t2) {
        return t2 + 0.5 | 0;
      }
      const g = (t2, e2, i2) => Math.max(Math.min(t2, i2), e2);
      function p(t2) {
        return g(f(2.55 * t2), 0, 255);
      }
      function m(t2) {
        return g(f(255 * t2), 0, 255);
      }
      function x(t2) {
        return g(f(t2 / 2.55) / 100, 0, 1);
      }
      function b(t2) {
        return g(f(100 * t2), 0, 100);
      }
      const _ = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      const y = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      function v(t2, e2, i2) {
        const n2 = e2 * Math.min(i2, 1 - i2), o2 = (e3, o3 = (e3 + t2 / 30) % 12) => i2 - n2 * Math.max(Math.min(o3 - 3, 9 - o3, 1), -1);
        return [o2(0), o2(8), o2(4)];
      }
      function w(t2, e2, i2) {
        const n2 = (n3, o2 = (n3 + t2 / 60) % 6) => i2 - i2 * e2 * Math.max(Math.min(o2, 4 - o2, 1), 0);
        return [n2(5), n2(3), n2(1)];
      }
      function M(t2, e2, i2) {
        const n2 = v(t2, 1, 0.5);
        let o2;
        for (e2 + i2 > 1 && (o2 = 1 / (e2 + i2), e2 *= o2, i2 *= o2), o2 = 0; o2 < 3; o2++)
          n2[o2] *= 1 - e2 - i2, n2[o2] += e2;
        return n2;
      }
      function k(t2) {
        const e2 = t2.r / 255, i2 = t2.g / 255, n2 = t2.b / 255, o2 = Math.max(e2, i2, n2), s2 = Math.min(e2, i2, n2), a2 = (o2 + s2) / 2;
        let r2, l2, c2;
        return o2 !== s2 && (c2 = o2 - s2, l2 = a2 > 0.5 ? c2 / (2 - o2 - s2) : c2 / (o2 + s2), r2 = o2 === e2 ? (i2 - n2) / c2 + (i2 < n2 ? 6 : 0) : o2 === i2 ? (n2 - e2) / c2 + 2 : (e2 - i2) / c2 + 4, r2 = 60 * r2 + 0.5), [0 | r2, l2 || 0, a2];
      }
      function S(t2, e2, i2, n2) {
        return (Array.isArray(e2) ? t2(e2[0], e2[1], e2[2]) : t2(e2, i2, n2)).map(m);
      }
      function P(t2, e2, i2) {
        return S(v, t2, e2, i2);
      }
      function D(t2) {
        return (t2 % 360 + 360) % 360;
      }
      function C(t2) {
        const e2 = y.exec(t2);
        let i2, n2 = 255;
        if (!e2)
          return;
        e2[5] !== i2 && (n2 = e2[6] ? p(+e2[5]) : m(+e2[5]));
        const o2 = D(+e2[2]), s2 = +e2[3] / 100, a2 = +e2[4] / 100;
        return i2 = e2[1] === "hwb" ? function(t3, e3, i3) {
          return S(M, t3, e3, i3);
        }(o2, s2, a2) : e2[1] === "hsv" ? function(t3, e3, i3) {
          return S(w, t3, e3, i3);
        }(o2, s2, a2) : P(o2, s2, a2), { r: i2[0], g: i2[1], b: i2[2], a: n2 };
      }
      const O = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, T = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" };
      let A;
      function L(t2) {
        A || (A = function() {
          const t3 = {}, e3 = Object.keys(T), i2 = Object.keys(O);
          let n2, o2, s2, a2, r2;
          for (n2 = 0; n2 < e3.length; n2++) {
            for (a2 = r2 = e3[n2], o2 = 0; o2 < i2.length; o2++)
              s2 = i2[o2], r2 = r2.replace(s2, O[s2]);
            s2 = parseInt(T[a2], 16), t3[r2] = [s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2];
          }
          return t3;
        }(), A.transparent = [0, 0, 0, 0]);
        const e2 = A[t2.toLowerCase()];
        return e2 && { r: e2[0], g: e2[1], b: e2[2], a: e2.length === 4 ? e2[3] : 255 };
      }
      function R(t2, e2, i2) {
        if (t2) {
          let n2 = k(t2);
          n2[e2] = Math.max(0, Math.min(n2[e2] + n2[e2] * i2, e2 === 0 ? 360 : 1)), n2 = P(n2), t2.r = n2[0], t2.g = n2[1], t2.b = n2[2];
        }
      }
      function E(t2, e2) {
        return t2 ? Object.assign(e2 || {}, t2) : t2;
      }
      function I(t2) {
        var e2 = { r: 0, g: 0, b: 0, a: 255 };
        return Array.isArray(t2) ? t2.length >= 3 && (e2 = { r: t2[0], g: t2[1], b: t2[2], a: 255 }, t2.length > 3 && (e2.a = m(t2[3]))) : (e2 = E(t2, { r: 0, g: 0, b: 0, a: 1 })).a = m(e2.a), e2;
      }
      function z(t2) {
        return t2.charAt(0) === "r" ? function(t3) {
          const e2 = _.exec(t3);
          let i2, n2, o2, s2 = 255;
          if (e2) {
            if (e2[7] !== i2) {
              const t4 = +e2[7];
              s2 = 255 & (e2[8] ? p(t4) : 255 * t4);
            }
            return i2 = +e2[1], n2 = +e2[3], o2 = +e2[5], i2 = 255 & (e2[2] ? p(i2) : i2), n2 = 255 & (e2[4] ? p(n2) : n2), o2 = 255 & (e2[6] ? p(o2) : o2), { r: i2, g: n2, b: o2, a: s2 };
          }
        }(t2) : C(t2);
      }
      class F {
        constructor(t2) {
          if (t2 instanceof F)
            return t2;
          const e2 = typeof t2;
          let i2;
          var n2, o2, s2;
          e2 === "object" ? i2 = I(t2) : e2 === "string" && (s2 = (n2 = t2).length, n2[0] === "#" && (s2 === 4 || s2 === 5 ? o2 = { r: 255 & 17 * r[n2[1]], g: 255 & 17 * r[n2[2]], b: 255 & 17 * r[n2[3]], a: s2 === 5 ? 17 * r[n2[4]] : 255 } : s2 !== 7 && s2 !== 9 || (o2 = { r: r[n2[1]] << 4 | r[n2[2]], g: r[n2[3]] << 4 | r[n2[4]], b: r[n2[5]] << 4 | r[n2[6]], a: s2 === 9 ? r[n2[7]] << 4 | r[n2[8]] : 255 })), i2 = o2 || L(t2) || z(t2)), this._rgb = i2, this._valid = !!i2;
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var t2 = E(this._rgb);
          return t2 && (t2.a = x(t2.a)), t2;
        }
        set rgb(t2) {
          this._rgb = I(t2);
        }
        rgbString() {
          return this._valid ? (t2 = this._rgb) && (t2.a < 255 ? `rgba(${t2.r}, ${t2.g}, ${t2.b}, ${x(t2.a)})` : `rgb(${t2.r}, ${t2.g}, ${t2.b})`) : this._rgb;
          var t2;
        }
        hexString() {
          return this._valid ? u(this._rgb) : this._rgb;
        }
        hslString() {
          return this._valid ? function(t2) {
            if (!t2)
              return;
            const e2 = k(t2), i2 = e2[0], n2 = b(e2[1]), o2 = b(e2[2]);
            return t2.a < 255 ? `hsla(${i2}, ${n2}%, ${o2}%, ${x(t2.a)})` : `hsl(${i2}, ${n2}%, ${o2}%)`;
          }(this._rgb) : this._rgb;
        }
        mix(t2, e2) {
          const i2 = this;
          if (t2) {
            const n2 = i2.rgb, o2 = t2.rgb;
            let s2;
            const a2 = e2 === s2 ? 0.5 : e2, r2 = 2 * a2 - 1, l2 = n2.a - o2.a, c2 = ((r2 * l2 == -1 ? r2 : (r2 + l2) / (1 + r2 * l2)) + 1) / 2;
            s2 = 1 - c2, n2.r = 255 & c2 * n2.r + s2 * o2.r + 0.5, n2.g = 255 & c2 * n2.g + s2 * o2.g + 0.5, n2.b = 255 & c2 * n2.b + s2 * o2.b + 0.5, n2.a = a2 * n2.a + (1 - a2) * o2.a, i2.rgb = n2;
          }
          return i2;
        }
        clone() {
          return new F(this.rgb);
        }
        alpha(t2) {
          return this._rgb.a = m(t2), this;
        }
        clearer(t2) {
          return this._rgb.a *= 1 - t2, this;
        }
        greyscale() {
          const t2 = this._rgb, e2 = f(0.3 * t2.r + 0.59 * t2.g + 0.11 * t2.b);
          return t2.r = t2.g = t2.b = e2, this;
        }
        opaquer(t2) {
          return this._rgb.a *= 1 + t2, this;
        }
        negate() {
          const t2 = this._rgb;
          return t2.r = 255 - t2.r, t2.g = 255 - t2.g, t2.b = 255 - t2.b, this;
        }
        lighten(t2) {
          return R(this._rgb, 2, t2), this;
        }
        darken(t2) {
          return R(this._rgb, 2, -t2), this;
        }
        saturate(t2) {
          return R(this._rgb, 1, t2), this;
        }
        desaturate(t2) {
          return R(this._rgb, 1, -t2), this;
        }
        rotate(t2) {
          return function(t3, e2) {
            var i2 = k(t3);
            i2[0] = D(i2[0] + e2), i2 = P(i2), t3.r = i2[0], t3.g = i2[1], t3.b = i2[2];
          }(this._rgb, t2), this;
        }
      }
      function V(t2) {
        return new F(t2);
      }
      const B = (t2) => t2 instanceof CanvasGradient || t2 instanceof CanvasPattern;
      function W(t2) {
        return B(t2) ? t2 : V(t2);
      }
      function H(t2) {
        return B(t2) ? t2 : V(t2).saturate(0.5).darken(0.1).hexString();
      }
      function N() {
      }
      const j = function() {
        let t2 = 0;
        return function() {
          return t2++;
        };
      }();
      function $(t2) {
        return t2 == null;
      }
      function Y(t2) {
        if (Array.isArray && Array.isArray(t2))
          return true;
        const e2 = Object.prototype.toString.call(t2);
        return e2.substr(0, 7) === "[object" && e2.substr(-6) === "Array]";
      }
      function U(t2) {
        return t2 !== null && Object.prototype.toString.call(t2) === "[object Object]";
      }
      const X = (t2) => (typeof t2 == "number" || t2 instanceof Number) && isFinite(+t2);
      function q(t2, e2) {
        return X(t2) ? t2 : e2;
      }
      function K(t2, e2) {
        return t2 === void 0 ? e2 : t2;
      }
      const G = (t2, e2) => typeof t2 == "string" && t2.endsWith("%") ? parseFloat(t2) / 100 : t2 / e2, Z = (t2, e2) => typeof t2 == "string" && t2.endsWith("%") ? parseFloat(t2) / 100 * e2 : +t2;
      function Q(t2, e2, i2) {
        if (t2 && typeof t2.call == "function")
          return t2.apply(i2, e2);
      }
      function J(t2, e2, i2, n2) {
        let o2, s2, a2;
        if (Y(t2))
          if (s2 = t2.length, n2)
            for (o2 = s2 - 1; o2 >= 0; o2--)
              e2.call(i2, t2[o2], o2);
          else
            for (o2 = 0; o2 < s2; o2++)
              e2.call(i2, t2[o2], o2);
        else if (U(t2))
          for (a2 = Object.keys(t2), s2 = a2.length, o2 = 0; o2 < s2; o2++)
            e2.call(i2, t2[a2[o2]], a2[o2]);
      }
      function tt(t2, e2) {
        let i2, n2, o2, s2;
        if (!t2 || !e2 || t2.length !== e2.length)
          return false;
        for (i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          if (o2 = t2[i2], s2 = e2[i2], o2.datasetIndex !== s2.datasetIndex || o2.index !== s2.index)
            return false;
        return true;
      }
      function et(t2) {
        if (Y(t2))
          return t2.map(et);
        if (U(t2)) {
          const e2 = Object.create(null), i2 = Object.keys(t2), n2 = i2.length;
          let o2 = 0;
          for (; o2 < n2; ++o2)
            e2[i2[o2]] = et(t2[i2[o2]]);
          return e2;
        }
        return t2;
      }
      function it(t2) {
        return ["__proto__", "prototype", "constructor"].indexOf(t2) === -1;
      }
      function nt(t2, e2, i2, n2) {
        if (!it(t2))
          return;
        const o2 = e2[t2], s2 = i2[t2];
        U(o2) && U(s2) ? ot(o2, s2, n2) : e2[t2] = et(s2);
      }
      function ot(t2, e2, i2) {
        const n2 = Y(e2) ? e2 : [e2], o2 = n2.length;
        if (!U(t2))
          return t2;
        const s2 = (i2 = i2 || {}).merger || nt;
        for (let a2 = 0; a2 < o2; ++a2) {
          if (!U(e2 = n2[a2]))
            continue;
          const o3 = Object.keys(e2);
          for (let n3 = 0, a3 = o3.length; n3 < a3; ++n3)
            s2(o3[n3], t2, e2, i2);
        }
        return t2;
      }
      function st(t2, e2) {
        return ot(t2, e2, { merger: at });
      }
      function at(t2, e2, i2) {
        if (!it(t2))
          return;
        const n2 = e2[t2], o2 = i2[t2];
        U(n2) && U(o2) ? st(n2, o2) : Object.prototype.hasOwnProperty.call(e2, t2) || (e2[t2] = et(o2));
      }
      function rt(t2, e2) {
        const i2 = t2.indexOf(".", e2);
        return i2 === -1 ? t2.length : i2;
      }
      function lt(t2, e2) {
        if (e2 === "")
          return t2;
        let i2 = 0, n2 = rt(e2, i2);
        for (; t2 && n2 > i2; )
          t2 = t2[e2.substr(i2, n2 - i2)], i2 = n2 + 1, n2 = rt(e2, i2);
        return t2;
      }
      function ct(t2) {
        return t2.charAt(0).toUpperCase() + t2.slice(1);
      }
      const ht = (t2) => t2 !== void 0, dt = (t2) => typeof t2 == "function", ut = (t2, e2) => {
        if (t2.size !== e2.size)
          return false;
        for (const i2 of t2)
          if (!e2.has(i2))
            return false;
        return true;
      }, ft = Object.create(null), gt = Object.create(null);
      function pt(t2, e2) {
        if (!e2)
          return t2;
        const i2 = e2.split(".");
        for (let e3 = 0, n2 = i2.length; e3 < n2; ++e3) {
          const n3 = i2[e3];
          t2 = t2[n3] || (t2[n3] = Object.create(null));
        }
        return t2;
      }
      function mt(t2, e2, i2) {
        return typeof e2 == "string" ? ot(pt(t2, e2), i2) : ot(pt(t2, ""), e2);
      }
      var xt = new class {
        constructor(t2) {
          this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (t3) => t3.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (t3, e2) => H(e2.backgroundColor), this.hoverBorderColor = (t3, e2) => H(e2.borderColor), this.hoverColor = (t3, e2) => H(e2.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: true }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.describe(t2);
        }
        set(t2, e2) {
          return mt(this, t2, e2);
        }
        get(t2) {
          return pt(this, t2);
        }
        describe(t2, e2) {
          return mt(gt, t2, e2);
        }
        override(t2, e2) {
          return mt(ft, t2, e2);
        }
        route(t2, e2, i2, n2) {
          const o2 = pt(this, t2), s2 = pt(this, i2), a2 = "_" + e2;
          Object.defineProperties(o2, { [a2]: { value: o2[e2], writable: true }, [e2]: { enumerable: true, get() {
            const t3 = this[a2], e3 = s2[n2];
            return U(t3) ? Object.assign({}, e3, t3) : K(t3, e3);
          }, set(t3) {
            this[a2] = t3;
          } } });
        }
      }({ _scriptable: (t2) => !t2.startsWith("on"), _indexable: (t2) => t2 !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: false, _indexable: false } });
      const bt = Math.PI, _t = 2 * bt, yt = _t + bt, vt = Number.POSITIVE_INFINITY, wt = bt / 180, Mt = bt / 2, kt = bt / 4, St = 2 * bt / 3, Pt = Math.log10, Dt = Math.sign;
      function Ct(t2) {
        const e2 = Math.pow(10, Math.floor(Pt(t2))), i2 = t2 / e2;
        return (i2 <= 1 ? 1 : i2 <= 2 ? 2 : i2 <= 5 ? 5 : 10) * e2;
      }
      function Ot(t2) {
        const e2 = [], i2 = Math.sqrt(t2);
        let n2;
        for (n2 = 1; n2 < i2; n2++)
          t2 % n2 == 0 && (e2.push(n2), e2.push(t2 / n2));
        return i2 === (0 | i2) && e2.push(i2), e2.sort((t3, e3) => t3 - e3).pop(), e2;
      }
      function Tt(t2) {
        return !isNaN(parseFloat(t2)) && isFinite(t2);
      }
      function At(t2, e2, i2) {
        return Math.abs(t2 - e2) < i2;
      }
      function Lt(t2, e2) {
        const i2 = Math.round(t2);
        return i2 - e2 <= t2 && i2 + e2 >= t2;
      }
      function Rt(t2, e2, i2) {
        let n2, o2, s2;
        for (n2 = 0, o2 = t2.length; n2 < o2; n2++)
          s2 = t2[n2][i2], isNaN(s2) || (e2.min = Math.min(e2.min, s2), e2.max = Math.max(e2.max, s2));
      }
      function Et(t2) {
        return t2 * (bt / 180);
      }
      function It(t2) {
        return t2 * (180 / bt);
      }
      function zt(t2) {
        if (!X(t2))
          return;
        let e2 = 1, i2 = 0;
        for (; Math.round(t2 * e2) / e2 !== t2; )
          e2 *= 10, i2++;
        return i2;
      }
      function Ft(t2, e2) {
        const i2 = e2.x - t2.x, n2 = e2.y - t2.y, o2 = Math.sqrt(i2 * i2 + n2 * n2);
        let s2 = Math.atan2(n2, i2);
        return s2 < -0.5 * bt && (s2 += _t), { angle: s2, distance: o2 };
      }
      function Vt(t2, e2) {
        return Math.sqrt(Math.pow(e2.x - t2.x, 2) + Math.pow(e2.y - t2.y, 2));
      }
      function Bt(t2, e2) {
        return (t2 - e2 + yt) % _t - bt;
      }
      function Wt(t2) {
        return (t2 % _t + _t) % _t;
      }
      function Ht(t2, e2, i2, n2) {
        const o2 = Wt(t2), s2 = Wt(e2), a2 = Wt(i2), r2 = Wt(s2 - o2), l2 = Wt(a2 - o2), c2 = Wt(o2 - s2), h2 = Wt(o2 - a2);
        return o2 === s2 || o2 === a2 || n2 && s2 === a2 || r2 > l2 && c2 < h2;
      }
      function Nt(t2, e2, i2) {
        return Math.max(e2, Math.min(i2, t2));
      }
      function jt(t2) {
        return Nt(t2, -32768, 32767);
      }
      function $t(t2) {
        return !t2 || $(t2.size) || $(t2.family) ? null : (t2.style ? t2.style + " " : "") + (t2.weight ? t2.weight + " " : "") + t2.size + "px " + t2.family;
      }
      function Yt(t2, e2, i2, n2, o2) {
        let s2 = e2[o2];
        return s2 || (s2 = e2[o2] = t2.measureText(o2).width, i2.push(o2)), s2 > n2 && (n2 = s2), n2;
      }
      function Ut(t2, e2, i2, n2) {
        let o2 = (n2 = n2 || {}).data = n2.data || {}, s2 = n2.garbageCollect = n2.garbageCollect || [];
        n2.font !== e2 && (o2 = n2.data = {}, s2 = n2.garbageCollect = [], n2.font = e2), t2.save(), t2.font = e2;
        let a2 = 0;
        const r2 = i2.length;
        let l2, c2, h2, d2, u2;
        for (l2 = 0; l2 < r2; l2++)
          if (d2 = i2[l2], d2 != null && Y(d2) !== true)
            a2 = Yt(t2, o2, s2, a2, d2);
          else if (Y(d2))
            for (c2 = 0, h2 = d2.length; c2 < h2; c2++)
              u2 = d2[c2], u2 == null || Y(u2) || (a2 = Yt(t2, o2, s2, a2, u2));
        t2.restore();
        const f2 = s2.length / 2;
        if (f2 > i2.length) {
          for (l2 = 0; l2 < f2; l2++)
            delete o2[s2[l2]];
          s2.splice(0, f2);
        }
        return a2;
      }
      function Xt(t2, e2, i2) {
        const n2 = t2.currentDevicePixelRatio, o2 = i2 !== 0 ? Math.max(i2 / 2, 0.5) : 0;
        return Math.round((e2 - o2) * n2) / n2 + o2;
      }
      function qt(t2, e2) {
        (e2 = e2 || t2.getContext("2d")).save(), e2.resetTransform(), e2.clearRect(0, 0, t2.width, t2.height), e2.restore();
      }
      function Kt(t2, e2, i2, n2) {
        let o2, s2, a2, r2, l2;
        const c2 = e2.pointStyle, h2 = e2.rotation, d2 = e2.radius;
        let u2 = (h2 || 0) * wt;
        if (c2 && typeof c2 == "object" && (o2 = c2.toString(), o2 === "[object HTMLImageElement]" || o2 === "[object HTMLCanvasElement]"))
          return t2.save(), t2.translate(i2, n2), t2.rotate(u2), t2.drawImage(c2, -c2.width / 2, -c2.height / 2, c2.width, c2.height), void t2.restore();
        if (!(isNaN(d2) || d2 <= 0)) {
          switch (t2.beginPath(), c2) {
            default:
              t2.arc(i2, n2, d2, 0, _t), t2.closePath();
              break;
            case "triangle":
              t2.moveTo(i2 + Math.sin(u2) * d2, n2 - Math.cos(u2) * d2), u2 += St, t2.lineTo(i2 + Math.sin(u2) * d2, n2 - Math.cos(u2) * d2), u2 += St, t2.lineTo(i2 + Math.sin(u2) * d2, n2 - Math.cos(u2) * d2), t2.closePath();
              break;
            case "rectRounded":
              l2 = 0.516 * d2, r2 = d2 - l2, s2 = Math.cos(u2 + kt) * r2, a2 = Math.sin(u2 + kt) * r2, t2.arc(i2 - s2, n2 - a2, l2, u2 - bt, u2 - Mt), t2.arc(i2 + a2, n2 - s2, l2, u2 - Mt, u2), t2.arc(i2 + s2, n2 + a2, l2, u2, u2 + Mt), t2.arc(i2 - a2, n2 + s2, l2, u2 + Mt, u2 + bt), t2.closePath();
              break;
            case "rect":
              if (!h2) {
                r2 = Math.SQRT1_2 * d2, t2.rect(i2 - r2, n2 - r2, 2 * r2, 2 * r2);
                break;
              }
              u2 += kt;
            case "rectRot":
              s2 = Math.cos(u2) * d2, a2 = Math.sin(u2) * d2, t2.moveTo(i2 - s2, n2 - a2), t2.lineTo(i2 + a2, n2 - s2), t2.lineTo(i2 + s2, n2 + a2), t2.lineTo(i2 - a2, n2 + s2), t2.closePath();
              break;
            case "crossRot":
              u2 += kt;
            case "cross":
              s2 = Math.cos(u2) * d2, a2 = Math.sin(u2) * d2, t2.moveTo(i2 - s2, n2 - a2), t2.lineTo(i2 + s2, n2 + a2), t2.moveTo(i2 + a2, n2 - s2), t2.lineTo(i2 - a2, n2 + s2);
              break;
            case "star":
              s2 = Math.cos(u2) * d2, a2 = Math.sin(u2) * d2, t2.moveTo(i2 - s2, n2 - a2), t2.lineTo(i2 + s2, n2 + a2), t2.moveTo(i2 + a2, n2 - s2), t2.lineTo(i2 - a2, n2 + s2), u2 += kt, s2 = Math.cos(u2) * d2, a2 = Math.sin(u2) * d2, t2.moveTo(i2 - s2, n2 - a2), t2.lineTo(i2 + s2, n2 + a2), t2.moveTo(i2 + a2, n2 - s2), t2.lineTo(i2 - a2, n2 + s2);
              break;
            case "line":
              s2 = Math.cos(u2) * d2, a2 = Math.sin(u2) * d2, t2.moveTo(i2 - s2, n2 - a2), t2.lineTo(i2 + s2, n2 + a2);
              break;
            case "dash":
              t2.moveTo(i2, n2), t2.lineTo(i2 + Math.cos(u2) * d2, n2 + Math.sin(u2) * d2);
          }
          t2.fill(), e2.borderWidth > 0 && t2.stroke();
        }
      }
      function Gt(t2, e2, i2) {
        return i2 = i2 || 0.5, t2 && t2.x > e2.left - i2 && t2.x < e2.right + i2 && t2.y > e2.top - i2 && t2.y < e2.bottom + i2;
      }
      function Zt(t2, e2) {
        t2.save(), t2.beginPath(), t2.rect(e2.left, e2.top, e2.right - e2.left, e2.bottom - e2.top), t2.clip();
      }
      function Qt(t2) {
        t2.restore();
      }
      function Jt(t2, e2, i2, n2, o2) {
        if (!e2)
          return t2.lineTo(i2.x, i2.y);
        if (o2 === "middle") {
          const n3 = (e2.x + i2.x) / 2;
          t2.lineTo(n3, e2.y), t2.lineTo(n3, i2.y);
        } else
          o2 === "after" != !!n2 ? t2.lineTo(e2.x, i2.y) : t2.lineTo(i2.x, e2.y);
        t2.lineTo(i2.x, i2.y);
      }
      function te(t2, e2, i2, n2) {
        if (!e2)
          return t2.lineTo(i2.x, i2.y);
        t2.bezierCurveTo(n2 ? e2.cp1x : e2.cp2x, n2 ? e2.cp1y : e2.cp2y, n2 ? i2.cp2x : i2.cp1x, n2 ? i2.cp2y : i2.cp1y, i2.x, i2.y);
      }
      function ee(t2, e2, i2, n2, o2, s2 = {}) {
        const a2 = Y(e2) ? e2 : [e2], r2 = s2.strokeWidth > 0 && s2.strokeColor !== "";
        let l2, c2;
        for (t2.save(), s2.translation && t2.translate(s2.translation[0], s2.translation[1]), $(s2.rotation) || t2.rotate(s2.rotation), t2.font = o2.string, s2.color && (t2.fillStyle = s2.color), s2.textAlign && (t2.textAlign = s2.textAlign), s2.textBaseline && (t2.textBaseline = s2.textBaseline), l2 = 0; l2 < a2.length; ++l2) {
          if (c2 = a2[l2], r2 && (s2.strokeColor && (t2.strokeStyle = s2.strokeColor), $(s2.strokeWidth) || (t2.lineWidth = s2.strokeWidth), t2.strokeText(c2, i2, n2, s2.maxWidth)), t2.fillText(c2, i2, n2, s2.maxWidth), s2.strikethrough || s2.underline) {
            const e3 = t2.measureText(c2), o3 = i2 - e3.actualBoundingBoxLeft, a3 = i2 + e3.actualBoundingBoxRight, r3 = n2 - e3.actualBoundingBoxAscent, l3 = n2 + e3.actualBoundingBoxDescent, h2 = s2.strikethrough ? (r3 + l3) / 2 : l3;
            t2.strokeStyle = t2.fillStyle, t2.beginPath(), t2.lineWidth = s2.decorationWidth || 2, t2.moveTo(o3, h2), t2.lineTo(a3, h2), t2.stroke();
          }
          n2 += o2.lineHeight;
        }
        t2.restore();
      }
      function ie(t2, e2) {
        const { x: i2, y: n2, w: o2, h: s2, radius: a2 } = e2;
        t2.arc(i2 + a2.topLeft, n2 + a2.topLeft, a2.topLeft, -Mt, bt, true), t2.lineTo(i2, n2 + s2 - a2.bottomLeft), t2.arc(i2 + a2.bottomLeft, n2 + s2 - a2.bottomLeft, a2.bottomLeft, bt, Mt, true), t2.lineTo(i2 + o2 - a2.bottomRight, n2 + s2), t2.arc(i2 + o2 - a2.bottomRight, n2 + s2 - a2.bottomRight, a2.bottomRight, Mt, 0, true), t2.lineTo(i2 + o2, n2 + a2.topRight), t2.arc(i2 + o2 - a2.topRight, n2 + a2.topRight, a2.topRight, 0, -Mt, true), t2.lineTo(i2 + a2.topLeft, n2);
      }
      function ne(t2, e2, i2) {
        i2 = i2 || ((i3) => t2[i3] < e2);
        let n2, o2 = t2.length - 1, s2 = 0;
        for (; o2 - s2 > 1; )
          n2 = s2 + o2 >> 1, i2(n2) ? s2 = n2 : o2 = n2;
        return { lo: s2, hi: o2 };
      }
      const oe = (t2, e2, i2) => ne(t2, i2, (n2) => t2[n2][e2] < i2), se = (t2, e2, i2) => ne(t2, i2, (n2) => t2[n2][e2] >= i2);
      function ae(t2, e2, i2) {
        let n2 = 0, o2 = t2.length;
        for (; n2 < o2 && t2[n2] < e2; )
          n2++;
        for (; o2 > n2 && t2[o2 - 1] > i2; )
          o2--;
        return n2 > 0 || o2 < t2.length ? t2.slice(n2, o2) : t2;
      }
      const re = ["push", "pop", "shift", "splice", "unshift"];
      function le(t2, e2) {
        t2._chartjs ? t2._chartjs.listeners.push(e2) : (Object.defineProperty(t2, "_chartjs", { configurable: true, enumerable: false, value: { listeners: [e2] } }), re.forEach((e3) => {
          const i2 = "_onData" + ct(e3), n2 = t2[e3];
          Object.defineProperty(t2, e3, { configurable: true, enumerable: false, value(...e4) {
            const o2 = n2.apply(this, e4);
            return t2._chartjs.listeners.forEach((t3) => {
              typeof t3[i2] == "function" && t3[i2](...e4);
            }), o2;
          } });
        }));
      }
      function ce(t2, e2) {
        const i2 = t2._chartjs;
        if (!i2)
          return;
        const n2 = i2.listeners, o2 = n2.indexOf(e2);
        o2 !== -1 && n2.splice(o2, 1), n2.length > 0 || (re.forEach((e3) => {
          delete t2[e3];
        }), delete t2._chartjs);
      }
      function he(t2) {
        const e2 = new Set();
        let i2, n2;
        for (i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          e2.add(t2[i2]);
        if (e2.size === n2)
          return t2;
        const o2 = [];
        return e2.forEach((t3) => {
          o2.push(t3);
        }), o2;
      }
      function de(t2) {
        let e2 = t2.parentNode;
        return e2 && e2.toString() === "[object ShadowRoot]" && (e2 = e2.host), e2;
      }
      function ue(t2, e2, i2) {
        let n2;
        return typeof t2 == "string" ? (n2 = parseInt(t2, 10), t2.indexOf("%") !== -1 && (n2 = n2 / 100 * e2.parentNode[i2])) : n2 = t2, n2;
      }
      const fe = (t2) => window.getComputedStyle(t2, null);
      function ge(t2, e2) {
        return fe(t2).getPropertyValue(e2);
      }
      const pe = ["top", "right", "bottom", "left"];
      function me(t2, e2, i2) {
        const n2 = {};
        i2 = i2 ? "-" + i2 : "";
        for (let o2 = 0; o2 < 4; o2++) {
          const s2 = pe[o2];
          n2[s2] = parseFloat(t2[e2 + "-" + s2 + i2]) || 0;
        }
        return n2.width = n2.left + n2.right, n2.height = n2.top + n2.bottom, n2;
      }
      function xe(t2, e2) {
        const { canvas: i2, currentDevicePixelRatio: n2 } = e2, o2 = fe(i2), s2 = o2.boxSizing === "border-box", a2 = me(o2, "padding"), r2 = me(o2, "border", "width"), { x: l2, y: c2, box: h2 } = function(t3, e3) {
          const i3 = t3.native || t3, n3 = i3.touches, o3 = n3 && n3.length ? n3[0] : i3, { offsetX: s3, offsetY: a3 } = o3;
          let r3, l3, c3 = false;
          if (((t4, e4, i4) => (t4 > 0 || e4 > 0) && (!i4 || !i4.shadowRoot))(s3, a3, i3.target))
            r3 = s3, l3 = a3;
          else {
            const t4 = e3.getBoundingClientRect();
            r3 = o3.clientX - t4.left, l3 = o3.clientY - t4.top, c3 = true;
          }
          return { x: r3, y: l3, box: c3 };
        }(t2, i2), d2 = a2.left + (h2 && r2.left), u2 = a2.top + (h2 && r2.top);
        let { width: f2, height: g2 } = e2;
        return s2 && (f2 -= a2.width + r2.width, g2 -= a2.height + r2.height), { x: Math.round((l2 - d2) / f2 * i2.width / n2), y: Math.round((c2 - u2) / g2 * i2.height / n2) };
      }
      const be = (t2) => Math.round(10 * t2) / 10;
      function _e(t2, e2, i2, n2) {
        const o2 = fe(t2), s2 = me(o2, "margin"), a2 = ue(o2.maxWidth, t2, "clientWidth") || vt, r2 = ue(o2.maxHeight, t2, "clientHeight") || vt, l2 = function(t3, e3, i3) {
          let n3, o3;
          if (e3 === void 0 || i3 === void 0) {
            const s3 = de(t3);
            if (s3) {
              const t4 = s3.getBoundingClientRect(), a3 = fe(s3), r3 = me(a3, "border", "width"), l3 = me(a3, "padding");
              e3 = t4.width - l3.width - r3.width, i3 = t4.height - l3.height - r3.height, n3 = ue(a3.maxWidth, s3, "clientWidth"), o3 = ue(a3.maxHeight, s3, "clientHeight");
            } else
              e3 = t3.clientWidth, i3 = t3.clientHeight;
          }
          return { width: e3, height: i3, maxWidth: n3 || vt, maxHeight: o3 || vt };
        }(t2, e2, i2);
        let { width: c2, height: h2 } = l2;
        if (o2.boxSizing === "content-box") {
          const t3 = me(o2, "border", "width"), e3 = me(o2, "padding");
          c2 -= e3.width + t3.width, h2 -= e3.height + t3.height;
        }
        return c2 = Math.max(0, c2 - s2.width), h2 = Math.max(0, n2 ? Math.floor(c2 / n2) : h2 - s2.height), c2 = be(Math.min(c2, a2, l2.maxWidth)), h2 = be(Math.min(h2, r2, l2.maxHeight)), c2 && !h2 && (h2 = be(c2 / 2)), { width: c2, height: h2 };
      }
      function ye(t2, e2, i2) {
        const n2 = e2 || 1, o2 = Math.floor(t2.height * n2), s2 = Math.floor(t2.width * n2);
        t2.height = o2 / n2, t2.width = s2 / n2;
        const a2 = t2.canvas;
        return a2.style && (i2 || !a2.style.height && !a2.style.width) && (a2.style.height = `${t2.height}px`, a2.style.width = `${t2.width}px`), (t2.currentDevicePixelRatio !== n2 || a2.height !== o2 || a2.width !== s2) && (t2.currentDevicePixelRatio = n2, a2.height = o2, a2.width = s2, t2.ctx.setTransform(n2, 0, 0, n2, 0, 0), true);
      }
      const ve = function() {
        let t2 = false;
        try {
          const e2 = { get passive() {
            return t2 = true, false;
          } };
          window.addEventListener("test", null, e2), window.removeEventListener("test", null, e2);
        } catch (t3) {
        }
        return t2;
      }();
      function we(t2, e2) {
        const i2 = ge(t2, e2), n2 = i2 && i2.match(/^(\d+)(\.\d+)?px$/);
        return n2 ? +n2[1] : void 0;
      }
      function Me(t2, e2) {
        return "native" in t2 ? { x: t2.x, y: t2.y } : xe(t2, e2);
      }
      function ke(t2, e2, i2, n2) {
        const { controller: o2, data: s2, _sorted: a2 } = t2, r2 = o2._cachedMeta.iScale;
        if (r2 && e2 === r2.axis && a2 && s2.length) {
          const t3 = r2._reversePixels ? se : oe;
          if (!n2)
            return t3(s2, e2, i2);
          if (o2._sharedOptions) {
            const n3 = s2[0], o3 = typeof n3.getRange == "function" && n3.getRange(e2);
            if (o3) {
              const n4 = t3(s2, e2, i2 - o3), a3 = t3(s2, e2, i2 + o3);
              return { lo: n4.lo, hi: a3.hi };
            }
          }
        }
        return { lo: 0, hi: s2.length - 1 };
      }
      function Se(t2, e2, i2, n2, o2) {
        const s2 = t2.getSortedVisibleDatasetMetas(), a2 = i2[e2];
        for (let t3 = 0, i3 = s2.length; t3 < i3; ++t3) {
          const { index: i4, data: r2 } = s2[t3], { lo: l2, hi: c2 } = ke(s2[t3], e2, a2, o2);
          for (let t4 = l2; t4 <= c2; ++t4) {
            const e3 = r2[t4];
            e3.skip || n2(e3, i4, t4);
          }
        }
      }
      function Pe(t2, e2, i2, n2) {
        const o2 = [];
        if (!Gt(e2, t2.chartArea, t2._minPadding))
          return o2;
        return Se(t2, i2, e2, function(t3, i3, s2) {
          t3.inRange(e2.x, e2.y, n2) && o2.push({ element: t3, datasetIndex: i3, index: s2 });
        }, true), o2;
      }
      function De(t2, e2, i2, n2, o2) {
        const s2 = function(t3) {
          const e3 = t3.indexOf("x") !== -1, i3 = t3.indexOf("y") !== -1;
          return function(t4, n3) {
            const o3 = e3 ? Math.abs(t4.x - n3.x) : 0, s3 = i3 ? Math.abs(t4.y - n3.y) : 0;
            return Math.sqrt(Math.pow(o3, 2) + Math.pow(s3, 2));
          };
        }(i2);
        let a2 = Number.POSITIVE_INFINITY, r2 = [];
        if (!Gt(e2, t2.chartArea, t2._minPadding))
          return r2;
        return Se(t2, i2, e2, function(i3, l2, c2) {
          if (n2 && !i3.inRange(e2.x, e2.y, o2))
            return;
          const h2 = i3.getCenterPoint(o2);
          if (!Gt(h2, t2.chartArea, t2._minPadding))
            return;
          const d2 = s2(e2, h2);
          d2 < a2 ? (r2 = [{ element: i3, datasetIndex: l2, index: c2 }], a2 = d2) : d2 === a2 && r2.push({ element: i3, datasetIndex: l2, index: c2 });
        }), r2;
      }
      function Ce(t2, e2, i2, n2) {
        const o2 = Me(e2, t2), s2 = [], a2 = i2.axis, r2 = a2 === "x" ? "inXRange" : "inYRange";
        let l2 = false;
        return function(t3, e3) {
          const i3 = t3.getSortedVisibleDatasetMetas();
          let n3, o3, s3;
          for (let t4 = 0, a3 = i3.length; t4 < a3; ++t4) {
            ({ index: n3, data: o3 } = i3[t4]);
            for (let t5 = 0, i4 = o3.length; t5 < i4; ++t5)
              s3 = o3[t5], s3.skip || e3(s3, n3, t5);
          }
        }(t2, (t3, e3, i3) => {
          t3[r2](o2[a2], n2) && s2.push({ element: t3, datasetIndex: e3, index: i3 }), t3.inRange(o2.x, o2.y, n2) && (l2 = true);
        }), i2.intersect && !l2 ? [] : s2;
      }
      var Oe = { modes: { index(t2, e2, i2, n2) {
        const o2 = Me(e2, t2), s2 = i2.axis || "x", a2 = i2.intersect ? Pe(t2, o2, s2, n2) : De(t2, o2, s2, false, n2), r2 = [];
        return a2.length ? (t2.getSortedVisibleDatasetMetas().forEach((t3) => {
          const e3 = a2[0].index, i3 = t3.data[e3];
          i3 && !i3.skip && r2.push({ element: i3, datasetIndex: t3.index, index: e3 });
        }), r2) : [];
      }, dataset(t2, e2, i2, n2) {
        const o2 = Me(e2, t2), s2 = i2.axis || "xy";
        let a2 = i2.intersect ? Pe(t2, o2, s2, n2) : De(t2, o2, s2, false, n2);
        if (a2.length > 0) {
          const e3 = a2[0].datasetIndex, i3 = t2.getDatasetMeta(e3).data;
          a2 = [];
          for (let t3 = 0; t3 < i3.length; ++t3)
            a2.push({ element: i3[t3], datasetIndex: e3, index: t3 });
        }
        return a2;
      }, point: (t2, e2, i2, n2) => Pe(t2, Me(e2, t2), i2.axis || "xy", n2), nearest: (t2, e2, i2, n2) => De(t2, Me(e2, t2), i2.axis || "xy", i2.intersect, n2), x: (t2, e2, i2, n2) => (i2.axis = "x", Ce(t2, e2, i2, n2)), y: (t2, e2, i2, n2) => (i2.axis = "y", Ce(t2, e2, i2, n2)) } };
      const Te = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/), Ae = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
      function Le(t2, e2) {
        const i2 = ("" + t2).match(Te);
        if (!i2 || i2[1] === "normal")
          return 1.2 * e2;
        switch (t2 = +i2[2], i2[3]) {
          case "px":
            return t2;
          case "%":
            t2 /= 100;
        }
        return e2 * t2;
      }
      function Re(t2, e2) {
        const i2 = {}, n2 = U(e2), o2 = n2 ? Object.keys(e2) : e2, s2 = U(t2) ? n2 ? (i3) => K(t2[i3], t2[e2[i3]]) : (e3) => t2[e3] : () => t2;
        for (const t3 of o2)
          i2[t3] = +s2(t3) || 0;
        return i2;
      }
      function Ee(t2) {
        return Re(t2, { top: "y", right: "x", bottom: "y", left: "x" });
      }
      function Ie(t2) {
        return Re(t2, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
      }
      function ze(t2) {
        const e2 = Ee(t2);
        return e2.width = e2.left + e2.right, e2.height = e2.top + e2.bottom, e2;
      }
      function Fe(t2, e2) {
        t2 = t2 || {}, e2 = e2 || xt.font;
        let i2 = K(t2.size, e2.size);
        typeof i2 == "string" && (i2 = parseInt(i2, 10));
        let n2 = K(t2.style, e2.style);
        n2 && !("" + n2).match(Ae) && (console.warn('Invalid font style specified: "' + n2 + '"'), n2 = "");
        const o2 = { family: K(t2.family, e2.family), lineHeight: Le(K(t2.lineHeight, e2.lineHeight), i2), size: i2, style: n2, weight: K(t2.weight, e2.weight), string: "" };
        return o2.string = $t(o2), o2;
      }
      function Ve(t2, e2, i2, n2) {
        let o2, s2, a2, r2 = true;
        for (o2 = 0, s2 = t2.length; o2 < s2; ++o2)
          if (a2 = t2[o2], a2 !== void 0 && (e2 !== void 0 && typeof a2 == "function" && (a2 = a2(e2), r2 = false), i2 !== void 0 && Y(a2) && (a2 = a2[i2 % a2.length], r2 = false), a2 !== void 0))
            return n2 && !r2 && (n2.cacheable = false), a2;
      }
      function Be(t2, e2) {
        const { min: i2, max: n2 } = t2;
        return { min: i2 - Math.abs(Z(e2, i2)), max: n2 + Z(e2, n2) };
      }
      const We = ["left", "top", "right", "bottom"];
      function He(t2, e2) {
        return t2.filter((t3) => t3.pos === e2);
      }
      function Ne(t2, e2) {
        return t2.filter((t3) => We.indexOf(t3.pos) === -1 && t3.box.axis === e2);
      }
      function je(t2, e2) {
        return t2.sort((t3, i2) => {
          const n2 = e2 ? i2 : t3, o2 = e2 ? t3 : i2;
          return n2.weight === o2.weight ? n2.index - o2.index : n2.weight - o2.weight;
        });
      }
      function $e(t2, e2, i2, n2) {
        return Math.max(t2[i2], e2[i2]) + Math.max(t2[n2], e2[n2]);
      }
      function Ye(t2, e2) {
        t2.top = Math.max(t2.top, e2.top), t2.left = Math.max(t2.left, e2.left), t2.bottom = Math.max(t2.bottom, e2.bottom), t2.right = Math.max(t2.right, e2.right);
      }
      function Ue(t2, e2, i2) {
        const n2 = i2.box, o2 = t2.maxPadding;
        U(i2.pos) || (i2.size && (t2[i2.pos] -= i2.size), i2.size = i2.horizontal ? n2.height : n2.width, t2[i2.pos] += i2.size), n2.getPadding && Ye(o2, n2.getPadding());
        const s2 = Math.max(0, e2.outerWidth - $e(o2, t2, "left", "right")), a2 = Math.max(0, e2.outerHeight - $e(o2, t2, "top", "bottom")), r2 = s2 !== t2.w, l2 = a2 !== t2.h;
        return t2.w = s2, t2.h = a2, i2.horizontal ? { same: r2, other: l2 } : { same: l2, other: r2 };
      }
      function Xe(t2, e2) {
        const i2 = e2.maxPadding;
        function n2(t3) {
          const n3 = { left: 0, top: 0, right: 0, bottom: 0 };
          return t3.forEach((t4) => {
            n3[t4] = Math.max(e2[t4], i2[t4]);
          }), n3;
        }
        return n2(t2 ? ["left", "right"] : ["top", "bottom"]);
      }
      function qe(t2, e2, i2) {
        const n2 = [];
        let o2, s2, a2, r2, l2, c2;
        for (o2 = 0, s2 = t2.length, l2 = 0; o2 < s2; ++o2) {
          a2 = t2[o2], r2 = a2.box, r2.update(a2.width || e2.w, a2.height || e2.h, Xe(a2.horizontal, e2));
          const { same: s3, other: h2 } = Ue(e2, i2, a2);
          l2 |= s3 && n2.length, c2 = c2 || h2, r2.fullSize || n2.push(a2);
        }
        return l2 && qe(n2, e2, i2) || c2;
      }
      function Ke(t2, e2, i2) {
        const n2 = i2.padding;
        let o2, s2, a2, r2, l2 = e2.x, c2 = e2.y;
        for (o2 = 0, s2 = t2.length; o2 < s2; ++o2)
          a2 = t2[o2], r2 = a2.box, a2.horizontal ? (r2.left = r2.fullSize ? n2.left : e2.left, r2.right = r2.fullSize ? i2.outerWidth - n2.right : e2.left + e2.w, r2.top = c2, r2.bottom = c2 + r2.height, r2.width = r2.right - r2.left, c2 = r2.bottom) : (r2.left = l2, r2.right = l2 + r2.width, r2.top = r2.fullSize ? n2.top : e2.top, r2.bottom = r2.fullSize ? i2.outerHeight - n2.right : e2.top + e2.h, r2.height = r2.bottom - r2.top, l2 = r2.right);
        e2.x = l2, e2.y = c2;
      }
      xt.set("layout", { padding: { top: 0, right: 0, bottom: 0, left: 0 } });
      var Ge = { addBox(t2, e2) {
        t2.boxes || (t2.boxes = []), e2.fullSize = e2.fullSize || false, e2.position = e2.position || "top", e2.weight = e2.weight || 0, e2._layers = e2._layers || function() {
          return [{ z: 0, draw(t3) {
            e2.draw(t3);
          } }];
        }, t2.boxes.push(e2);
      }, removeBox(t2, e2) {
        const i2 = t2.boxes ? t2.boxes.indexOf(e2) : -1;
        i2 !== -1 && t2.boxes.splice(i2, 1);
      }, configure(t2, e2, i2) {
        e2.fullSize = i2.fullSize, e2.position = i2.position, e2.weight = i2.weight;
      }, update(t2, e2, i2, n2) {
        if (!t2)
          return;
        const o2 = ze(t2.options.layout.padding), s2 = Math.max(e2 - o2.width, 0), a2 = Math.max(i2 - o2.height, 0), r2 = function(t3) {
          const e3 = function(t4) {
            const e4 = [];
            let i4, n4, o4;
            for (i4 = 0, n4 = (t4 || []).length; i4 < n4; ++i4)
              o4 = t4[i4], e4.push({ index: i4, box: o4, pos: o4.position, horizontal: o4.isHorizontal(), weight: o4.weight });
            return e4;
          }(t3), i3 = je(e3.filter((t4) => t4.box.fullSize), true), n3 = je(He(e3, "left"), true), o3 = je(He(e3, "right")), s3 = je(He(e3, "top"), true), a3 = je(He(e3, "bottom")), r3 = Ne(e3, "x"), l3 = Ne(e3, "y");
          return { fullSize: i3, leftAndTop: n3.concat(s3), rightAndBottom: o3.concat(l3).concat(a3).concat(r3), chartArea: He(e3, "chartArea"), vertical: n3.concat(o3).concat(l3), horizontal: s3.concat(a3).concat(r3) };
        }(t2.boxes), l2 = r2.vertical, c2 = r2.horizontal;
        J(t2.boxes, (t3) => {
          typeof t3.beforeLayout == "function" && t3.beforeLayout();
        });
        const h2 = l2.reduce((t3, e3) => e3.box.options && e3.box.options.display === false ? t3 : t3 + 1, 0) || 1, d2 = Object.freeze({ outerWidth: e2, outerHeight: i2, padding: o2, availableWidth: s2, availableHeight: a2, vBoxMaxWidth: s2 / 2 / h2, hBoxMaxHeight: a2 / 2 }), u2 = Object.assign({}, o2);
        Ye(u2, ze(n2));
        const f2 = Object.assign({ maxPadding: u2, w: s2, h: a2, x: o2.left, y: o2.top }, o2);
        !function(t3, e3) {
          let i3, n3, o3;
          for (i3 = 0, n3 = t3.length; i3 < n3; ++i3)
            o3 = t3[i3], o3.horizontal ? (o3.width = o3.box.fullSize && e3.availableWidth, o3.height = e3.hBoxMaxHeight) : (o3.width = e3.vBoxMaxWidth, o3.height = o3.box.fullSize && e3.availableHeight);
        }(l2.concat(c2), d2), qe(r2.fullSize, f2, d2), qe(l2, f2, d2), qe(c2, f2, d2) && qe(l2, f2, d2), function(t3) {
          const e3 = t3.maxPadding;
          function i3(i4) {
            const n3 = Math.max(e3[i4] - t3[i4], 0);
            return t3[i4] += n3, n3;
          }
          t3.y += i3("top"), t3.x += i3("left"), i3("right"), i3("bottom");
        }(f2), Ke(r2.leftAndTop, f2, d2), f2.x += f2.w, f2.y += f2.h, Ke(r2.rightAndBottom, f2, d2), t2.chartArea = { left: f2.left, top: f2.top, right: f2.left + f2.w, bottom: f2.top + f2.h, height: f2.h, width: f2.w }, J(r2.chartArea, (e3) => {
          const i3 = e3.box;
          Object.assign(i3, t2.chartArea), i3.update(f2.w, f2.h);
        });
      } };
      class Ze {
        acquireContext(t2, e2) {
        }
        releaseContext(t2) {
          return false;
        }
        addEventListener(t2, e2, i2) {
        }
        removeEventListener(t2, e2, i2) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(t2, e2, i2, n2) {
          return e2 = Math.max(0, e2 || t2.width), i2 = i2 || t2.height, { width: e2, height: Math.max(0, n2 ? Math.floor(e2 / n2) : i2) };
        }
        isAttached(t2) {
          return true;
        }
      }
      class Qe extends Ze {
        acquireContext(t2) {
          return t2 && t2.getContext && t2.getContext("2d") || null;
        }
      }
      const Je = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, ti = (t2) => t2 === null || t2 === "";
      const ei = !!ve && { passive: true };
      function ii(t2, e2, i2) {
        t2.canvas.removeEventListener(e2, i2, ei);
      }
      function ni(t2, e2, i2) {
        const n2 = t2.canvas, o2 = n2 && de(n2) || n2, s2 = new MutationObserver((t3) => {
          const e3 = de(o2);
          t3.forEach((t4) => {
            for (let n3 = 0; n3 < t4.addedNodes.length; n3++) {
              const s3 = t4.addedNodes[n3];
              s3 !== o2 && s3 !== e3 || i2(t4.target);
            }
          });
        });
        return s2.observe(document, { childList: true, subtree: true }), s2;
      }
      function oi(t2, e2, i2) {
        const n2 = t2.canvas, o2 = n2 && de(n2);
        if (!o2)
          return;
        const s2 = new MutationObserver((t3) => {
          t3.forEach((t4) => {
            for (let e3 = 0; e3 < t4.removedNodes.length; e3++)
              if (t4.removedNodes[e3] === n2) {
                i2();
                break;
              }
          });
        });
        return s2.observe(o2, { childList: true }), s2;
      }
      const si = new Map();
      let ai = 0;
      function ri() {
        const t2 = window.devicePixelRatio;
        t2 !== ai && (ai = t2, si.forEach((e2, i2) => {
          i2.currentDevicePixelRatio !== t2 && e2();
        }));
      }
      function li(t2, i2, n2) {
        const o2 = t2.canvas, s2 = o2 && de(o2);
        if (!s2)
          return;
        const a2 = e((t3, e2) => {
          const i3 = s2.clientWidth;
          n2(t3, e2), i3 < s2.clientWidth && n2();
        }, window), r2 = new ResizeObserver((t3) => {
          const e2 = t3[0], i3 = e2.contentRect.width, n3 = e2.contentRect.height;
          i3 === 0 && n3 === 0 || a2(i3, n3);
        });
        return r2.observe(s2), function(t3, e2) {
          si.size || window.addEventListener("resize", ri), si.set(t3, e2);
        }(t2, a2), r2;
      }
      function ci(t2, e2, i2) {
        i2 && i2.disconnect(), e2 === "resize" && function(t3) {
          si.delete(t3), si.size || window.removeEventListener("resize", ri);
        }(t2);
      }
      function hi(t2, i2, n2) {
        const o2 = t2.canvas, s2 = e((e2) => {
          t2.ctx !== null && n2(function(t3, e3) {
            const i3 = Je[t3.type] || t3.type, { x: n3, y: o3 } = xe(t3, e3);
            return { type: i3, chart: e3, native: t3, x: n3 !== void 0 ? n3 : null, y: o3 !== void 0 ? o3 : null };
          }(e2, t2));
        }, t2, (t3) => {
          const e2 = t3[0];
          return [e2, e2.offsetX, e2.offsetY];
        });
        return function(t3, e2, i3) {
          t3.addEventListener(e2, i3, ei);
        }(o2, i2, s2), s2;
      }
      class di extends Ze {
        acquireContext(t2, e2) {
          const i2 = t2 && t2.getContext && t2.getContext("2d");
          return i2 && i2.canvas === t2 ? (function(t3, e3) {
            const i3 = t3.style, n2 = t3.getAttribute("height"), o2 = t3.getAttribute("width");
            if (t3.$chartjs = { initial: { height: n2, width: o2, style: { display: i3.display, height: i3.height, width: i3.width } } }, i3.display = i3.display || "block", i3.boxSizing = i3.boxSizing || "border-box", ti(o2)) {
              const e4 = we(t3, "width");
              e4 !== void 0 && (t3.width = e4);
            }
            if (ti(n2))
              if (t3.style.height === "")
                t3.height = t3.width / (e3 || 2);
              else {
                const e4 = we(t3, "height");
                e4 !== void 0 && (t3.height = e4);
              }
          }(t2, e2), i2) : null;
        }
        releaseContext(t2) {
          const e2 = t2.canvas;
          if (!e2.$chartjs)
            return false;
          const i2 = e2.$chartjs.initial;
          ["height", "width"].forEach((t3) => {
            const n3 = i2[t3];
            $(n3) ? e2.removeAttribute(t3) : e2.setAttribute(t3, n3);
          });
          const n2 = i2.style || {};
          return Object.keys(n2).forEach((t3) => {
            e2.style[t3] = n2[t3];
          }), e2.width = e2.width, delete e2.$chartjs, true;
        }
        addEventListener(t2, e2, i2) {
          this.removeEventListener(t2, e2);
          const n2 = t2.$proxies || (t2.$proxies = {}), o2 = { attach: ni, detach: oi, resize: li }[e2] || hi;
          n2[e2] = o2(t2, e2, i2);
        }
        removeEventListener(t2, e2) {
          const i2 = t2.$proxies || (t2.$proxies = {}), n2 = i2[e2];
          if (!n2)
            return;
          ({ attach: ci, detach: ci, resize: ci }[e2] || ii)(t2, e2, n2), i2[e2] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(t2, e2, i2, n2) {
          return _e(t2, e2, i2, n2);
        }
        isAttached(t2) {
          const e2 = de(t2);
          return !(!e2 || !de(e2));
        }
      }
      var ui = Object.freeze({ __proto__: null, BasePlatform: Ze, BasicPlatform: Qe, DomPlatform: di });
      const fi = (t2) => t2 === 0 || t2 === 1, gi = (t2, e2, i2) => -Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - e2) * _t / i2), pi = (t2, e2, i2) => Math.pow(2, -10 * t2) * Math.sin((t2 - e2) * _t / i2) + 1, mi = { linear: (t2) => t2, easeInQuad: (t2) => t2 * t2, easeOutQuad: (t2) => -t2 * (t2 - 2), easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1), easeInCubic: (t2) => t2 * t2 * t2, easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1, easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2), easeInQuart: (t2) => t2 * t2 * t2 * t2, easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1), easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2), easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2, easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1, easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2), easeInSine: (t2) => 1 - Math.cos(t2 * Mt), easeOutSine: (t2) => Math.sin(t2 * Mt), easeInOutSine: (t2) => -0.5 * (Math.cos(bt * t2) - 1), easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)), easeOutExpo: (t2) => t2 === 1 ? 1 : 1 - Math.pow(2, -10 * t2), easeInOutExpo: (t2) => fi(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (2 * t2 - 1)) : 0.5 * (2 - Math.pow(2, -10 * (2 * t2 - 1))), easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1), easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2), easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1), easeInElastic: (t2) => fi(t2) ? t2 : gi(t2, 0.075, 0.3), easeOutElastic: (t2) => fi(t2) ? t2 : pi(t2, 0.075, 0.3), easeInOutElastic(t2) {
        const e2 = 0.1125;
        return fi(t2) ? t2 : t2 < 0.5 ? 0.5 * gi(2 * t2, e2, 0.45) : 0.5 + 0.5 * pi(2 * t2 - 1, e2, 0.45);
      }, easeInBack(t2) {
        const e2 = 1.70158;
        return t2 * t2 * ((e2 + 1) * t2 - e2);
      }, easeOutBack(t2) {
        const e2 = 1.70158;
        return (t2 -= 1) * t2 * ((e2 + 1) * t2 + e2) + 1;
      }, easeInOutBack(t2) {
        let e2 = 1.70158;
        return (t2 /= 0.5) < 1 ? t2 * t2 * ((1 + (e2 *= 1.525)) * t2 - e2) * 0.5 : 0.5 * ((t2 -= 2) * t2 * ((1 + (e2 *= 1.525)) * t2 + e2) + 2);
      }, easeInBounce: (t2) => 1 - mi.easeOutBounce(1 - t2), easeOutBounce(t2) {
        const e2 = 7.5625, i2 = 2.75;
        return t2 < 1 / i2 ? e2 * t2 * t2 : t2 < 2 / i2 ? e2 * (t2 -= 1.5 / i2) * t2 + 0.75 : t2 < 2.5 / i2 ? e2 * (t2 -= 2.25 / i2) * t2 + 0.9375 : e2 * (t2 -= 2.625 / i2) * t2 + 0.984375;
      }, easeInOutBounce: (t2) => t2 < 0.5 ? 0.5 * mi.easeInBounce(2 * t2) : 0.5 * mi.easeOutBounce(2 * t2 - 1) + 0.5 }, xi = "transparent", bi = { boolean: (t2, e2, i2) => i2 > 0.5 ? e2 : t2, color(t2, e2, i2) {
        const n2 = W(t2 || xi), o2 = n2.valid && W(e2 || xi);
        return o2 && o2.valid ? o2.mix(n2, i2).hexString() : e2;
      }, number: (t2, e2, i2) => t2 + (e2 - t2) * i2 };
      class _i {
        constructor(t2, e2, i2, n2) {
          const o2 = e2[i2];
          n2 = Ve([t2.to, n2, o2, t2.from]);
          const s2 = Ve([t2.from, o2, n2]);
          this._active = true, this._fn = t2.fn || bi[t2.type || typeof s2], this._easing = mi[t2.easing] || mi.linear, this._start = Math.floor(Date.now() + (t2.delay || 0)), this._duration = this._total = Math.floor(t2.duration), this._loop = !!t2.loop, this._target = e2, this._prop = i2, this._from = s2, this._to = n2, this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(t2, e2, i2) {
          const n2 = this;
          if (n2._active) {
            n2._notify(false);
            const o2 = n2._target[n2._prop], s2 = i2 - n2._start, a2 = n2._duration - s2;
            n2._start = i2, n2._duration = Math.floor(Math.max(a2, t2.duration)), n2._total += s2, n2._loop = !!t2.loop, n2._to = Ve([t2.to, e2, o2, t2.from]), n2._from = Ve([t2.from, o2, e2]);
          }
        }
        cancel() {
          const t2 = this;
          t2._active && (t2.tick(Date.now()), t2._active = false, t2._notify(false));
        }
        tick(t2) {
          const e2 = this, i2 = t2 - e2._start, n2 = e2._duration, o2 = e2._prop, s2 = e2._from, a2 = e2._loop, r2 = e2._to;
          let l2;
          if (e2._active = s2 !== r2 && (a2 || i2 < n2), !e2._active)
            return e2._target[o2] = r2, void e2._notify(true);
          i2 < 0 ? e2._target[o2] = s2 : (l2 = i2 / n2 % 2, l2 = a2 && l2 > 1 ? 2 - l2 : l2, l2 = e2._easing(Math.min(1, Math.max(0, l2))), e2._target[o2] = e2._fn(s2, r2, l2));
        }
        wait() {
          const t2 = this._promises || (this._promises = []);
          return new Promise((e2, i2) => {
            t2.push({ res: e2, rej: i2 });
          });
        }
        _notify(t2) {
          const e2 = t2 ? "res" : "rej", i2 = this._promises || [];
          for (let t3 = 0; t3 < i2.length; t3++)
            i2[t3][e2]();
        }
      }
      xt.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 });
      const yi = Object.keys(xt.animation);
      xt.describe("animation", { _fallback: false, _indexable: false, _scriptable: (t2) => t2 !== "onProgress" && t2 !== "onComplete" && t2 !== "fn" }), xt.set("animations", { colors: { type: "color", properties: ["color", "borderColor", "backgroundColor"] }, numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius", "tension"] } }), xt.describe("animations", { _fallback: "animation" }), xt.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: (t2) => 0 | t2 } } } });
      class vi {
        constructor(t2, e2) {
          this._chart = t2, this._properties = new Map(), this.configure(e2);
        }
        configure(t2) {
          if (!U(t2))
            return;
          const e2 = this._properties;
          Object.getOwnPropertyNames(t2).forEach((i2) => {
            const n2 = t2[i2];
            if (!U(n2))
              return;
            const o2 = {};
            for (const t3 of yi)
              o2[t3] = n2[t3];
            (Y(n2.properties) && n2.properties || [i2]).forEach((t3) => {
              t3 !== i2 && e2.has(t3) || e2.set(t3, o2);
            });
          });
        }
        _animateOptions(t2, e2) {
          const i2 = e2.options, n2 = function(t3, e3) {
            if (!e3)
              return;
            let i3 = t3.options;
            if (!i3)
              return void (t3.options = e3);
            i3.$shared && (t3.options = i3 = Object.assign({}, i3, { $shared: false, $animations: {} }));
            return i3;
          }(t2, i2);
          if (!n2)
            return [];
          const o2 = this._createAnimations(n2, i2);
          return i2.$shared && function(t3, e3) {
            const i3 = [], n3 = Object.keys(e3);
            for (let e4 = 0; e4 < n3.length; e4++) {
              const o3 = t3[n3[e4]];
              o3 && o3.active() && i3.push(o3.wait());
            }
            return Promise.all(i3);
          }(t2.options.$animations, i2).then(() => {
            t2.options = i2;
          }, () => {
          }), o2;
        }
        _createAnimations(t2, e2) {
          const i2 = this._properties, n2 = [], o2 = t2.$animations || (t2.$animations = {}), s2 = Object.keys(e2), a2 = Date.now();
          let r2;
          for (r2 = s2.length - 1; r2 >= 0; --r2) {
            const l2 = s2[r2];
            if (l2.charAt(0) === "$")
              continue;
            if (l2 === "options") {
              n2.push(...this._animateOptions(t2, e2));
              continue;
            }
            const c2 = e2[l2];
            let h2 = o2[l2];
            const d2 = i2.get(l2);
            if (h2) {
              if (d2 && h2.active()) {
                h2.update(d2, c2, a2);
                continue;
              }
              h2.cancel();
            }
            d2 && d2.duration ? (o2[l2] = h2 = new _i(d2, t2, l2, c2), n2.push(h2)) : t2[l2] = c2;
          }
          return n2;
        }
        update(t2, e2) {
          if (this._properties.size === 0)
            return void Object.assign(t2, e2);
          const i2 = this._createAnimations(t2, e2);
          return i2.length ? (a.add(this._chart, i2), true) : void 0;
        }
      }
      function wi(t2, e2) {
        const i2 = t2 && t2.options || {}, n2 = i2.reverse, o2 = i2.min === void 0 ? e2 : 0, s2 = i2.max === void 0 ? e2 : 0;
        return { start: n2 ? s2 : o2, end: n2 ? o2 : s2 };
      }
      function Mi(t2, e2) {
        const i2 = [], n2 = t2._getSortedDatasetMetas(e2);
        let o2, s2;
        for (o2 = 0, s2 = n2.length; o2 < s2; ++o2)
          i2.push(n2[o2].index);
        return i2;
      }
      function ki(t2, e2, i2, n2) {
        const o2 = t2.keys, s2 = n2.mode === "single";
        let a2, r2, l2, c2;
        if (e2 !== null) {
          for (a2 = 0, r2 = o2.length; a2 < r2; ++a2) {
            if (l2 = +o2[a2], l2 === i2) {
              if (n2.all)
                continue;
              break;
            }
            c2 = t2.values[l2], X(c2) && (s2 || e2 === 0 || Dt(e2) === Dt(c2)) && (e2 += c2);
          }
          return e2;
        }
      }
      function Si(t2, e2) {
        const i2 = t2 && t2.options.stacked;
        return i2 || i2 === void 0 && e2.stack !== void 0;
      }
      function Pi(t2, e2, i2) {
        const n2 = t2[e2] || (t2[e2] = {});
        return n2[i2] || (n2[i2] = {});
      }
      function Di(t2, e2, i2) {
        for (const n2 of e2.getMatchingVisibleMetas("bar").reverse()) {
          const e3 = t2[n2.index];
          if (i2 && e3 > 0 || !i2 && e3 < 0)
            return n2.index;
        }
        return null;
      }
      function Ci(t2, e2) {
        const { chart: i2, _cachedMeta: n2 } = t2, o2 = i2._stacks || (i2._stacks = {}), { iScale: s2, vScale: a2, index: r2 } = n2, l2 = s2.axis, c2 = a2.axis, h2 = function(t3, e3, i3) {
          return `${t3.id}.${e3.id}.${i3.stack || i3.type}`;
        }(s2, a2, n2), d2 = e2.length;
        let u2;
        for (let t3 = 0; t3 < d2; ++t3) {
          const i3 = e2[t3], { [l2]: n3, [c2]: s3 } = i3;
          u2 = (i3._stacks || (i3._stacks = {}))[c2] = Pi(o2, h2, n3), u2[r2] = s3, u2._top = Di(u2, a2, true), u2._bottom = Di(u2, a2, false);
        }
      }
      function Oi(t2, e2) {
        const i2 = t2.scales;
        return Object.keys(i2).filter((t3) => i2[t3].axis === e2).shift();
      }
      function Ti(t2, e2) {
        const i2 = t2.vScale && t2.vScale.axis;
        if (i2) {
          e2 = e2 || t2._parsed;
          for (const n2 of e2) {
            const e3 = n2._stacks;
            if (!e3 || e3[i2] === void 0 || e3[i2][t2.index] === void 0)
              return;
            delete e3[i2][t2.index];
          }
        }
      }
      const Ai = (t2) => t2 === "reset" || t2 === "none", Li = (t2, e2) => e2 ? t2 : Object.assign({}, t2);
      class Ri {
        constructor(t2, e2) {
          this.chart = t2, this._ctx = t2.ctx, this.index = e2, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.$context = void 0, this._syncList = [], this.initialize();
        }
        initialize() {
          const t2 = this, e2 = t2._cachedMeta;
          t2.configure(), t2.linkScales(), e2._stacked = Si(e2.vScale, e2), t2.addElements();
        }
        updateIndex(t2) {
          this.index !== t2 && Ti(this._cachedMeta), this.index = t2;
        }
        linkScales() {
          const t2 = this, e2 = t2.chart, i2 = t2._cachedMeta, n2 = t2.getDataset(), o2 = (t3, e3, i3, n3) => t3 === "x" ? e3 : t3 === "r" ? n3 : i3, s2 = i2.xAxisID = K(n2.xAxisID, Oi(e2, "x")), a2 = i2.yAxisID = K(n2.yAxisID, Oi(e2, "y")), r2 = i2.rAxisID = K(n2.rAxisID, Oi(e2, "r")), l2 = i2.indexAxis, c2 = i2.iAxisID = o2(l2, s2, a2, r2), h2 = i2.vAxisID = o2(l2, a2, s2, r2);
          i2.xScale = t2.getScaleForId(s2), i2.yScale = t2.getScaleForId(a2), i2.rScale = t2.getScaleForId(r2), i2.iScale = t2.getScaleForId(c2), i2.vScale = t2.getScaleForId(h2);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(t2) {
          return this.chart.scales[t2];
        }
        _getOtherScale(t2) {
          const e2 = this._cachedMeta;
          return t2 === e2.iScale ? e2.vScale : e2.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const t2 = this._cachedMeta;
          this._data && ce(this._data, this), t2._stacked && Ti(t2);
        }
        _dataCheck() {
          const t2 = this, e2 = t2.getDataset(), i2 = e2.data || (e2.data = []), n2 = t2._data;
          if (U(i2))
            t2._data = function(t3) {
              const e3 = Object.keys(t3), i3 = new Array(e3.length);
              let n3, o2, s2;
              for (n3 = 0, o2 = e3.length; n3 < o2; ++n3)
                s2 = e3[n3], i3[n3] = { x: s2, y: t3[s2] };
              return i3;
            }(i2);
          else if (n2 !== i2) {
            if (n2) {
              ce(n2, t2);
              const e3 = t2._cachedMeta;
              Ti(e3), e3._parsed = [];
            }
            i2 && Object.isExtensible(i2) && le(i2, t2), t2._syncList = [], t2._data = i2;
          }
        }
        addElements() {
          const t2 = this, e2 = t2._cachedMeta;
          t2._dataCheck(), t2.datasetElementType && (e2.dataset = new t2.datasetElementType());
        }
        buildOrUpdateElements(t2) {
          const e2 = this, i2 = e2._cachedMeta, n2 = e2.getDataset();
          let o2 = false;
          e2._dataCheck();
          const s2 = i2._stacked;
          i2._stacked = Si(i2.vScale, i2), i2.stack !== n2.stack && (o2 = true, Ti(i2), i2.stack = n2.stack), e2._resyncElements(t2), (o2 || s2 !== i2._stacked) && Ci(e2, i2._parsed);
        }
        configure() {
          const t2 = this, e2 = t2.chart.config, i2 = e2.datasetScopeKeys(t2._type), n2 = e2.getOptionScopes(t2.getDataset(), i2, true);
          t2.options = e2.createResolver(n2, t2.getContext()), t2._parsing = t2.options.parsing;
        }
        parse(t2, e2) {
          const i2 = this, { _cachedMeta: n2, _data: o2 } = i2, { iScale: s2, _stacked: a2 } = n2, r2 = s2.axis;
          let l2, c2, h2, d2 = t2 === 0 && e2 === o2.length || n2._sorted, u2 = t2 > 0 && n2._parsed[t2 - 1];
          if (i2._parsing === false)
            n2._parsed = o2, n2._sorted = true, h2 = o2;
          else {
            h2 = Y(o2[t2]) ? i2.parseArrayData(n2, o2, t2, e2) : U(o2[t2]) ? i2.parseObjectData(n2, o2, t2, e2) : i2.parsePrimitiveData(n2, o2, t2, e2);
            const s3 = () => c2[r2] === null || u2 && c2[r2] < u2[r2];
            for (l2 = 0; l2 < e2; ++l2)
              n2._parsed[l2 + t2] = c2 = h2[l2], d2 && (s3() && (d2 = false), u2 = c2);
            n2._sorted = d2;
          }
          a2 && Ci(i2, h2);
        }
        parsePrimitiveData(t2, e2, i2, n2) {
          const { iScale: o2, vScale: s2 } = t2, a2 = o2.axis, r2 = s2.axis, l2 = o2.getLabels(), c2 = o2 === s2, h2 = new Array(n2);
          let d2, u2, f2;
          for (d2 = 0, u2 = n2; d2 < u2; ++d2)
            f2 = d2 + i2, h2[d2] = { [a2]: c2 || o2.parse(l2[f2], f2), [r2]: s2.parse(e2[f2], f2) };
          return h2;
        }
        parseArrayData(t2, e2, i2, n2) {
          const { xScale: o2, yScale: s2 } = t2, a2 = new Array(n2);
          let r2, l2, c2, h2;
          for (r2 = 0, l2 = n2; r2 < l2; ++r2)
            c2 = r2 + i2, h2 = e2[c2], a2[r2] = { x: o2.parse(h2[0], c2), y: s2.parse(h2[1], c2) };
          return a2;
        }
        parseObjectData(t2, e2, i2, n2) {
          const { xScale: o2, yScale: s2 } = t2, { xAxisKey: a2 = "x", yAxisKey: r2 = "y" } = this._parsing, l2 = new Array(n2);
          let c2, h2, d2, u2;
          for (c2 = 0, h2 = n2; c2 < h2; ++c2)
            d2 = c2 + i2, u2 = e2[d2], l2[c2] = { x: o2.parse(lt(u2, a2), d2), y: s2.parse(lt(u2, r2), d2) };
          return l2;
        }
        getParsed(t2) {
          return this._cachedMeta._parsed[t2];
        }
        getDataElement(t2) {
          return this._cachedMeta.data[t2];
        }
        applyStack(t2, e2, i2) {
          const n2 = this.chart, o2 = this._cachedMeta, s2 = e2[t2.axis];
          return ki({ keys: Mi(n2, true), values: e2._stacks[t2.axis] }, s2, o2.index, { mode: i2 });
        }
        updateRangeFromParsed(t2, e2, i2, n2) {
          const o2 = i2[e2.axis];
          let s2 = o2 === null ? NaN : o2;
          const a2 = n2 && i2._stacks[e2.axis];
          n2 && a2 && (n2.values = a2, t2.min = Math.min(t2.min, s2), t2.max = Math.max(t2.max, s2), s2 = ki(n2, o2, this._cachedMeta.index, { all: true })), t2.min = Math.min(t2.min, s2), t2.max = Math.max(t2.max, s2);
        }
        getMinMax(t2, e2) {
          const i2 = this, n2 = i2._cachedMeta, o2 = n2._parsed, s2 = n2._sorted && t2 === n2.iScale, a2 = o2.length, r2 = i2._getOtherScale(t2), l2 = e2 && n2._stacked && { keys: Mi(i2.chart, true), values: null }, c2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h2, max: d2 } = function(t3) {
            const { min: e3, max: i3, minDefined: n3, maxDefined: o3 } = t3.getUserBounds();
            return { min: n3 ? e3 : Number.NEGATIVE_INFINITY, max: o3 ? i3 : Number.POSITIVE_INFINITY };
          }(r2);
          let u2, f2, g2, p2;
          function m2() {
            return g2 = o2[u2], f2 = g2[t2.axis], p2 = g2[r2.axis], !X(f2) || h2 > p2 || d2 < p2;
          }
          for (u2 = 0; u2 < a2 && (m2() || (i2.updateRangeFromParsed(c2, t2, g2, l2), !s2)); ++u2)
            ;
          if (s2) {
            for (u2 = a2 - 1; u2 >= 0; --u2)
              if (!m2()) {
                i2.updateRangeFromParsed(c2, t2, g2, l2);
                break;
              }
          }
          return c2;
        }
        getAllParsedValues(t2) {
          const e2 = this._cachedMeta._parsed, i2 = [];
          let n2, o2, s2;
          for (n2 = 0, o2 = e2.length; n2 < o2; ++n2)
            s2 = e2[n2][t2.axis], X(s2) && i2.push(s2);
          return i2;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta, i2 = e2.iScale, n2 = e2.vScale, o2 = this.getParsed(t2);
          return { label: i2 ? "" + i2.getLabelForValue(o2[i2.axis]) : "", value: n2 ? "" + n2.getLabelForValue(o2[n2.axis]) : "" };
        }
        _update(t2) {
          const e2 = this, i2 = e2._cachedMeta;
          e2.configure(), e2._cachedDataOpts = {}, e2.update(t2 || "default"), i2._clip = function(t3) {
            let e3, i3, n2, o2;
            return U(t3) ? (e3 = t3.top, i3 = t3.right, n2 = t3.bottom, o2 = t3.left) : e3 = i3 = n2 = o2 = t3, { top: e3, right: i3, bottom: n2, left: o2 };
          }(K(e2.options.clip, function(t3, e3, i3) {
            if (i3 === false)
              return false;
            const n2 = wi(t3, i3), o2 = wi(e3, i3);
            return { top: o2.end, right: n2.end, bottom: o2.start, left: n2.start };
          }(i2.xScale, i2.yScale, e2.getMaxOverflow())));
        }
        update(t2) {
        }
        draw() {
          const t2 = this, e2 = t2._ctx, i2 = t2.chart, n2 = t2._cachedMeta, o2 = n2.data || [], s2 = i2.chartArea, a2 = [], r2 = t2._drawStart || 0, l2 = t2._drawCount || o2.length - r2;
          let c2;
          for (n2.dataset && n2.dataset.draw(e2, s2, r2, l2), c2 = r2; c2 < r2 + l2; ++c2) {
            const t3 = o2[c2];
            t3.active ? a2.push(t3) : t3.draw(e2, s2);
          }
          for (c2 = 0; c2 < a2.length; ++c2)
            a2[c2].draw(e2, s2);
        }
        getStyle(t2, e2) {
          const i2 = e2 ? "active" : "default";
          return t2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i2) : this.resolveDataElementOptions(t2 || 0, i2);
        }
        getContext(t2, e2, i2) {
          const n2 = this, o2 = n2.getDataset();
          let s2;
          if (t2 >= 0 && t2 < n2._cachedMeta.data.length) {
            const e3 = n2._cachedMeta.data[t2];
            s2 = e3.$context || (e3.$context = function(t3, e4, i3) {
              return Object.assign(Object.create(t3), { active: false, dataIndex: e4, parsed: void 0, raw: void 0, element: i3, index: e4, mode: "default", type: "data" });
            }(n2.getContext(), t2, e3)), s2.parsed = n2.getParsed(t2), s2.raw = o2.data[t2], s2.index = s2.dataIndex = t2;
          } else
            s2 = n2.$context || (n2.$context = function(t3, e3) {
              return Object.assign(Object.create(t3), { active: false, dataset: void 0, datasetIndex: e3, index: e3, mode: "default", type: "dataset" });
            }(n2.chart.getContext(), n2.index)), s2.dataset = o2, s2.index = s2.datasetIndex = n2.index;
          return s2.active = !!e2, s2.mode = i2, s2;
        }
        resolveDatasetElementOptions(t2) {
          return this._resolveElementOptions(this.datasetElementType.id, t2);
        }
        resolveDataElementOptions(t2, e2) {
          return this._resolveElementOptions(this.dataElementType.id, e2, t2);
        }
        _resolveElementOptions(t2, e2 = "default", i2) {
          const n2 = this, o2 = e2 === "active", s2 = n2._cachedDataOpts, a2 = t2 + "-" + e2, r2 = s2[a2], l2 = n2.enableOptionSharing && ht(i2);
          if (r2)
            return Li(r2, l2);
          const c2 = n2.chart.config, h2 = c2.datasetElementScopeKeys(n2._type, t2), d2 = o2 ? [`${t2}Hover`, "hover", t2, ""] : [t2, ""], u2 = c2.getOptionScopes(n2.getDataset(), h2), f2 = Object.keys(xt.elements[t2]), g2 = c2.resolveNamedOptions(u2, f2, () => n2.getContext(i2, o2), d2);
          return g2.$shared && (g2.$shared = l2, s2[a2] = Object.freeze(Li(g2, l2))), g2;
        }
        _resolveAnimations(t2, e2, i2) {
          const n2 = this, o2 = n2.chart, s2 = n2._cachedDataOpts, a2 = `animation-${e2}`, r2 = s2[a2];
          if (r2)
            return r2;
          let l2;
          if (o2.options.animation !== false) {
            const o3 = n2.chart.config, s3 = o3.datasetAnimationScopeKeys(n2._type, e2), a3 = o3.getOptionScopes(n2.getDataset(), s3);
            l2 = o3.createResolver(a3, n2.getContext(t2, i2, e2));
          }
          const c2 = new vi(o2, l2 && l2.animations);
          return l2 && l2._cacheable && (s2[a2] = Object.freeze(c2)), c2;
        }
        getSharedOptions(t2) {
          if (t2.$shared)
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, t2));
        }
        includeOptions(t2, e2) {
          return !e2 || Ai(t2) || this.chart._animationsDisabled;
        }
        updateElement(t2, e2, i2, n2) {
          Ai(n2) ? Object.assign(t2, i2) : this._resolveAnimations(e2, n2).update(t2, i2);
        }
        updateSharedOptions(t2, e2, i2) {
          t2 && !Ai(e2) && this._resolveAnimations(void 0, e2).update(t2, i2);
        }
        _setStyle(t2, e2, i2, n2) {
          t2.active = n2;
          const o2 = this.getStyle(e2, n2);
          this._resolveAnimations(e2, i2, n2).update(t2, { options: !n2 && this.getSharedOptions(o2) || o2 });
        }
        removeHoverStyle(t2, e2, i2) {
          this._setStyle(t2, i2, "active", false);
        }
        setHoverStyle(t2, e2, i2) {
          this._setStyle(t2, i2, "active", true);
        }
        _removeDatasetHoverStyle() {
          const t2 = this._cachedMeta.dataset;
          t2 && this._setStyle(t2, void 0, "active", false);
        }
        _setDatasetHoverStyle() {
          const t2 = this._cachedMeta.dataset;
          t2 && this._setStyle(t2, void 0, "active", true);
        }
        _resyncElements(t2) {
          const e2 = this, i2 = e2._data, n2 = e2._cachedMeta.data;
          for (const [t3, i3, n3] of e2._syncList)
            e2[t3](i3, n3);
          e2._syncList = [];
          const o2 = n2.length, s2 = i2.length, a2 = Math.min(s2, o2);
          a2 && e2.parse(0, a2), s2 > o2 ? e2._insertElements(o2, s2 - o2, t2) : s2 < o2 && e2._removeElements(s2, o2 - s2);
        }
        _insertElements(t2, e2, i2 = true) {
          const n2 = this, o2 = n2._cachedMeta, s2 = o2.data, a2 = t2 + e2;
          let r2;
          const l2 = (t3) => {
            for (t3.length += e2, r2 = t3.length - 1; r2 >= a2; r2--)
              t3[r2] = t3[r2 - e2];
          };
          for (l2(s2), r2 = t2; r2 < a2; ++r2)
            s2[r2] = new n2.dataElementType();
          n2._parsing && l2(o2._parsed), n2.parse(t2, e2), i2 && n2.updateElements(s2, t2, e2, "reset");
        }
        updateElements(t2, e2, i2, n2) {
        }
        _removeElements(t2, e2) {
          const i2 = this._cachedMeta;
          if (this._parsing) {
            const n2 = i2._parsed.splice(t2, e2);
            i2._stacked && Ti(i2, n2);
          }
          i2.data.splice(t2, e2);
        }
        _onDataPush() {
          const t2 = arguments.length;
          this._syncList.push(["_insertElements", this.getDataset().data.length - t2, t2]);
        }
        _onDataPop() {
          this._syncList.push(["_removeElements", this._cachedMeta.data.length - 1, 1]);
        }
        _onDataShift() {
          this._syncList.push(["_removeElements", 0, 1]);
        }
        _onDataSplice(t2, e2) {
          this._syncList.push(["_removeElements", t2, e2]), this._syncList.push(["_insertElements", t2, arguments.length - 2]);
        }
        _onDataUnshift() {
          this._syncList.push(["_insertElements", 0, arguments.length]);
        }
      }
      Ri.defaults = {}, Ri.prototype.datasetElementType = null, Ri.prototype.dataElementType = null;
      class Ei {
        constructor() {
          this.x = void 0, this.y = void 0, this.active = false, this.options = void 0, this.$animations = void 0;
        }
        tooltipPosition(t2) {
          const { x: e2, y: i2 } = this.getProps(["x", "y"], t2);
          return { x: e2, y: i2 };
        }
        hasValue() {
          return Tt(this.x) && Tt(this.y);
        }
        getProps(t2, e2) {
          const i2 = this, n2 = this.$animations;
          if (!e2 || !n2)
            return i2;
          const o2 = {};
          return t2.forEach((t3) => {
            o2[t3] = n2[t3] && n2[t3].active() ? n2[t3]._to : i2[t3];
          }), o2;
        }
      }
      Ei.defaults = {}, Ei.defaultRoutes = void 0;
      const Ii = new Map();
      function zi(t2, e2, i2) {
        return function(t3, e3) {
          e3 = e3 || {};
          const i3 = t3 + JSON.stringify(e3);
          let n2 = Ii.get(i3);
          return n2 || (n2 = new Intl.NumberFormat(t3, e3), Ii.set(i3, n2)), n2;
        }(e2, i2).format(t2);
      }
      const Fi = { values: (t2) => Y(t2) ? t2 : "" + t2, numeric(t2, e2, i2) {
        if (t2 === 0)
          return "0";
        const n2 = this.chart.options.locale;
        let o2, s2 = t2;
        if (i2.length > 1) {
          const e3 = Math.max(Math.abs(i2[0].value), Math.abs(i2[i2.length - 1].value));
          (e3 < 1e-4 || e3 > 1e15) && (o2 = "scientific"), s2 = function(t3, e4) {
            let i3 = e4.length > 3 ? e4[2].value - e4[1].value : e4[1].value - e4[0].value;
            Math.abs(i3) >= 1 && t3 !== Math.floor(t3) && (i3 = t3 - Math.floor(t3));
            return i3;
          }(t2, i2);
        }
        const a2 = Pt(Math.abs(s2)), r2 = Math.max(Math.min(-1 * Math.floor(a2), 20), 0), l2 = { notation: o2, minimumFractionDigits: r2, maximumFractionDigits: r2 };
        return Object.assign(l2, this.options.ticks.format), zi(t2, n2, l2);
      }, logarithmic(t2, e2, i2) {
        if (t2 === 0)
          return "0";
        const n2 = t2 / Math.pow(10, Math.floor(Pt(t2)));
        return n2 === 1 || n2 === 2 || n2 === 5 ? Fi.numeric.call(this, t2, e2, i2) : "";
      } };
      var Vi = { formatters: Fi };
      function Bi(t2, e2) {
        const i2 = t2.options.ticks, n2 = i2.maxTicksLimit || function(t3) {
          const e3 = t3.options.offset, i3 = t3._tickSize(), n3 = t3._length / i3 + (e3 ? 0 : 1), o3 = t3._maxLength / i3;
          return Math.floor(Math.min(n3, o3));
        }(t2), o2 = i2.major.enabled ? function(t3) {
          const e3 = [];
          let i3, n3;
          for (i3 = 0, n3 = t3.length; i3 < n3; i3++)
            t3[i3].major && e3.push(i3);
          return e3;
        }(e2) : [], s2 = o2.length, a2 = o2[0], r2 = o2[s2 - 1], l2 = [];
        if (s2 > n2)
          return function(t3, e3, i3, n3) {
            let o3, s3 = 0, a3 = i3[0];
            for (n3 = Math.ceil(n3), o3 = 0; o3 < t3.length; o3++)
              o3 === a3 && (e3.push(t3[o3]), s3++, a3 = i3[s3 * n3]);
          }(e2, l2, o2, s2 / n2), l2;
        const c2 = function(t3, e3, i3) {
          const n3 = function(t4) {
            const e4 = t4.length;
            let i4, n4;
            if (e4 < 2)
              return false;
            for (n4 = t4[0], i4 = 1; i4 < e4; ++i4)
              if (t4[i4] - t4[i4 - 1] !== n4)
                return false;
            return n4;
          }(t3), o3 = e3.length / i3;
          if (!n3)
            return Math.max(o3, 1);
          const s3 = Ot(n3);
          for (let t4 = 0, e4 = s3.length - 1; t4 < e4; t4++) {
            const e5 = s3[t4];
            if (e5 > o3)
              return e5;
          }
          return Math.max(o3, 1);
        }(o2, e2, n2);
        if (s2 > 0) {
          let t3, i3;
          const n3 = s2 > 1 ? Math.round((r2 - a2) / (s2 - 1)) : null;
          for (Wi(e2, l2, c2, $(n3) ? 0 : a2 - n3, a2), t3 = 0, i3 = s2 - 1; t3 < i3; t3++)
            Wi(e2, l2, c2, o2[t3], o2[t3 + 1]);
          return Wi(e2, l2, c2, r2, $(n3) ? e2.length : r2 + n3), l2;
        }
        return Wi(e2, l2, c2), l2;
      }
      function Wi(t2, e2, i2, n2, o2) {
        const s2 = K(n2, 0), a2 = Math.min(K(o2, t2.length), t2.length);
        let r2, l2, c2, h2 = 0;
        for (i2 = Math.ceil(i2), o2 && (r2 = o2 - n2, i2 = r2 / Math.floor(r2 / i2)), c2 = s2; c2 < 0; )
          h2++, c2 = Math.round(s2 + h2 * i2);
        for (l2 = Math.max(s2, 0); l2 < a2; l2++)
          l2 === c2 && (e2.push(t2[l2]), h2++, c2 = Math.round(s2 + h2 * i2));
      }
      xt.set("scale", { display: true, offset: false, reverse: false, beginAtZero: false, bounds: "ticks", grace: 0, grid: { display: true, lineWidth: 1, drawBorder: true, drawOnChartArea: true, drawTicks: true, tickLength: 8, tickWidth: (t2, e2) => e2.lineWidth, tickColor: (t2, e2) => e2.color, offset: false, borderDash: [], borderDashOffset: 0, borderWidth: 1 }, title: { display: false, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: false, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: true, autoSkip: true, autoSkipPadding: 3, labelOffset: 0, callback: Vi.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: false, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), xt.route("scale.ticks", "color", "", "color"), xt.route("scale.grid", "color", "", "borderColor"), xt.route("scale.grid", "borderColor", "", "borderColor"), xt.route("scale.title", "color", "", "color"), xt.describe("scale", { _fallback: false, _scriptable: (t2) => !t2.startsWith("before") && !t2.startsWith("after") && t2 !== "callback" && t2 !== "parser", _indexable: (t2) => t2 !== "borderDash" && t2 !== "tickBorderDash" }), xt.describe("scales", { _fallback: "scale" });
      const Hi = (t2, e2, i2) => e2 === "top" || e2 === "left" ? t2[e2] + i2 : t2[e2] - i2;
      function Ni(t2, e2) {
        const i2 = [], n2 = t2.length / e2, o2 = t2.length;
        let s2 = 0;
        for (; s2 < o2; s2 += n2)
          i2.push(t2[Math.floor(s2)]);
        return i2;
      }
      function ji(t2, e2, i2) {
        const n2 = t2.ticks.length, o2 = Math.min(e2, n2 - 1), s2 = t2._startPixel, a2 = t2._endPixel, r2 = 1e-6;
        let l2, c2 = t2.getPixelForTick(o2);
        if (!(i2 && (l2 = n2 === 1 ? Math.max(c2 - s2, a2 - c2) : e2 === 0 ? (t2.getPixelForTick(1) - c2) / 2 : (c2 - t2.getPixelForTick(o2 - 1)) / 2, c2 += o2 < e2 ? l2 : -l2, c2 < s2 - r2 || c2 > a2 + r2)))
          return c2;
      }
      function $i(t2) {
        return t2.drawTicks ? t2.tickLength : 0;
      }
      function Yi(t2, e2) {
        if (!t2.display)
          return 0;
        const i2 = Fe(t2.font, e2), n2 = ze(t2.padding);
        return (Y(t2.text) ? t2.text.length : 1) * i2.lineHeight + n2.height;
      }
      function Ui(t2, e2, i2) {
        let o2 = n(t2);
        return (i2 && e2 !== "right" || !i2 && e2 === "right") && (o2 = ((t3) => t3 === "left" ? "right" : t3 === "right" ? "left" : t3)(o2)), o2;
      }
      class Xi extends Ei {
        constructor(t2) {
          super(), this.id = t2.id, this.type = t2.type, this.options = void 0, this.ctx = t2.ctx, this.chart = t2.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
        }
        init(t2) {
          const e2 = this;
          e2.options = t2.setContext(e2.getContext()), e2.axis = t2.axis, e2._userMin = e2.parse(t2.min), e2._userMax = e2.parse(t2.max), e2._suggestedMin = e2.parse(t2.suggestedMin), e2._suggestedMax = e2.parse(t2.suggestedMax);
        }
        parse(t2, e2) {
          return t2;
        }
        getUserBounds() {
          let { _userMin: t2, _userMax: e2, _suggestedMin: i2, _suggestedMax: n2 } = this;
          return t2 = q(t2, Number.POSITIVE_INFINITY), e2 = q(e2, Number.NEGATIVE_INFINITY), i2 = q(i2, Number.POSITIVE_INFINITY), n2 = q(n2, Number.NEGATIVE_INFINITY), { min: q(t2, i2), max: q(e2, n2), minDefined: X(t2), maxDefined: X(e2) };
        }
        getMinMax(t2) {
          const e2 = this;
          let i2, { min: n2, max: o2, minDefined: s2, maxDefined: a2 } = e2.getUserBounds();
          if (s2 && a2)
            return { min: n2, max: o2 };
          const r2 = e2.getMatchingVisibleMetas();
          for (let l2 = 0, c2 = r2.length; l2 < c2; ++l2)
            i2 = r2[l2].controller.getMinMax(e2, t2), s2 || (n2 = Math.min(n2, i2.min)), a2 || (o2 = Math.max(o2, i2.max));
          return { min: q(n2, q(o2, n2)), max: q(o2, q(n2, o2)) };
        }
        getPadding() {
          const t2 = this;
          return { left: t2.paddingLeft || 0, top: t2.paddingTop || 0, right: t2.paddingRight || 0, bottom: t2.paddingBottom || 0 };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const t2 = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? t2.xLabels : t2.yLabels) || t2.labels || [];
        }
        beforeLayout() {
          this._cache = {}, this._dataLimitsCached = false;
        }
        beforeUpdate() {
          Q(this.options.beforeUpdate, [this]);
        }
        update(t2, e2, i2) {
          const n2 = this, o2 = n2.options.ticks, s2 = o2.sampleSize;
          n2.beforeUpdate(), n2.maxWidth = t2, n2.maxHeight = e2, n2._margins = i2 = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i2), n2.ticks = null, n2._labelSizes = null, n2._gridLineItems = null, n2._labelItems = null, n2.beforeSetDimensions(), n2.setDimensions(), n2.afterSetDimensions(), n2._maxLength = n2.isHorizontal() ? n2.width + i2.left + i2.right : n2.height + i2.top + i2.bottom, n2._dataLimitsCached || (n2.beforeDataLimits(), n2.determineDataLimits(), n2.afterDataLimits(), n2._range = Be(n2, n2.options.grace), n2._dataLimitsCached = true), n2.beforeBuildTicks(), n2.ticks = n2.buildTicks() || [], n2.afterBuildTicks();
          const a2 = s2 < n2.ticks.length;
          n2._convertTicksToLabels(a2 ? Ni(n2.ticks, s2) : n2.ticks), n2.configure(), n2.beforeCalculateLabelRotation(), n2.calculateLabelRotation(), n2.afterCalculateLabelRotation(), o2.display && (o2.autoSkip || o2.source === "auto") && (n2.ticks = Bi(n2, n2.ticks), n2._labelSizes = null), a2 && n2._convertTicksToLabels(n2.ticks), n2.beforeFit(), n2.fit(), n2.afterFit(), n2.afterUpdate();
        }
        configure() {
          const t2 = this;
          let e2, i2, n2 = t2.options.reverse;
          t2.isHorizontal() ? (e2 = t2.left, i2 = t2.right) : (e2 = t2.top, i2 = t2.bottom, n2 = !n2), t2._startPixel = e2, t2._endPixel = i2, t2._reversePixels = n2, t2._length = i2 - e2, t2._alignToPixels = t2.options.alignToPixels;
        }
        afterUpdate() {
          Q(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          Q(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          const t2 = this;
          t2.isHorizontal() ? (t2.width = t2.maxWidth, t2.left = 0, t2.right = t2.width) : (t2.height = t2.maxHeight, t2.top = 0, t2.bottom = t2.height), t2.paddingLeft = 0, t2.paddingTop = 0, t2.paddingRight = 0, t2.paddingBottom = 0;
        }
        afterSetDimensions() {
          Q(this.options.afterSetDimensions, [this]);
        }
        _callHooks(t2) {
          const e2 = this;
          e2.chart.notifyPlugins(t2, e2.getContext()), Q(e2.options[t2], [e2]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          Q(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(t2) {
          const e2 = this, i2 = e2.options.ticks;
          let n2, o2, s2;
          for (n2 = 0, o2 = t2.length; n2 < o2; n2++)
            s2 = t2[n2], s2.label = Q(i2.callback, [s2.value, n2, t2], e2);
          for (n2 = 0; n2 < o2; n2++)
            $(t2[n2].label) && (t2.splice(n2, 1), o2--, n2--);
        }
        afterTickToLabelConversion() {
          Q(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          Q(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const t2 = this, e2 = t2.options, i2 = e2.ticks, n2 = t2.ticks.length, o2 = i2.minRotation || 0, s2 = i2.maxRotation;
          let a2, r2, l2, c2 = o2;
          if (!t2._isVisible() || !i2.display || o2 >= s2 || n2 <= 1 || !t2.isHorizontal())
            return void (t2.labelRotation = o2);
          const h2 = t2._getLabelSizes(), d2 = h2.widest.width, u2 = h2.highest.height, f2 = Nt(t2.chart.width - d2, 0, t2.maxWidth);
          a2 = e2.offset ? t2.maxWidth / n2 : f2 / (n2 - 1), d2 + 6 > a2 && (a2 = f2 / (n2 - (e2.offset ? 0.5 : 1)), r2 = t2.maxHeight - $i(e2.grid) - i2.padding - Yi(e2.title, t2.chart.options.font), l2 = Math.sqrt(d2 * d2 + u2 * u2), c2 = It(Math.min(Math.asin(Math.min((h2.highest.height + 6) / a2, 1)), Math.asin(Math.min(r2 / l2, 1)) - Math.asin(u2 / l2))), c2 = Math.max(o2, Math.min(s2, c2))), t2.labelRotation = c2;
        }
        afterCalculateLabelRotation() {
          Q(this.options.afterCalculateLabelRotation, [this]);
        }
        beforeFit() {
          Q(this.options.beforeFit, [this]);
        }
        fit() {
          const t2 = this, e2 = { width: 0, height: 0 }, { chart: i2, options: { ticks: n2, title: o2, grid: s2 } } = t2, a2 = t2._isVisible(), r2 = t2.isHorizontal();
          if (a2) {
            const a3 = Yi(o2, i2.options.font);
            if (r2 ? (e2.width = t2.maxWidth, e2.height = $i(s2) + a3) : (e2.height = t2.maxHeight, e2.width = $i(s2) + a3), n2.display && t2.ticks.length) {
              const { first: i3, last: o3, widest: s3, highest: a4 } = t2._getLabelSizes(), l2 = 2 * n2.padding, c2 = Et(t2.labelRotation), h2 = Math.cos(c2), d2 = Math.sin(c2);
              if (r2) {
                const i4 = n2.mirror ? 0 : d2 * s3.width + h2 * a4.height;
                e2.height = Math.min(t2.maxHeight, e2.height + i4 + l2);
              } else {
                const i4 = n2.mirror ? 0 : h2 * s3.width + d2 * a4.height;
                e2.width = Math.min(t2.maxWidth, e2.width + i4 + l2);
              }
              t2._calculatePadding(i3, o3, d2, h2);
            }
          }
          t2._handleMargins(), r2 ? (t2.width = t2._length = i2.width - t2._margins.left - t2._margins.right, t2.height = e2.height) : (t2.width = e2.width, t2.height = t2._length = i2.height - t2._margins.top - t2._margins.bottom);
        }
        _calculatePadding(t2, e2, i2, n2) {
          const o2 = this, { ticks: { align: s2, padding: a2 }, position: r2 } = o2.options, l2 = o2.labelRotation !== 0, c2 = r2 !== "top" && o2.axis === "x";
          if (o2.isHorizontal()) {
            const r3 = o2.getPixelForTick(0) - o2.left, h2 = o2.right - o2.getPixelForTick(o2.ticks.length - 1);
            let d2 = 0, u2 = 0;
            l2 ? c2 ? (d2 = n2 * t2.width, u2 = i2 * e2.height) : (d2 = i2 * t2.height, u2 = n2 * e2.width) : s2 === "start" ? u2 = e2.width : s2 === "end" ? d2 = t2.width : (d2 = t2.width / 2, u2 = e2.width / 2), o2.paddingLeft = Math.max((d2 - r3 + a2) * o2.width / (o2.width - r3), 0), o2.paddingRight = Math.max((u2 - h2 + a2) * o2.width / (o2.width - h2), 0);
          } else {
            let i3 = e2.height / 2, n3 = t2.height / 2;
            s2 === "start" ? (i3 = 0, n3 = t2.height) : s2 === "end" && (i3 = e2.height, n3 = 0), o2.paddingTop = i3 + a2, o2.paddingBottom = n3 + a2;
          }
        }
        _handleMargins() {
          const t2 = this;
          t2._margins && (t2._margins.left = Math.max(t2.paddingLeft, t2._margins.left), t2._margins.top = Math.max(t2.paddingTop, t2._margins.top), t2._margins.right = Math.max(t2.paddingRight, t2._margins.right), t2._margins.bottom = Math.max(t2.paddingBottom, t2._margins.bottom));
        }
        afterFit() {
          Q(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const { axis: t2, position: e2 } = this.options;
          return e2 === "top" || e2 === "bottom" || t2 === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(t2) {
          const e2 = this;
          e2.beforeTickToLabelConversion(), e2.generateTickLabels(t2), e2.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          const t2 = this;
          let e2 = t2._labelSizes;
          if (!e2) {
            const i2 = t2.options.ticks.sampleSize;
            let n2 = t2.ticks;
            i2 < n2.length && (n2 = Ni(n2, i2)), t2._labelSizes = e2 = t2._computeLabelSizes(n2, n2.length);
          }
          return e2;
        }
        _computeLabelSizes(t2, e2) {
          const { ctx: i2, _longestTextCache: n2 } = this, o2 = [], s2 = [];
          let a2, r2, l2, c2, h2, d2, u2, f2, g2, p2, m2, x2 = 0, b2 = 0;
          for (a2 = 0; a2 < e2; ++a2) {
            if (c2 = t2[a2].label, h2 = this._resolveTickFontOptions(a2), i2.font = d2 = h2.string, u2 = n2[d2] = n2[d2] || { data: {}, gc: [] }, f2 = h2.lineHeight, g2 = p2 = 0, $(c2) || Y(c2)) {
              if (Y(c2))
                for (r2 = 0, l2 = c2.length; r2 < l2; ++r2)
                  m2 = c2[r2], $(m2) || Y(m2) || (g2 = Yt(i2, u2.data, u2.gc, g2, m2), p2 += f2);
            } else
              g2 = Yt(i2, u2.data, u2.gc, g2, c2), p2 = f2;
            o2.push(g2), s2.push(p2), x2 = Math.max(g2, x2), b2 = Math.max(p2, b2);
          }
          !function(t3, e3) {
            J(t3, (t4) => {
              const i3 = t4.gc, n3 = i3.length / 2;
              let o3;
              if (n3 > e3) {
                for (o3 = 0; o3 < n3; ++o3)
                  delete t4.data[i3[o3]];
                i3.splice(0, n3);
              }
            });
          }(n2, e2);
          const _2 = o2.indexOf(x2), y2 = s2.indexOf(b2), v2 = (t3) => ({ width: o2[t3] || 0, height: s2[t3] || 0 });
          return { first: v2(0), last: v2(e2 - 1), widest: v2(_2), highest: v2(y2), widths: o2, heights: s2 };
        }
        getLabelForValue(t2) {
          return t2;
        }
        getPixelForValue(t2, e2) {
          return NaN;
        }
        getValueForPixel(t2) {
        }
        getPixelForTick(t2) {
          const e2 = this.ticks;
          return t2 < 0 || t2 > e2.length - 1 ? null : this.getPixelForValue(e2[t2].value);
        }
        getPixelForDecimal(t2) {
          const e2 = this;
          e2._reversePixels && (t2 = 1 - t2);
          const i2 = e2._startPixel + t2 * e2._length;
          return jt(e2._alignToPixels ? Xt(e2.chart, i2, 0) : i2);
        }
        getDecimalForPixel(t2) {
          const e2 = (t2 - this._startPixel) / this._length;
          return this._reversePixels ? 1 - e2 : e2;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min: t2, max: e2 } = this;
          return t2 < 0 && e2 < 0 ? e2 : t2 > 0 && e2 > 0 ? t2 : 0;
        }
        getContext(t2) {
          const e2 = this, i2 = e2.ticks || [];
          if (t2 >= 0 && t2 < i2.length) {
            const n3 = i2[t2];
            return n3.$context || (n3.$context = function(t3, e3, i3) {
              return Object.assign(Object.create(t3), { tick: i3, index: e3, type: "tick" });
            }(e2.getContext(), t2, n3));
          }
          return e2.$context || (e2.$context = (n2 = e2.chart.getContext(), o2 = e2, Object.assign(Object.create(n2), { scale: o2, type: "scale" })));
          var n2, o2;
        }
        _tickSize() {
          const t2 = this, e2 = t2.options.ticks, i2 = Et(t2.labelRotation), n2 = Math.abs(Math.cos(i2)), o2 = Math.abs(Math.sin(i2)), s2 = t2._getLabelSizes(), a2 = e2.autoSkipPadding || 0, r2 = s2 ? s2.widest.width + a2 : 0, l2 = s2 ? s2.highest.height + a2 : 0;
          return t2.isHorizontal() ? l2 * n2 > r2 * o2 ? r2 / n2 : l2 / o2 : l2 * o2 < r2 * n2 ? l2 / n2 : r2 / o2;
        }
        _isVisible() {
          const t2 = this.options.display;
          return t2 !== "auto" ? !!t2 : this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(t2) {
          const e2 = this, i2 = e2.axis, n2 = e2.chart, o2 = e2.options, { grid: s2, position: a2 } = o2, r2 = s2.offset, l2 = e2.isHorizontal(), c2 = e2.ticks.length + (r2 ? 1 : 0), h2 = $i(s2), d2 = [], u2 = s2.setContext(e2.getContext()), f2 = u2.drawBorder ? u2.borderWidth : 0, g2 = f2 / 2, p2 = function(t3) {
            return Xt(n2, t3, f2);
          };
          let m2, x2, b2, _2, y2, v2, w2, M2, k2, S2, P2, D2;
          if (a2 === "top")
            m2 = p2(e2.bottom), v2 = e2.bottom - h2, M2 = m2 - g2, S2 = p2(t2.top) + g2, D2 = t2.bottom;
          else if (a2 === "bottom")
            m2 = p2(e2.top), S2 = t2.top, D2 = p2(t2.bottom) - g2, v2 = m2 + g2, M2 = e2.top + h2;
          else if (a2 === "left")
            m2 = p2(e2.right), y2 = e2.right - h2, w2 = m2 - g2, k2 = p2(t2.left) + g2, P2 = t2.right;
          else if (a2 === "right")
            m2 = p2(e2.left), k2 = t2.left, P2 = p2(t2.right) - g2, y2 = m2 + g2, w2 = e2.left + h2;
          else if (i2 === "x") {
            if (a2 === "center")
              m2 = p2((t2.top + t2.bottom) / 2 + 0.5);
            else if (U(a2)) {
              const t3 = Object.keys(a2)[0], i3 = a2[t3];
              m2 = p2(e2.chart.scales[t3].getPixelForValue(i3));
            }
            S2 = t2.top, D2 = t2.bottom, v2 = m2 + g2, M2 = v2 + h2;
          } else if (i2 === "y") {
            if (a2 === "center")
              m2 = p2((t2.left + t2.right) / 2);
            else if (U(a2)) {
              const t3 = Object.keys(a2)[0], i3 = a2[t3];
              m2 = p2(e2.chart.scales[t3].getPixelForValue(i3));
            }
            y2 = m2 - g2, w2 = y2 - h2, k2 = t2.left, P2 = t2.right;
          }
          for (x2 = 0; x2 < c2; ++x2) {
            const t3 = s2.setContext(e2.getContext(x2)), i3 = t3.lineWidth, o3 = t3.color, a3 = s2.borderDash || [], c3 = t3.borderDashOffset, h3 = t3.tickWidth, u3 = t3.tickColor, f3 = t3.tickBorderDash || [], g3 = t3.tickBorderDashOffset;
            b2 = ji(e2, x2, r2), b2 !== void 0 && (_2 = Xt(n2, b2, i3), l2 ? y2 = w2 = k2 = P2 = _2 : v2 = M2 = S2 = D2 = _2, d2.push({ tx1: y2, ty1: v2, tx2: w2, ty2: M2, x1: k2, y1: S2, x2: P2, y2: D2, width: i3, color: o3, borderDash: a3, borderDashOffset: c3, tickWidth: h3, tickColor: u3, tickBorderDash: f3, tickBorderDashOffset: g3 }));
          }
          return e2._ticksLength = c2, e2._borderValue = m2, d2;
        }
        _computeLabelItems(t2) {
          const e2 = this, i2 = e2.axis, n2 = e2.options, { position: o2, ticks: s2 } = n2, a2 = e2.isHorizontal(), r2 = e2.ticks, { align: l2, crossAlign: c2, padding: h2, mirror: d2 } = s2, u2 = $i(n2.grid), f2 = u2 + h2, g2 = d2 ? -h2 : f2, p2 = -Et(e2.labelRotation), m2 = [];
          let x2, b2, _2, y2, v2, w2, M2, k2, S2, P2, D2, C2, O2 = "middle";
          if (o2 === "top")
            w2 = e2.bottom - g2, M2 = e2._getXAxisLabelAlignment();
          else if (o2 === "bottom")
            w2 = e2.top + g2, M2 = e2._getXAxisLabelAlignment();
          else if (o2 === "left") {
            const t3 = e2._getYAxisLabelAlignment(u2);
            M2 = t3.textAlign, v2 = t3.x;
          } else if (o2 === "right") {
            const t3 = e2._getYAxisLabelAlignment(u2);
            M2 = t3.textAlign, v2 = t3.x;
          } else if (i2 === "x") {
            if (o2 === "center")
              w2 = (t2.top + t2.bottom) / 2 + f2;
            else if (U(o2)) {
              const t3 = Object.keys(o2)[0], i3 = o2[t3];
              w2 = e2.chart.scales[t3].getPixelForValue(i3) + f2;
            }
            M2 = e2._getXAxisLabelAlignment();
          } else if (i2 === "y") {
            if (o2 === "center")
              v2 = (t2.left + t2.right) / 2 - f2;
            else if (U(o2)) {
              const t3 = Object.keys(o2)[0], i3 = o2[t3];
              v2 = e2.chart.scales[t3].getPixelForValue(i3);
            }
            M2 = e2._getYAxisLabelAlignment(u2).textAlign;
          }
          i2 === "y" && (l2 === "start" ? O2 = "top" : l2 === "end" && (O2 = "bottom"));
          const T2 = e2._getLabelSizes();
          for (x2 = 0, b2 = r2.length; x2 < b2; ++x2) {
            _2 = r2[x2], y2 = _2.label;
            const t3 = s2.setContext(e2.getContext(x2));
            k2 = e2.getPixelForTick(x2) + s2.labelOffset, S2 = e2._resolveTickFontOptions(x2), P2 = S2.lineHeight, D2 = Y(y2) ? y2.length : 1;
            const i3 = D2 / 2, n3 = t3.color, l3 = t3.textStrokeColor, h3 = t3.textStrokeWidth;
            let u3;
            if (a2 ? (v2 = k2, C2 = o2 === "top" ? c2 === "near" || p2 !== 0 ? -D2 * P2 + P2 / 2 : c2 === "center" ? -T2.highest.height / 2 - i3 * P2 + P2 : -T2.highest.height + P2 / 2 : c2 === "near" || p2 !== 0 ? P2 / 2 : c2 === "center" ? T2.highest.height / 2 - i3 * P2 : T2.highest.height - D2 * P2, d2 && (C2 *= -1)) : (w2 = k2, C2 = (1 - D2) * P2 / 2), t3.showLabelBackdrop) {
              const e3 = ze(t3.backdropPadding), i4 = T2.heights[x2], n4 = T2.widths[x2];
              let o3 = w2 + C2 - e3.top, s3 = v2 - e3.left;
              switch (O2) {
                case "middle":
                  o3 -= i4 / 2;
                  break;
                case "bottom":
                  o3 -= i4;
              }
              switch (M2) {
                case "center":
                  s3 -= n4 / 2;
                  break;
                case "right":
                  s3 -= n4;
              }
              u3 = { left: s3, top: o3, width: n4 + e3.width, height: i4 + e3.height, color: t3.backdropColor };
            }
            m2.push({ rotation: p2, label: y2, font: S2, color: n3, strokeColor: l3, strokeWidth: h3, textOffset: C2, textAlign: M2, textBaseline: O2, translation: [v2, w2], backdrop: u3 });
          }
          return m2;
        }
        _getXAxisLabelAlignment() {
          const { position: t2, ticks: e2 } = this.options;
          if (-Et(this.labelRotation))
            return t2 === "top" ? "left" : "right";
          let i2 = "center";
          return e2.align === "start" ? i2 = "left" : e2.align === "end" && (i2 = "right"), i2;
        }
        _getYAxisLabelAlignment(t2) {
          const e2 = this, { position: i2, ticks: { crossAlign: n2, mirror: o2, padding: s2 } } = e2.options, a2 = t2 + s2, r2 = e2._getLabelSizes().widest.width;
          let l2, c2;
          return i2 === "left" ? o2 ? (l2 = "left", c2 = e2.right + s2) : (c2 = e2.right - a2, n2 === "near" ? l2 = "right" : n2 === "center" ? (l2 = "center", c2 -= r2 / 2) : (l2 = "left", c2 = e2.left)) : i2 === "right" ? o2 ? (l2 = "right", c2 = e2.left + s2) : (c2 = e2.left + a2, n2 === "near" ? l2 = "left" : n2 === "center" ? (l2 = "center", c2 += r2 / 2) : (l2 = "right", c2 = e2.right)) : l2 = "right", { textAlign: l2, x: c2 };
        }
        _computeLabelArea() {
          const t2 = this;
          if (t2.options.ticks.mirror)
            return;
          const e2 = t2.chart, i2 = t2.options.position;
          return i2 === "left" || i2 === "right" ? { top: 0, left: t2.left, bottom: e2.height, right: t2.right } : i2 === "top" || i2 === "bottom" ? { top: t2.top, left: 0, bottom: t2.bottom, right: e2.width } : void 0;
        }
        drawBackground() {
          const { ctx: t2, options: { backgroundColor: e2 }, left: i2, top: n2, width: o2, height: s2 } = this;
          e2 && (t2.save(), t2.fillStyle = e2, t2.fillRect(i2, n2, o2, s2), t2.restore());
        }
        getLineWidthForValue(t2) {
          const e2 = this, i2 = e2.options.grid;
          if (!e2._isVisible() || !i2.display)
            return 0;
          const n2 = e2.ticks.findIndex((e3) => e3.value === t2);
          if (n2 >= 0) {
            return i2.setContext(e2.getContext(n2)).lineWidth;
          }
          return 0;
        }
        drawGrid(t2) {
          const e2 = this, i2 = e2.options.grid, n2 = e2.ctx, o2 = e2._gridLineItems || (e2._gridLineItems = e2._computeGridLineItems(t2));
          let s2, a2;
          const r2 = (t3, e3, i3) => {
            i3.width && i3.color && (n2.save(), n2.lineWidth = i3.width, n2.strokeStyle = i3.color, n2.setLineDash(i3.borderDash || []), n2.lineDashOffset = i3.borderDashOffset, n2.beginPath(), n2.moveTo(t3.x, t3.y), n2.lineTo(e3.x, e3.y), n2.stroke(), n2.restore());
          };
          if (i2.display)
            for (s2 = 0, a2 = o2.length; s2 < a2; ++s2) {
              const t3 = o2[s2];
              i2.drawOnChartArea && r2({ x: t3.x1, y: t3.y1 }, { x: t3.x2, y: t3.y2 }, t3), i2.drawTicks && r2({ x: t3.tx1, y: t3.ty1 }, { x: t3.tx2, y: t3.ty2 }, { color: t3.tickColor, width: t3.tickWidth, borderDash: t3.tickBorderDash, borderDashOffset: t3.tickBorderDashOffset });
            }
        }
        drawBorder() {
          const t2 = this, { chart: e2, ctx: i2, options: { grid: n2 } } = t2, o2 = n2.setContext(t2.getContext()), s2 = n2.drawBorder ? o2.borderWidth : 0;
          if (!s2)
            return;
          const a2 = n2.setContext(t2.getContext(0)).lineWidth, r2 = t2._borderValue;
          let l2, c2, h2, d2;
          t2.isHorizontal() ? (l2 = Xt(e2, t2.left, s2) - s2 / 2, c2 = Xt(e2, t2.right, a2) + a2 / 2, h2 = d2 = r2) : (h2 = Xt(e2, t2.top, s2) - s2 / 2, d2 = Xt(e2, t2.bottom, a2) + a2 / 2, l2 = c2 = r2), i2.save(), i2.lineWidth = o2.borderWidth, i2.strokeStyle = o2.borderColor, i2.beginPath(), i2.moveTo(l2, h2), i2.lineTo(c2, d2), i2.stroke(), i2.restore();
        }
        drawLabels(t2) {
          const e2 = this;
          if (!e2.options.ticks.display)
            return;
          const i2 = e2.ctx, n2 = e2._computeLabelArea();
          n2 && Zt(i2, n2);
          const o2 = e2._labelItems || (e2._labelItems = e2._computeLabelItems(t2));
          let s2, a2;
          for (s2 = 0, a2 = o2.length; s2 < a2; ++s2) {
            const t3 = o2[s2], e3 = t3.font, n3 = t3.label;
            t3.backdrop && (i2.fillStyle = t3.backdrop.color, i2.fillRect(t3.backdrop.left, t3.backdrop.top, t3.backdrop.width, t3.backdrop.height)), ee(i2, n3, 0, t3.textOffset, e3, t3);
          }
          n2 && Qt(i2);
        }
        drawTitle() {
          const { ctx: t2, options: { position: e2, title: i2, reverse: n2 } } = this;
          if (!i2.display)
            return;
          const s2 = Fe(i2.font), a2 = ze(i2.padding), r2 = i2.align;
          let l2 = s2.lineHeight / 2;
          e2 === "bottom" ? (l2 += a2.bottom, Y(i2.text) && (l2 += s2.lineHeight * (i2.text.length - 1))) : l2 += a2.top;
          const { titleX: c2, titleY: h2, maxWidth: d2, rotation: u2 } = function(t3, e3, i3, n3) {
            const { top: s3, left: a3, bottom: r3, right: l3 } = t3;
            let c3, h3, d3, u3 = 0;
            return t3.isHorizontal() ? (h3 = o(n3, a3, l3), d3 = Hi(t3, i3, e3), c3 = l3 - a3) : (h3 = Hi(t3, i3, e3), d3 = o(n3, r3, s3), u3 = i3 === "left" ? -Mt : Mt), { titleX: h3, titleY: d3, maxWidth: c3, rotation: u3 };
          }(this, l2, e2, r2);
          ee(t2, i2.text, 0, 0, s2, { color: i2.color, maxWidth: d2, rotation: u2, textAlign: Ui(r2, e2, n2), textBaseline: "middle", translation: [c2, h2] });
        }
        draw(t2) {
          const e2 = this;
          e2._isVisible() && (e2.drawBackground(), e2.drawGrid(t2), e2.drawBorder(), e2.drawTitle(), e2.drawLabels(t2));
        }
        _layers() {
          const t2 = this, e2 = t2.options, i2 = e2.ticks && e2.ticks.z || 0, n2 = e2.grid && e2.grid.z || 0;
          return t2._isVisible() && t2.draw === Xi.prototype.draw ? [{ z: n2, draw(e3) {
            t2.drawBackground(), t2.drawGrid(e3), t2.drawTitle();
          } }, { z: n2 + 1, draw() {
            t2.drawBorder();
          } }, { z: i2, draw(e3) {
            t2.drawLabels(e3);
          } }] : [{ z: i2, draw(e3) {
            t2.draw(e3);
          } }];
        }
        getMatchingVisibleMetas(t2) {
          const e2 = this, i2 = e2.chart.getSortedVisibleDatasetMetas(), n2 = e2.axis + "AxisID", o2 = [];
          let s2, a2;
          for (s2 = 0, a2 = i2.length; s2 < a2; ++s2) {
            const a3 = i2[s2];
            a3[n2] !== e2.id || t2 && a3.type !== t2 || o2.push(a3);
          }
          return o2;
        }
        _resolveTickFontOptions(t2) {
          return Fe(this.options.ticks.setContext(this.getContext(t2)).font);
        }
        _maxDigits() {
          const t2 = this, e2 = t2._resolveTickFontOptions(0).lineHeight;
          return (t2.isHorizontal() ? t2.width : t2.height) / e2;
        }
      }
      function qi(t2, e2 = [""], i2 = t2, n2, o2 = () => t2[0]) {
        ht(n2) || (n2 = an("_fallback", t2));
        const s2 = { [Symbol.toStringTag]: "Object", _cacheable: true, _scopes: t2, _rootScopes: i2, _fallback: n2, _getTarget: o2, override: (o3) => qi([o3, ...t2], e2, i2, n2) };
        return new Proxy(s2, { deleteProperty: (e3, i3) => (delete e3[i3], delete e3._keys, delete t2[0][i3], true), get: (i3, n3) => Ji(i3, n3, () => function(t3, e3, i4, n4) {
          let o3;
          for (const s3 of e3)
            if (o3 = an(Zi(s3, t3), i4), ht(o3))
              return Qi(t3, o3) ? on(i4, n4, t3, o3) : o3;
        }(n3, e2, t2, i3)), getOwnPropertyDescriptor: (t3, e3) => Reflect.getOwnPropertyDescriptor(t3._scopes[0], e3), getPrototypeOf: () => Reflect.getPrototypeOf(t2[0]), has: (t3, e3) => rn(t3).includes(e3), ownKeys: (t3) => rn(t3), set: (t3, e3, i3) => ((t3._storage || (t3._storage = o2()))[e3] = i3, delete t3[e3], delete t3._keys, true) });
      }
      function Ki(t2, e2, i2, n2) {
        const o2 = { _cacheable: false, _proxy: t2, _context: e2, _subProxy: i2, _stack: new Set(), _descriptors: Gi(t2, n2), setContext: (e3) => Ki(t2, e3, i2, n2), override: (o3) => Ki(t2.override(o3), e2, i2, n2) };
        return new Proxy(o2, { deleteProperty: (e3, i3) => (delete e3[i3], delete t2[i3], true), get: (t3, e3, i3) => Ji(t3, e3, () => function(t4, e4, i4) {
          const { _proxy: n3, _context: o3, _subProxy: s2, _descriptors: a2 } = t4;
          let r2 = n3[e4];
          dt(r2) && a2.isScriptable(e4) && (r2 = function(t5, e5, i5, n4) {
            const { _proxy: o4, _context: s3, _subProxy: a3, _stack: r3 } = i5;
            if (r3.has(t5))
              throw new Error("Recursion detected: " + [...r3].join("->") + "->" + t5);
            r3.add(t5), e5 = e5(s3, a3 || n4), r3.delete(t5), U(e5) && (e5 = on(o4._scopes, o4, t5, e5));
            return e5;
          }(e4, r2, t4, i4));
          Y(r2) && r2.length && (r2 = function(t5, e5, i5, n4) {
            const { _proxy: o4, _context: s3, _subProxy: a3, _descriptors: r3 } = i5;
            if (ht(s3.index) && n4(t5))
              e5 = e5[s3.index % e5.length];
            else if (U(e5[0])) {
              const i6 = e5, n5 = o4._scopes.filter((t6) => t6 !== i6);
              e5 = [];
              for (const l2 of i6) {
                const i7 = on(n5, o4, t5, l2);
                e5.push(Ki(i7, s3, a3 && a3[t5], r3));
              }
            }
            return e5;
          }(e4, r2, t4, a2.isIndexable));
          Qi(e4, r2) && (r2 = Ki(r2, o3, s2 && s2[e4], a2));
          return r2;
        }(t3, e3, i3)), getOwnPropertyDescriptor: (e3, i3) => e3._descriptors.allKeys ? Reflect.has(t2, i3) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(t2, i3), getPrototypeOf: () => Reflect.getPrototypeOf(t2), has: (e3, i3) => Reflect.has(t2, i3), ownKeys: () => Reflect.ownKeys(t2), set: (e3, i3, n3) => (t2[i3] = n3, delete e3[i3], true) });
      }
      function Gi(t2, e2 = { scriptable: true, indexable: true }) {
        const { _scriptable: i2 = e2.scriptable, _indexable: n2 = e2.indexable, _allKeys: o2 = e2.allKeys } = t2;
        return { allKeys: o2, scriptable: i2, indexable: n2, isScriptable: dt(i2) ? i2 : () => i2, isIndexable: dt(n2) ? n2 : () => n2 };
      }
      const Zi = (t2, e2) => t2 ? t2 + ct(e2) : e2, Qi = (t2, e2) => U(e2) && t2 !== "adapters";
      function Ji(t2, e2, i2) {
        let n2 = t2[e2];
        return ht(n2) || (n2 = i2(), ht(n2) && (t2[e2] = n2)), n2;
      }
      function tn(t2, e2, i2) {
        return dt(t2) ? t2(e2, i2) : t2;
      }
      const en = (t2, e2) => t2 === true ? e2 : typeof t2 == "string" ? lt(e2, t2) : void 0;
      function nn(t2, e2, i2, n2) {
        for (const o2 of e2) {
          const e3 = en(i2, o2);
          if (e3) {
            t2.add(e3);
            const o3 = tn(e3._fallback, i2, e3);
            if (ht(o3) && o3 !== i2 && o3 !== n2)
              return o3;
          } else if (e3 === false && ht(n2) && i2 !== n2)
            return null;
        }
        return false;
      }
      function on(t2, e2, i2, n2) {
        const o2 = e2._rootScopes, s2 = tn(e2._fallback, i2, n2), a2 = [...t2, ...o2], r2 = new Set();
        r2.add(n2);
        let l2 = sn(r2, a2, i2, s2 || i2);
        return l2 !== null && ((!ht(s2) || s2 === i2 || (l2 = sn(r2, a2, s2, l2), l2 !== null)) && qi([...r2], [""], o2, s2, () => function(t3, e3, i3) {
          const n3 = t3._getTarget();
          e3 in n3 || (n3[e3] = {});
          const o3 = n3[e3];
          if (Y(o3) && U(i3))
            return i3;
          return o3;
        }(e2, i2, n2)));
      }
      function sn(t2, e2, i2, n2) {
        for (; i2; )
          i2 = nn(t2, e2, i2, n2);
        return i2;
      }
      function an(t2, e2) {
        for (const i2 of e2) {
          if (!i2)
            continue;
          const e3 = i2[t2];
          if (ht(e3))
            return e3;
        }
      }
      function rn(t2) {
        let e2 = t2._keys;
        return e2 || (e2 = t2._keys = function(t3) {
          const e3 = new Set();
          for (const i2 of t3)
            for (const t4 of Object.keys(i2).filter((t5) => !t5.startsWith("_")))
              e3.add(t4);
          return [...e3];
        }(t2._scopes)), e2;
      }
      const ln = Number.EPSILON || 1e-14, cn = (t2, e2) => e2 < t2.length && !t2[e2].skip && t2[e2], hn = (t2) => t2 === "x" ? "y" : "x";
      function dn(t2, e2, i2, n2) {
        const o2 = t2.skip ? e2 : t2, s2 = e2, a2 = i2.skip ? e2 : i2, r2 = Vt(s2, o2), l2 = Vt(a2, s2);
        let c2 = r2 / (r2 + l2), h2 = l2 / (r2 + l2);
        c2 = isNaN(c2) ? 0 : c2, h2 = isNaN(h2) ? 0 : h2;
        const d2 = n2 * c2, u2 = n2 * h2;
        return { previous: { x: s2.x - d2 * (a2.x - o2.x), y: s2.y - d2 * (a2.y - o2.y) }, next: { x: s2.x + u2 * (a2.x - o2.x), y: s2.y + u2 * (a2.y - o2.y) } };
      }
      function un(t2, e2 = "x") {
        const i2 = hn(e2), n2 = t2.length, o2 = Array(n2).fill(0), s2 = Array(n2);
        let a2, r2, l2, c2 = cn(t2, 0);
        for (a2 = 0; a2 < n2; ++a2)
          if (r2 = l2, l2 = c2, c2 = cn(t2, a2 + 1), l2) {
            if (c2) {
              const t3 = c2[e2] - l2[e2];
              o2[a2] = t3 !== 0 ? (c2[i2] - l2[i2]) / t3 : 0;
            }
            s2[a2] = r2 ? c2 ? Dt(o2[a2 - 1]) !== Dt(o2[a2]) ? 0 : (o2[a2 - 1] + o2[a2]) / 2 : o2[a2 - 1] : o2[a2];
          }
        !function(t3, e3, i3) {
          const n3 = t3.length;
          let o3, s3, a3, r3, l3, c3 = cn(t3, 0);
          for (let h2 = 0; h2 < n3 - 1; ++h2)
            l3 = c3, c3 = cn(t3, h2 + 1), l3 && c3 && (At(e3[h2], 0, ln) ? i3[h2] = i3[h2 + 1] = 0 : (o3 = i3[h2] / e3[h2], s3 = i3[h2 + 1] / e3[h2], r3 = Math.pow(o3, 2) + Math.pow(s3, 2), r3 <= 9 || (a3 = 3 / Math.sqrt(r3), i3[h2] = o3 * a3 * e3[h2], i3[h2 + 1] = s3 * a3 * e3[h2])));
        }(t2, o2, s2), function(t3, e3, i3 = "x") {
          const n3 = hn(i3), o3 = t3.length;
          let s3, a3, r3, l3 = cn(t3, 0);
          for (let c3 = 0; c3 < o3; ++c3) {
            if (a3 = r3, r3 = l3, l3 = cn(t3, c3 + 1), !r3)
              continue;
            const o4 = r3[i3], h2 = r3[n3];
            a3 && (s3 = (o4 - a3[i3]) / 3, r3[`cp1${i3}`] = o4 - s3, r3[`cp1${n3}`] = h2 - s3 * e3[c3]), l3 && (s3 = (l3[i3] - o4) / 3, r3[`cp2${i3}`] = o4 + s3, r3[`cp2${n3}`] = h2 + s3 * e3[c3]);
          }
        }(t2, s2, e2);
      }
      function fn(t2, e2, i2) {
        return Math.max(Math.min(t2, i2), e2);
      }
      function gn(t2, e2, i2, n2, o2) {
        let s2, a2, r2, l2;
        if (e2.spanGaps && (t2 = t2.filter((t3) => !t3.skip)), e2.cubicInterpolationMode === "monotone")
          un(t2, o2);
        else {
          let i3 = n2 ? t2[t2.length - 1] : t2[0];
          for (s2 = 0, a2 = t2.length; s2 < a2; ++s2)
            r2 = t2[s2], l2 = dn(i3, r2, t2[Math.min(s2 + 1, a2 - (n2 ? 0 : 1)) % a2], e2.tension), r2.cp1x = l2.previous.x, r2.cp1y = l2.previous.y, r2.cp2x = l2.next.x, r2.cp2y = l2.next.y, i3 = r2;
        }
        e2.capBezierPoints && function(t3, e3) {
          let i3, n3, o3, s3, a3, r3 = Gt(t3[0], e3);
          for (i3 = 0, n3 = t3.length; i3 < n3; ++i3)
            a3 = s3, s3 = r3, r3 = i3 < n3 - 1 && Gt(t3[i3 + 1], e3), s3 && (o3 = t3[i3], a3 && (o3.cp1x = fn(o3.cp1x, e3.left, e3.right), o3.cp1y = fn(o3.cp1y, e3.top, e3.bottom)), r3 && (o3.cp2x = fn(o3.cp2x, e3.left, e3.right), o3.cp2y = fn(o3.cp2y, e3.top, e3.bottom)));
        }(t2, i2);
      }
      function pn(t2, e2, i2, n2) {
        return { x: t2.x + i2 * (e2.x - t2.x), y: t2.y + i2 * (e2.y - t2.y) };
      }
      function mn(t2, e2, i2, n2) {
        return { x: t2.x + i2 * (e2.x - t2.x), y: n2 === "middle" ? i2 < 0.5 ? t2.y : e2.y : n2 === "after" ? i2 < 1 ? t2.y : e2.y : i2 > 0 ? e2.y : t2.y };
      }
      function xn(t2, e2, i2, n2) {
        const o2 = { x: t2.cp2x, y: t2.cp2y }, s2 = { x: e2.cp1x, y: e2.cp1y }, a2 = pn(t2, o2, i2), r2 = pn(o2, s2, i2), l2 = pn(s2, e2, i2), c2 = pn(a2, r2, i2), h2 = pn(r2, l2, i2);
        return pn(c2, h2, i2);
      }
      function bn(t2, e2, i2) {
        return t2 ? function(t3, e3) {
          return { x: (i3) => t3 + t3 + e3 - i3, setWidth(t4) {
            e3 = t4;
          }, textAlign: (t4) => t4 === "center" ? t4 : t4 === "right" ? "left" : "right", xPlus: (t4, e4) => t4 - e4, leftForLtr: (t4, e4) => t4 - e4 };
        }(e2, i2) : { x: (t3) => t3, setWidth(t3) {
        }, textAlign: (t3) => t3, xPlus: (t3, e3) => t3 + e3, leftForLtr: (t3, e3) => t3 };
      }
      function _n(t2, e2) {
        let i2, n2;
        e2 !== "ltr" && e2 !== "rtl" || (i2 = t2.canvas.style, n2 = [i2.getPropertyValue("direction"), i2.getPropertyPriority("direction")], i2.setProperty("direction", e2, "important"), t2.prevTextDirection = n2);
      }
      function yn(t2, e2) {
        e2 !== void 0 && (delete t2.prevTextDirection, t2.canvas.style.setProperty("direction", e2[0], e2[1]));
      }
      function vn(t2) {
        return t2 === "angle" ? { between: Ht, compare: Bt, normalize: Wt } : { between: (t3, e2, i2) => t3 >= Math.min(e2, i2) && t3 <= Math.max(i2, e2), compare: (t3, e2) => t3 - e2, normalize: (t3) => t3 };
      }
      function wn({ start: t2, end: e2, count: i2, loop: n2, style: o2 }) {
        return { start: t2 % i2, end: e2 % i2, loop: n2 && (e2 - t2 + 1) % i2 == 0, style: o2 };
      }
      function Mn(t2, e2, i2) {
        if (!i2)
          return [t2];
        const { property: n2, start: o2, end: s2 } = i2, a2 = e2.length, { compare: r2, between: l2, normalize: c2 } = vn(n2), { start: h2, end: d2, loop: u2, style: f2 } = function(t3, e3, i3) {
          const { property: n3, start: o3, end: s3 } = i3, { between: a3, normalize: r3 } = vn(n3), l3 = e3.length;
          let c3, h3, { start: d3, end: u3, loop: f3 } = t3;
          if (f3) {
            for (d3 += l3, u3 += l3, c3 = 0, h3 = l3; c3 < h3 && a3(r3(e3[d3 % l3][n3]), o3, s3); ++c3)
              d3--, u3--;
            d3 %= l3, u3 %= l3;
          }
          return u3 < d3 && (u3 += l3), { start: d3, end: u3, loop: f3, style: t3.style };
        }(t2, e2, i2), g2 = [];
        let p2, m2, x2, b2 = false, _2 = null;
        const y2 = () => b2 || l2(o2, x2, p2) && r2(o2, x2) !== 0, v2 = () => !b2 || r2(s2, p2) === 0 || l2(s2, x2, p2);
        for (let t3 = h2, i3 = h2; t3 <= d2; ++t3)
          m2 = e2[t3 % a2], m2.skip || (p2 = c2(m2[n2]), p2 !== x2 && (b2 = l2(p2, o2, s2), _2 === null && y2() && (_2 = r2(p2, o2) === 0 ? t3 : i3), _2 !== null && v2() && (g2.push(wn({ start: _2, end: t3, loop: u2, count: a2, style: f2 })), _2 = null), i3 = t3, x2 = p2));
        return _2 !== null && g2.push(wn({ start: _2, end: d2, loop: u2, count: a2, style: f2 })), g2;
      }
      function kn(t2, e2) {
        const i2 = [], n2 = t2.segments;
        for (let o2 = 0; o2 < n2.length; o2++) {
          const s2 = Mn(n2[o2], t2.points, e2);
          s2.length && i2.push(...s2);
        }
        return i2;
      }
      function Sn(t2, e2) {
        const i2 = t2.points, n2 = t2.options.spanGaps, o2 = i2.length;
        if (!o2)
          return [];
        const s2 = !!t2._loop, { start: a2, end: r2 } = function(t3, e3, i3, n3) {
          let o3 = 0, s3 = e3 - 1;
          if (i3 && !n3)
            for (; o3 < e3 && !t3[o3].skip; )
              o3++;
          for (; o3 < e3 && t3[o3].skip; )
            o3++;
          for (o3 %= e3, i3 && (s3 += o3); s3 > o3 && t3[s3 % e3].skip; )
            s3--;
          return s3 %= e3, { start: o3, end: s3 };
        }(i2, o2, s2, n2);
        if (n2 === true)
          return Pn([{ start: a2, end: r2, loop: s2 }], i2, e2);
        return Pn(function(t3, e3, i3, n3) {
          const o3 = t3.length, s3 = [];
          let a3, r3 = e3, l2 = t3[e3];
          for (a3 = e3 + 1; a3 <= i3; ++a3) {
            const i4 = t3[a3 % o3];
            i4.skip || i4.stop ? l2.skip || (n3 = false, s3.push({ start: e3 % o3, end: (a3 - 1) % o3, loop: n3 }), e3 = r3 = i4.stop ? a3 : null) : (r3 = a3, l2.skip && (e3 = a3)), l2 = i4;
          }
          return r3 !== null && s3.push({ start: e3 % o3, end: r3 % o3, loop: n3 }), s3;
        }(i2, a2, r2 < a2 ? r2 + o2 : r2, !!t2._fullLoop && a2 === 0 && r2 === o2 - 1), i2, e2);
      }
      function Pn(t2, e2, i2) {
        return i2 && i2.setContext && e2 ? function(t3, e3, i3) {
          const n2 = e3.length, o2 = [];
          let s2 = t3[0].start, a2 = s2;
          for (const r2 of t3) {
            let t4, l2, c2 = e3[s2 % n2];
            for (a2 = s2 + 1; a2 <= r2.end; a2++) {
              const h2 = e3[a2 % n2];
              l2 = Dn(i3.setContext({ type: "segment", p0: c2, p1: h2 })), Cn(l2, t4) && (o2.push({ start: s2, end: a2 - 1, loop: r2.loop, style: t4 }), t4 = l2, s2 = a2 - 1), c2 = h2, t4 = l2;
            }
            s2 < a2 - 1 && (o2.push({ start: s2, end: a2 - 1, loop: r2.loop, style: l2 }), s2 = a2 - 1);
          }
          return o2;
        }(t2, e2, i2) : t2;
      }
      function Dn(t2) {
        return { backgroundColor: t2.backgroundColor, borderCapStyle: t2.borderCapStyle, borderDash: t2.borderDash, borderDashOffset: t2.borderDashOffset, borderJoinStyle: t2.borderJoinStyle, borderWidth: t2.borderWidth, borderColor: t2.borderColor };
      }
      function Cn(t2, e2) {
        return e2 && JSON.stringify(t2) !== JSON.stringify(e2);
      }
      var On = Object.freeze({ __proto__: null, easingEffects: mi, color: W, getHoverColor: H, noop: N, uid: j, isNullOrUndef: $, isArray: Y, isObject: U, isFinite: X, finiteOrDefault: q, valueOrDefault: K, toPercentage: G, toDimension: Z, callback: Q, each: J, _elementsEqual: tt, clone: et, _merger: nt, merge: ot, mergeIf: st, _mergerIf: at, _deprecated: function(t2, e2, i2, n2) {
        e2 !== void 0 && console.warn(t2 + ': "' + i2 + '" is deprecated. Please use "' + n2 + '" instead');
      }, resolveObjectKey: lt, _capitalize: ct, defined: ht, isFunction: dt, setsEqual: ut, toFontString: $t, _measureText: Yt, _longestText: Ut, _alignPixel: Xt, clearCanvas: qt, drawPoint: Kt, _isPointInArea: Gt, clipArea: Zt, unclipArea: Qt, _steppedLineTo: Jt, _bezierCurveTo: te, renderText: ee, addRoundedRectPath: ie, _lookup: ne, _lookupByKey: oe, _rlookupByKey: se, _filterBetween: ae, listenArrayEvents: le, unlistenArrayEvents: ce, _arrayUnique: he, _createResolver: qi, _attachContext: Ki, _descriptors: Gi, splineCurve: dn, splineCurveMonotone: un, _updateBezierControlPoints: gn, _getParentNode: de, getStyle: ge, getRelativePosition: xe, getMaximumSize: _e, retinaScale: ye, supportsEventListenerOptions: ve, readUsedSize: we, fontString: function(t2, e2, i2) {
        return e2 + " " + t2 + "px " + i2;
      }, requestAnimFrame: t, throttled: e, debounce: i, _toLeftRightCenter: n, _alignStartEnd: o, _textX: s, _pointInLine: pn, _steppedInterpolation: mn, _bezierInterpolation: xn, formatNumber: zi, toLineHeight: Le, _readValueToProps: Re, toTRBL: Ee, toTRBLCorners: Ie, toPadding: ze, toFont: Fe, resolve: Ve, _addGrace: Be, PI: bt, TAU: _t, PITAU: yt, INFINITY: vt, RAD_PER_DEG: wt, HALF_PI: Mt, QUARTER_PI: kt, TWO_THIRDS_PI: St, log10: Pt, sign: Dt, niceNum: Ct, _factorize: Ot, isNumber: Tt, almostEquals: At, almostWhole: Lt, _setMinAndMaxByKey: Rt, toRadians: Et, toDegrees: It, _decimalPlaces: zt, getAngleFromPoint: Ft, distanceBetweenPoints: Vt, _angleDiff: Bt, _normalizeAngle: Wt, _angleBetween: Ht, _limitValue: Nt, _int16Range: jt, getRtlAdapter: bn, overrideTextDirection: _n, restoreTextDirection: yn, _boundSegment: Mn, _boundSegments: kn, _computeSegments: Sn });
      class Tn {
        constructor(t2, e2, i2) {
          this.type = t2, this.scope = e2, this.override = i2, this.items = Object.create(null);
        }
        isForType(t2) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, t2.prototype);
        }
        register(t2) {
          const e2 = this, i2 = Object.getPrototypeOf(t2);
          let n2;
          (function(t3) {
            return "id" in t3 && "defaults" in t3;
          })(i2) && (n2 = e2.register(i2));
          const o2 = e2.items, s2 = t2.id, a2 = e2.scope + "." + s2;
          if (!s2)
            throw new Error("class does not have id: " + t2);
          return s2 in o2 || (o2[s2] = t2, function(t3, e3, i3) {
            const n3 = ot(Object.create(null), [i3 ? xt.get(i3) : {}, xt.get(e3), t3.defaults]);
            xt.set(e3, n3), t3.defaultRoutes && function(t4, e4) {
              Object.keys(e4).forEach((i4) => {
                const n4 = i4.split("."), o3 = n4.pop(), s3 = [t4].concat(n4).join("."), a3 = e4[i4].split("."), r2 = a3.pop(), l2 = a3.join(".");
                xt.route(s3, o3, l2, r2);
              });
            }(e3, t3.defaultRoutes);
            t3.descriptors && xt.describe(e3, t3.descriptors);
          }(t2, a2, n2), e2.override && xt.override(t2.id, t2.overrides)), a2;
        }
        get(t2) {
          return this.items[t2];
        }
        unregister(t2) {
          const e2 = this.items, i2 = t2.id, n2 = this.scope;
          i2 in e2 && delete e2[i2], n2 && i2 in xt[n2] && (delete xt[n2][i2], this.override && delete ft[i2]);
        }
      }
      var An = new class {
        constructor() {
          this.controllers = new Tn(Ri, "datasets", true), this.elements = new Tn(Ei, "elements"), this.plugins = new Tn(Object, "plugins"), this.scales = new Tn(Xi, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
        }
        add(...t2) {
          this._each("register", t2);
        }
        remove(...t2) {
          this._each("unregister", t2);
        }
        addControllers(...t2) {
          this._each("register", t2, this.controllers);
        }
        addElements(...t2) {
          this._each("register", t2, this.elements);
        }
        addPlugins(...t2) {
          this._each("register", t2, this.plugins);
        }
        addScales(...t2) {
          this._each("register", t2, this.scales);
        }
        getController(t2) {
          return this._get(t2, this.controllers, "controller");
        }
        getElement(t2) {
          return this._get(t2, this.elements, "element");
        }
        getPlugin(t2) {
          return this._get(t2, this.plugins, "plugin");
        }
        getScale(t2) {
          return this._get(t2, this.scales, "scale");
        }
        removeControllers(...t2) {
          this._each("unregister", t2, this.controllers);
        }
        removeElements(...t2) {
          this._each("unregister", t2, this.elements);
        }
        removePlugins(...t2) {
          this._each("unregister", t2, this.plugins);
        }
        removeScales(...t2) {
          this._each("unregister", t2, this.scales);
        }
        _each(t2, e2, i2) {
          const n2 = this;
          [...e2].forEach((e3) => {
            const o2 = i2 || n2._getRegistryForType(e3);
            i2 || o2.isForType(e3) || o2 === n2.plugins && e3.id ? n2._exec(t2, o2, e3) : J(e3, (e4) => {
              const o3 = i2 || n2._getRegistryForType(e4);
              n2._exec(t2, o3, e4);
            });
          });
        }
        _exec(t2, e2, i2) {
          const n2 = ct(t2);
          Q(i2["before" + n2], [], i2), e2[t2](i2), Q(i2["after" + n2], [], i2);
        }
        _getRegistryForType(t2) {
          for (let e2 = 0; e2 < this._typedRegistries.length; e2++) {
            const i2 = this._typedRegistries[e2];
            if (i2.isForType(t2))
              return i2;
          }
          return this.plugins;
        }
        _get(t2, e2, i2) {
          const n2 = e2.get(t2);
          if (n2 === void 0)
            throw new Error('"' + t2 + '" is not a registered ' + i2 + ".");
          return n2;
        }
      }();
      class Ln {
        constructor() {
          this._init = [];
        }
        notify(t2, e2, i2, n2) {
          const o2 = this;
          e2 === "beforeInit" && (o2._init = o2._createDescriptors(t2, true), o2._notify(o2._init, t2, "install"));
          const s2 = n2 ? o2._descriptors(t2).filter(n2) : o2._descriptors(t2), a2 = o2._notify(s2, t2, e2, i2);
          return e2 === "destroy" && (o2._notify(s2, t2, "stop"), o2._notify(o2._init, t2, "uninstall")), a2;
        }
        _notify(t2, e2, i2, n2) {
          n2 = n2 || {};
          for (const o2 of t2) {
            const t3 = o2.plugin;
            if (Q(t3[i2], [e2, n2, o2.options], t3) === false && n2.cancelable)
              return false;
          }
          return true;
        }
        invalidate() {
          $(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
        }
        _descriptors(t2) {
          if (this._cache)
            return this._cache;
          const e2 = this._cache = this._createDescriptors(t2);
          return this._notifyStateChanges(t2), e2;
        }
        _createDescriptors(t2, e2) {
          const i2 = t2 && t2.config, n2 = K(i2.options && i2.options.plugins, {}), o2 = function(t3) {
            const e3 = [], i3 = Object.keys(An.plugins.items);
            for (let t4 = 0; t4 < i3.length; t4++)
              e3.push(An.getPlugin(i3[t4]));
            const n3 = t3.plugins || [];
            for (let t4 = 0; t4 < n3.length; t4++) {
              const i4 = n3[t4];
              e3.indexOf(i4) === -1 && e3.push(i4);
            }
            return e3;
          }(i2);
          return n2 !== false || e2 ? function(t3, e3, i3, n3) {
            const o3 = [], s2 = t3.getContext();
            for (let a2 = 0; a2 < e3.length; a2++) {
              const r2 = e3[a2], l2 = Rn(i3[r2.id], n3);
              l2 !== null && o3.push({ plugin: r2, options: En(t3.config, r2, l2, s2) });
            }
            return o3;
          }(t2, o2, n2, e2) : [];
        }
        _notifyStateChanges(t2) {
          const e2 = this._oldCache || [], i2 = this._cache, n2 = (t3, e3) => t3.filter((t4) => !e3.some((e4) => t4.plugin.id === e4.plugin.id));
          this._notify(n2(e2, i2), t2, "stop"), this._notify(n2(i2, e2), t2, "start");
        }
      }
      function Rn(t2, e2) {
        return e2 || t2 !== false ? t2 === true ? {} : t2 : null;
      }
      function En(t2, e2, i2, n2) {
        const o2 = t2.pluginScopeKeys(e2), s2 = t2.getOptionScopes(i2, o2);
        return t2.createResolver(s2, n2, [""], { scriptable: false, indexable: false, allKeys: true });
      }
      function In(t2, e2) {
        const i2 = xt.datasets[t2] || {};
        return ((e2.datasets || {})[t2] || {}).indexAxis || e2.indexAxis || i2.indexAxis || "x";
      }
      function zn(t2, e2) {
        return t2 === "x" || t2 === "y" ? t2 : e2.axis || ((i2 = e2.position) === "top" || i2 === "bottom" ? "x" : i2 === "left" || i2 === "right" ? "y" : void 0) || t2.charAt(0).toLowerCase();
        var i2;
      }
      function Fn(t2) {
        const e2 = t2.options || (t2.options = {});
        e2.plugins = K(e2.plugins, {}), e2.scales = function(t3, e3) {
          const i2 = ft[t3.type] || { scales: {} }, n2 = e3.scales || {}, o2 = In(t3.type, e3), s2 = Object.create(null), a2 = Object.create(null);
          return Object.keys(n2).forEach((t4) => {
            const e4 = n2[t4], r2 = zn(t4, e4), l2 = function(t5, e5) {
              return t5 === e5 ? "_index_" : "_value_";
            }(r2, o2), c2 = i2.scales || {};
            s2[r2] = s2[r2] || t4, a2[t4] = st(Object.create(null), [{ axis: r2 }, e4, c2[r2], c2[l2]]);
          }), t3.data.datasets.forEach((i3) => {
            const o3 = i3.type || t3.type, r2 = i3.indexAxis || In(o3, e3), l2 = (ft[o3] || {}).scales || {};
            Object.keys(l2).forEach((t4) => {
              const e4 = function(t5, e5) {
                let i4 = t5;
                return t5 === "_index_" ? i4 = e5 : t5 === "_value_" && (i4 = e5 === "x" ? "y" : "x"), i4;
              }(t4, r2), o4 = i3[e4 + "AxisID"] || s2[e4] || e4;
              a2[o4] = a2[o4] || Object.create(null), st(a2[o4], [{ axis: e4 }, n2[o4], l2[t4]]);
            });
          }), Object.keys(a2).forEach((t4) => {
            const e4 = a2[t4];
            st(e4, [xt.scales[e4.type], xt.scale]);
          }), a2;
        }(t2, e2);
      }
      function Vn(t2) {
        return (t2 = t2 || {}).datasets = t2.datasets || [], t2.labels = t2.labels || [], t2;
      }
      const Bn = new Map(), Wn = new Set();
      function Hn(t2, e2) {
        let i2 = Bn.get(t2);
        return i2 || (i2 = e2(), Bn.set(t2, i2), Wn.add(i2)), i2;
      }
      const Nn = (t2, e2, i2) => {
        const n2 = lt(e2, i2);
        n2 !== void 0 && t2.add(n2);
      };
      class jn {
        constructor(t2) {
          this._config = function(t3) {
            return (t3 = t3 || {}).data = Vn(t3.data), Fn(t3), t3;
          }(t2), this._scopeCache = new Map(), this._resolverCache = new Map();
        }
        get type() {
          return this._config.type;
        }
        set type(t2) {
          this._config.type = t2;
        }
        get data() {
          return this._config.data;
        }
        set data(t2) {
          this._config.data = Vn(t2);
        }
        get options() {
          return this._config.options;
        }
        set options(t2) {
          this._config.options = t2;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const t2 = this._config;
          this.clearCache(), Fn(t2);
        }
        clearCache() {
          this._scopeCache.clear(), this._resolverCache.clear();
        }
        datasetScopeKeys(t2) {
          return Hn(t2, () => [[`datasets.${t2}`, ""]]);
        }
        datasetAnimationScopeKeys(t2, e2) {
          return Hn(`${t2}.transition.${e2}`, () => [[`datasets.${t2}.transitions.${e2}`, `transitions.${e2}`], [`datasets.${t2}`, ""]]);
        }
        datasetElementScopeKeys(t2, e2) {
          return Hn(`${t2}-${e2}`, () => [[`datasets.${t2}.elements.${e2}`, `datasets.${t2}`, `elements.${e2}`, ""]]);
        }
        pluginScopeKeys(t2) {
          const e2 = t2.id;
          return Hn(`${this.type}-plugin-${e2}`, () => [[`plugins.${e2}`, ...t2.additionalOptionScopes || []]]);
        }
        _cachedScopes(t2, e2) {
          const i2 = this._scopeCache;
          let n2 = i2.get(t2);
          return n2 && !e2 || (n2 = new Map(), i2.set(t2, n2)), n2;
        }
        getOptionScopes(t2, e2, i2) {
          const { options: n2, type: o2 } = this, s2 = this._cachedScopes(t2, i2), a2 = s2.get(e2);
          if (a2)
            return a2;
          const r2 = new Set();
          e2.forEach((e3) => {
            t2 && (r2.add(t2), e3.forEach((e4) => Nn(r2, t2, e4))), e3.forEach((t3) => Nn(r2, n2, t3)), e3.forEach((t3) => Nn(r2, ft[o2] || {}, t3)), e3.forEach((t3) => Nn(r2, xt, t3)), e3.forEach((t3) => Nn(r2, gt, t3));
          });
          const l2 = [...r2];
          return Wn.has(e2) && s2.set(e2, l2), l2;
        }
        chartOptionScopes() {
          const { options: t2, type: e2 } = this;
          return [t2, ft[e2] || {}, xt.datasets[e2] || {}, { type: e2 }, xt, gt];
        }
        resolveNamedOptions(t2, e2, i2, n2 = [""]) {
          const o2 = { $shared: true }, { resolver: s2, subPrefixes: a2 } = $n(this._resolverCache, t2, n2);
          let r2 = s2;
          if (function(t3, e3) {
            const { isScriptable: i3, isIndexable: n3 } = Gi(t3);
            for (const o3 of e3)
              if (i3(o3) && dt(t3[o3]) || n3(o3) && Y(t3[o3]))
                return true;
            return false;
          }(s2, e2)) {
            o2.$shared = false;
            r2 = Ki(s2, i2 = dt(i2) ? i2() : i2, this.createResolver(t2, i2, a2));
          }
          for (const t3 of e2)
            o2[t3] = r2[t3];
          return o2;
        }
        createResolver(t2, e2, i2 = [""], n2) {
          const { resolver: o2 } = $n(this._resolverCache, t2, i2);
          return U(e2) ? Ki(o2, e2, void 0, n2) : o2;
        }
      }
      function $n(t2, e2, i2) {
        let n2 = t2.get(e2);
        n2 || (n2 = new Map(), t2.set(e2, n2));
        const o2 = i2.join();
        let s2 = n2.get(o2);
        if (!s2) {
          s2 = { resolver: qi(e2, i2), subPrefixes: i2.filter((t3) => !t3.toLowerCase().includes("hover")) }, n2.set(o2, s2);
        }
        return s2;
      }
      const Yn = ["top", "bottom", "left", "right", "chartArea"];
      function Un(t2, e2) {
        return t2 === "top" || t2 === "bottom" || Yn.indexOf(t2) === -1 && e2 === "x";
      }
      function Xn(t2, e2) {
        return function(i2, n2) {
          return i2[t2] === n2[t2] ? i2[e2] - n2[e2] : i2[t2] - n2[t2];
        };
      }
      function qn(t2) {
        const e2 = t2.chart, i2 = e2.options.animation;
        e2.notifyPlugins("afterRender"), Q(i2 && i2.onComplete, [t2], e2);
      }
      function Kn(t2) {
        const e2 = t2.chart, i2 = e2.options.animation;
        Q(i2 && i2.onProgress, [t2], e2);
      }
      function Gn() {
        return typeof window != "undefined" && typeof document != "undefined";
      }
      function Zn(t2) {
        return Gn() && typeof t2 == "string" ? t2 = document.getElementById(t2) : t2 && t2.length && (t2 = t2[0]), t2 && t2.canvas && (t2 = t2.canvas), t2;
      }
      const Qn = {}, Jn = (t2) => {
        const e2 = Zn(t2);
        return Object.values(Qn).filter((t3) => t3.canvas === e2).pop();
      };
      class to {
        constructor(t2, e2) {
          const n2 = this;
          this.config = e2 = new jn(e2);
          const o2 = Zn(t2), s2 = Jn(o2);
          if (s2)
            throw new Error("Canvas is already in use. Chart with ID '" + s2.id + "' must be destroyed before the canvas can be reused.");
          const r2 = e2.createResolver(e2.chartOptionScopes(), n2.getContext());
          this.platform = n2._initializePlatform(o2, e2);
          const l2 = n2.platform.acquireContext(o2, r2.aspectRatio), c2 = l2 && l2.canvas, h2 = c2 && c2.height, d2 = c2 && c2.width;
          this.id = j(), this.ctx = l2, this.canvas = c2, this.width = d2, this.height = h2, this._options = r2, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this.scale = void 0, this._plugins = new Ln(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = i(() => this.update("resize"), r2.resizeDelay || 0), Qn[n2.id] = n2, l2 && c2 ? (a.listen(n2, "complete", qn), a.listen(n2, "progress", Kn), n2._initialize(), n2.attached && n2.update()) : console.error("Failed to create chart: can't acquire context from the given item");
        }
        get aspectRatio() {
          const { options: { aspectRatio: t2, maintainAspectRatio: e2 }, width: i2, height: n2, _aspectRatio: o2 } = this;
          return $(t2) ? e2 && o2 ? o2 : n2 ? i2 / n2 : null : t2;
        }
        get data() {
          return this.config.data;
        }
        set data(t2) {
          this.config.data = t2;
        }
        get options() {
          return this._options;
        }
        set options(t2) {
          this.config.options = t2;
        }
        _initialize() {
          const t2 = this;
          return t2.notifyPlugins("beforeInit"), t2.options.responsive ? t2.resize() : ye(t2, t2.options.devicePixelRatio), t2.bindEvents(), t2.notifyPlugins("afterInit"), t2;
        }
        _initializePlatform(t2, e2) {
          return e2.platform ? new e2.platform() : !Gn() || typeof OffscreenCanvas != "undefined" && t2 instanceof OffscreenCanvas ? new Qe() : new di();
        }
        clear() {
          return qt(this.canvas, this.ctx), this;
        }
        stop() {
          return a.stop(this), this;
        }
        resize(t2, e2) {
          a.running(this) ? this._resizeBeforeDraw = { width: t2, height: e2 } : this._resize(t2, e2);
        }
        _resize(t2, e2) {
          const i2 = this, n2 = i2.options, o2 = i2.canvas, s2 = n2.maintainAspectRatio && i2.aspectRatio, a2 = i2.platform.getMaximumSize(o2, t2, e2, s2), r2 = n2.devicePixelRatio || i2.platform.getDevicePixelRatio();
          i2.width = a2.width, i2.height = a2.height, i2._aspectRatio = i2.aspectRatio, ye(i2, r2, true) && (i2.notifyPlugins("resize", { size: a2 }), Q(n2.onResize, [i2, a2], i2), i2.attached && i2._doResize() && i2.render());
        }
        ensureScalesHaveIDs() {
          J(this.options.scales || {}, (t2, e2) => {
            t2.id = e2;
          });
        }
        buildOrUpdateScales() {
          const t2 = this, e2 = t2.options, i2 = e2.scales, n2 = t2.scales, o2 = Object.keys(n2).reduce((t3, e3) => (t3[e3] = false, t3), {});
          let s2 = [];
          i2 && (s2 = s2.concat(Object.keys(i2).map((t3) => {
            const e3 = i2[t3], n3 = zn(t3, e3), o3 = n3 === "r", s3 = n3 === "x";
            return { options: e3, dposition: o3 ? "chartArea" : s3 ? "bottom" : "left", dtype: o3 ? "radialLinear" : s3 ? "category" : "linear" };
          }))), J(s2, (i3) => {
            const s3 = i3.options, a2 = s3.id, r2 = zn(a2, s3), l2 = K(s3.type, i3.dtype);
            s3.position !== void 0 && Un(s3.position, r2) === Un(i3.dposition) || (s3.position = i3.dposition), o2[a2] = true;
            let c2 = null;
            if (a2 in n2 && n2[a2].type === l2)
              c2 = n2[a2];
            else {
              c2 = new (An.getScale(l2))({ id: a2, type: l2, ctx: t2.ctx, chart: t2 }), n2[c2.id] = c2;
            }
            c2.init(s3, e2);
          }), J(o2, (t3, e3) => {
            t3 || delete n2[e3];
          }), J(n2, (e3) => {
            Ge.configure(t2, e3, e3.options), Ge.addBox(t2, e3);
          });
        }
        _updateMetasets() {
          const t2 = this, e2 = t2._metasets, i2 = t2.data.datasets.length, n2 = e2.length;
          if (e2.sort((t3, e3) => t3.index - e3.index), n2 > i2) {
            for (let e3 = i2; e3 < n2; ++e3)
              t2._destroyDatasetMeta(e3);
            e2.splice(i2, n2 - i2);
          }
          t2._sortedMetasets = e2.slice(0).sort(Xn("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const t2 = this, { _metasets: e2, data: { datasets: i2 } } = t2;
          e2.length > i2.length && delete t2._stacks, e2.forEach((e3, n2) => {
            i2.filter((t3) => t3 === e3._dataset).length === 0 && t2._destroyDatasetMeta(n2);
          });
        }
        buildOrUpdateControllers() {
          const t2 = this, e2 = [], i2 = t2.data.datasets;
          let n2, o2;
          for (t2._removeUnreferencedMetasets(), n2 = 0, o2 = i2.length; n2 < o2; n2++) {
            const o3 = i2[n2];
            let s2 = t2.getDatasetMeta(n2);
            const a2 = o3.type || t2.config.type;
            if (s2.type && s2.type !== a2 && (t2._destroyDatasetMeta(n2), s2 = t2.getDatasetMeta(n2)), s2.type = a2, s2.indexAxis = o3.indexAxis || In(a2, t2.options), s2.order = o3.order || 0, s2.index = n2, s2.label = "" + o3.label, s2.visible = t2.isDatasetVisible(n2), s2.controller)
              s2.controller.updateIndex(n2), s2.controller.linkScales();
            else {
              const i3 = An.getController(a2), { datasetElementType: o4, dataElementType: r2 } = xt.datasets[a2];
              Object.assign(i3.prototype, { dataElementType: An.getElement(r2), datasetElementType: o4 && An.getElement(o4) }), s2.controller = new i3(t2, n2), e2.push(s2.controller);
            }
          }
          return t2._updateMetasets(), e2;
        }
        _resetElements() {
          const t2 = this;
          J(t2.data.datasets, (e2, i2) => {
            t2.getDatasetMeta(i2).controller.reset();
          }, t2);
        }
        reset() {
          this._resetElements(), this.notifyPlugins("reset");
        }
        update(t2) {
          const e2 = this, i2 = e2.config;
          i2.update(), e2._options = i2.createResolver(i2.chartOptionScopes(), e2.getContext()), J(e2.scales, (t3) => {
            Ge.removeBox(e2, t3);
          });
          const n2 = e2._animationsDisabled = !e2.options.animation;
          e2.ensureScalesHaveIDs(), e2.buildOrUpdateScales();
          const o2 = new Set(Object.keys(e2._listeners)), s2 = new Set(e2.options.events);
          if (ut(o2, s2) && !!this._responsiveListeners === e2.options.responsive || (e2.unbindEvents(), e2.bindEvents()), e2._plugins.invalidate(), e2.notifyPlugins("beforeUpdate", { mode: t2, cancelable: true }) === false)
            return;
          const a2 = e2.buildOrUpdateControllers();
          e2.notifyPlugins("beforeElementsUpdate");
          let r2 = 0;
          for (let t3 = 0, i3 = e2.data.datasets.length; t3 < i3; t3++) {
            const { controller: i4 } = e2.getDatasetMeta(t3), o3 = !n2 && a2.indexOf(i4) === -1;
            i4.buildOrUpdateElements(o3), r2 = Math.max(+i4.getMaxOverflow(), r2);
          }
          e2._minPadding = r2, e2._updateLayout(r2), n2 || J(a2, (t3) => {
            t3.reset();
          }), e2._updateDatasets(t2), e2.notifyPlugins("afterUpdate", { mode: t2 }), e2._layers.sort(Xn("z", "_idx")), e2._lastEvent && e2._eventHandler(e2._lastEvent, true), e2.render();
        }
        _updateLayout(t2) {
          const e2 = this;
          if (e2.notifyPlugins("beforeLayout", { cancelable: true }) === false)
            return;
          Ge.update(e2, e2.width, e2.height, t2);
          const i2 = e2.chartArea, n2 = i2.width <= 0 || i2.height <= 0;
          e2._layers = [], J(e2.boxes, (t3) => {
            n2 && t3.position === "chartArea" || (t3.configure && t3.configure(), e2._layers.push(...t3._layers()));
          }, e2), e2._layers.forEach((t3, e3) => {
            t3._idx = e3;
          }), e2.notifyPlugins("afterLayout");
        }
        _updateDatasets(t2) {
          const e2 = this, i2 = typeof t2 == "function";
          if (e2.notifyPlugins("beforeDatasetsUpdate", { mode: t2, cancelable: true }) !== false) {
            for (let n2 = 0, o2 = e2.data.datasets.length; n2 < o2; ++n2)
              e2._updateDataset(n2, i2 ? t2({ datasetIndex: n2 }) : t2);
            e2.notifyPlugins("afterDatasetsUpdate", { mode: t2 });
          }
        }
        _updateDataset(t2, e2) {
          const i2 = this, n2 = i2.getDatasetMeta(t2), o2 = { meta: n2, index: t2, mode: e2, cancelable: true };
          i2.notifyPlugins("beforeDatasetUpdate", o2) !== false && (n2.controller._update(e2), o2.cancelable = false, i2.notifyPlugins("afterDatasetUpdate", o2));
        }
        render() {
          const t2 = this;
          t2.notifyPlugins("beforeRender", { cancelable: true }) !== false && (a.has(t2) ? t2.attached && !a.running(t2) && a.start(t2) : (t2.draw(), qn({ chart: t2 })));
        }
        draw() {
          const t2 = this;
          let e2;
          if (t2._resizeBeforeDraw) {
            const { width: e3, height: i3 } = t2._resizeBeforeDraw;
            t2._resize(e3, i3), t2._resizeBeforeDraw = null;
          }
          if (t2.clear(), t2.width <= 0 || t2.height <= 0)
            return;
          if (t2.notifyPlugins("beforeDraw", { cancelable: true }) === false)
            return;
          const i2 = t2._layers;
          for (e2 = 0; e2 < i2.length && i2[e2].z <= 0; ++e2)
            i2[e2].draw(t2.chartArea);
          for (t2._drawDatasets(); e2 < i2.length; ++e2)
            i2[e2].draw(t2.chartArea);
          t2.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(t2) {
          const e2 = this._sortedMetasets, i2 = [];
          let n2, o2;
          for (n2 = 0, o2 = e2.length; n2 < o2; ++n2) {
            const o3 = e2[n2];
            t2 && !o3.visible || i2.push(o3);
          }
          return i2;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          const t2 = this;
          if (t2.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false)
            return;
          const e2 = t2.getSortedVisibleDatasetMetas();
          for (let i2 = e2.length - 1; i2 >= 0; --i2)
            t2._drawDataset(e2[i2]);
          t2.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(t2) {
          const e2 = this, i2 = e2.ctx, n2 = t2._clip, o2 = e2.chartArea, s2 = { meta: t2, index: t2.index, cancelable: true };
          e2.notifyPlugins("beforeDatasetDraw", s2) !== false && (Zt(i2, { left: n2.left === false ? 0 : o2.left - n2.left, right: n2.right === false ? e2.width : o2.right + n2.right, top: n2.top === false ? 0 : o2.top - n2.top, bottom: n2.bottom === false ? e2.height : o2.bottom + n2.bottom }), t2.controller.draw(), Qt(i2), s2.cancelable = false, e2.notifyPlugins("afterDatasetDraw", s2));
        }
        getElementsAtEventForMode(t2, e2, i2, n2) {
          const o2 = Oe.modes[e2];
          return typeof o2 == "function" ? o2(this, t2, i2, n2) : [];
        }
        getDatasetMeta(t2) {
          const e2 = this.data.datasets[t2], i2 = this._metasets;
          let n2 = i2.filter((t3) => t3 && t3._dataset === e2).pop();
          return n2 || (n2 = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e2 && e2.order || 0, index: t2, _dataset: e2, _parsed: [], _sorted: false }, i2.push(n2)), n2;
        }
        getContext() {
          return this.$context || (this.$context = { chart: this, type: "chart" });
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(t2) {
          const e2 = this.data.datasets[t2];
          if (!e2)
            return false;
          const i2 = this.getDatasetMeta(t2);
          return typeof i2.hidden == "boolean" ? !i2.hidden : !e2.hidden;
        }
        setDatasetVisibility(t2, e2) {
          this.getDatasetMeta(t2).hidden = !e2;
        }
        toggleDataVisibility(t2) {
          this._hiddenIndices[t2] = !this._hiddenIndices[t2];
        }
        getDataVisibility(t2) {
          return !this._hiddenIndices[t2];
        }
        _updateDatasetVisibility(t2, e2) {
          const i2 = this, n2 = e2 ? "show" : "hide", o2 = i2.getDatasetMeta(t2), s2 = o2.controller._resolveAnimations(void 0, n2);
          i2.setDatasetVisibility(t2, e2), s2.update(o2, { visible: e2 }), i2.update((e3) => e3.datasetIndex === t2 ? n2 : void 0);
        }
        hide(t2) {
          this._updateDatasetVisibility(t2, false);
        }
        show(t2) {
          this._updateDatasetVisibility(t2, true);
        }
        _destroyDatasetMeta(t2) {
          const e2 = this, i2 = e2._metasets && e2._metasets[t2];
          i2 && i2.controller && (i2.controller._destroy(), delete e2._metasets[t2]);
        }
        destroy() {
          const t2 = this, { canvas: e2, ctx: i2 } = t2;
          let n2, o2;
          for (t2.stop(), a.remove(t2), n2 = 0, o2 = t2.data.datasets.length; n2 < o2; ++n2)
            t2._destroyDatasetMeta(n2);
          t2.config.clearCache(), e2 && (t2.unbindEvents(), qt(e2, i2), t2.platform.releaseContext(i2), t2.canvas = null, t2.ctx = null), t2.notifyPlugins("destroy"), delete Qn[t2.id];
        }
        toBase64Image(...t2) {
          return this.canvas.toDataURL(...t2);
        }
        bindEvents() {
          this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
        }
        bindUserEvents() {
          const t2 = this, e2 = t2._listeners, i2 = t2.platform, n2 = function(e3, i3, n3) {
            e3.offsetX = i3, e3.offsetY = n3, t2._eventHandler(e3);
          };
          J(t2.options.events, (o2) => ((n3, o3) => {
            i2.addEventListener(t2, n3, o3), e2[n3] = o3;
          })(o2, n2));
        }
        bindResponsiveEvents() {
          const t2 = this;
          t2._responsiveListeners || (t2._responsiveListeners = {});
          const e2 = t2._responsiveListeners, i2 = t2.platform, n2 = (n3, o3) => {
            i2.addEventListener(t2, n3, o3), e2[n3] = o3;
          }, o2 = (n3, o3) => {
            e2[n3] && (i2.removeEventListener(t2, n3, o3), delete e2[n3]);
          }, s2 = (e3, i3) => {
            t2.canvas && t2.resize(e3, i3);
          };
          let a2;
          const r2 = () => {
            o2("attach", r2), t2.attached = true, t2.resize(), n2("resize", s2), n2("detach", a2);
          };
          a2 = () => {
            t2.attached = false, o2("resize", s2), n2("attach", r2);
          }, i2.isAttached(t2.canvas) ? r2() : a2();
        }
        unbindEvents() {
          const t2 = this;
          J(t2._listeners, (e2, i2) => {
            t2.platform.removeEventListener(t2, i2, e2);
          }), t2._listeners = {}, J(t2._responsiveListeners, (e2, i2) => {
            t2.platform.removeEventListener(t2, i2, e2);
          }), t2._responsiveListeners = void 0;
        }
        updateHoverStyle(t2, e2, i2) {
          const n2 = i2 ? "set" : "remove";
          let o2, s2, a2, r2;
          for (e2 === "dataset" && (o2 = this.getDatasetMeta(t2[0].datasetIndex), o2.controller["_" + n2 + "DatasetHoverStyle"]()), a2 = 0, r2 = t2.length; a2 < r2; ++a2) {
            s2 = t2[a2];
            const e3 = s2 && this.getDatasetMeta(s2.datasetIndex).controller;
            e3 && e3[n2 + "HoverStyle"](s2.element, s2.datasetIndex, s2.index);
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(t2) {
          const e2 = this, i2 = e2._active || [], n2 = t2.map(({ datasetIndex: t3, index: i3 }) => {
            const n3 = e2.getDatasetMeta(t3);
            if (!n3)
              throw new Error("No dataset found at index " + t3);
            return { datasetIndex: t3, element: n3.data[i3], index: i3 };
          });
          !tt(n2, i2) && (e2._active = n2, e2._updateHoverStyles(n2, i2));
        }
        notifyPlugins(t2, e2, i2) {
          return this._plugins.notify(this, t2, e2, i2);
        }
        _updateHoverStyles(t2, e2, i2) {
          const n2 = this, o2 = n2.options.hover, s2 = (t3, e3) => t3.filter((t4) => !e3.some((e4) => t4.datasetIndex === e4.datasetIndex && t4.index === e4.index)), a2 = s2(e2, t2), r2 = i2 ? t2 : s2(t2, e2);
          a2.length && n2.updateHoverStyle(a2, o2.mode, false), r2.length && o2.mode && n2.updateHoverStyle(r2, o2.mode, true);
        }
        _eventHandler(t2, e2) {
          const i2 = this, n2 = { event: t2, replay: e2, cancelable: true }, o2 = (e3) => (e3.options.events || this.options.events).includes(t2.type);
          if (i2.notifyPlugins("beforeEvent", n2, o2) === false)
            return;
          const s2 = i2._handleEvent(t2, e2);
          return n2.cancelable = false, i2.notifyPlugins("afterEvent", n2, o2), (s2 || n2.changed) && i2.render(), i2;
        }
        _handleEvent(t2, e2) {
          const i2 = this, { _active: n2 = [], options: o2 } = i2, s2 = o2.hover, a2 = e2;
          let r2 = [], l2 = false, c2 = null;
          return t2.type !== "mouseout" && (r2 = i2.getElementsAtEventForMode(t2, s2.mode, s2, a2), c2 = t2.type === "click" ? i2._lastEvent : t2), i2._lastEvent = null, Gt(t2, i2.chartArea, i2._minPadding) && (Q(o2.onHover, [t2, r2, i2], i2), t2.type !== "mouseup" && t2.type !== "click" && t2.type !== "contextmenu" || Q(o2.onClick, [t2, r2, i2], i2)), l2 = !tt(r2, n2), (l2 || e2) && (i2._active = r2, i2._updateHoverStyles(r2, n2, e2)), i2._lastEvent = c2, l2;
        }
      }
      const eo = () => J(to.instances, (t2) => t2._plugins.invalidate()), io = true;
      function no() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      Object.defineProperties(to, { defaults: { enumerable: io, value: xt }, instances: { enumerable: io, value: Qn }, overrides: { enumerable: io, value: ft }, registry: { enumerable: io, value: An }, version: { enumerable: io, value: "3.3.2" }, getChart: { enumerable: io, value: Jn }, register: { enumerable: io, value: (...t2) => {
        An.add(...t2), eo();
      } }, unregister: { enumerable: io, value: (...t2) => {
        An.remove(...t2), eo();
      } } });
      class oo {
        constructor(t2) {
          this.options = t2 || {};
        }
        formats() {
          return no();
        }
        parse(t2, e2) {
          return no();
        }
        format(t2, e2) {
          return no();
        }
        add(t2, e2, i2) {
          return no();
        }
        diff(t2, e2, i2) {
          return no();
        }
        startOf(t2, e2, i2) {
          return no();
        }
        endOf(t2, e2) {
          return no();
        }
      }
      oo.override = function(t2) {
        Object.assign(oo.prototype, t2);
      };
      var so = { _date: oo };
      function ao(t2) {
        const e2 = function(t3) {
          if (!t3._cache.$bar) {
            const e3 = t3.getMatchingVisibleMetas("bar");
            let i3 = [];
            for (let n3 = 0, o3 = e3.length; n3 < o3; n3++)
              i3 = i3.concat(e3[n3].controller.getAllParsedValues(t3));
            t3._cache.$bar = he(i3.sort((t4, e4) => t4 - e4));
          }
          return t3._cache.$bar;
        }(t2);
        let i2, n2, o2, s2, a2 = t2._length;
        const r2 = () => {
          o2 !== 32767 && o2 !== -32768 && (ht(s2) && (a2 = Math.min(a2, Math.abs(o2 - s2) || a2)), s2 = o2);
        };
        for (i2 = 0, n2 = e2.length; i2 < n2; ++i2)
          o2 = t2.getPixelForValue(e2[i2]), r2();
        for (s2 = void 0, i2 = 0, n2 = t2.ticks.length; i2 < n2; ++i2)
          o2 = t2.getPixelForTick(i2), r2();
        return a2;
      }
      function ro(t2, e2, i2, n2) {
        return Y(t2) ? function(t3, e3, i3, n3) {
          const o2 = i3.parse(t3[0], n3), s2 = i3.parse(t3[1], n3), a2 = Math.min(o2, s2), r2 = Math.max(o2, s2);
          let l2 = a2, c2 = r2;
          Math.abs(a2) > Math.abs(r2) && (l2 = r2, c2 = a2), e3[i3.axis] = c2, e3._custom = { barStart: l2, barEnd: c2, start: o2, end: s2, min: a2, max: r2 };
        }(t2, e2, i2, n2) : e2[i2.axis] = i2.parse(t2, n2), e2;
      }
      function lo(t2, e2, i2, n2) {
        const o2 = t2.iScale, s2 = t2.vScale, a2 = o2.getLabels(), r2 = o2 === s2, l2 = [];
        let c2, h2, d2, u2;
        for (c2 = i2, h2 = i2 + n2; c2 < h2; ++c2)
          u2 = e2[c2], d2 = {}, d2[o2.axis] = r2 || o2.parse(a2[c2], c2), l2.push(ro(u2, d2, s2, c2));
        return l2;
      }
      function co(t2) {
        return t2 && t2.barStart !== void 0 && t2.barEnd !== void 0;
      }
      class ho extends Ri {
        parsePrimitiveData(t2, e2, i2, n2) {
          return lo(t2, e2, i2, n2);
        }
        parseArrayData(t2, e2, i2, n2) {
          return lo(t2, e2, i2, n2);
        }
        parseObjectData(t2, e2, i2, n2) {
          const { iScale: o2, vScale: s2 } = t2, { xAxisKey: a2 = "x", yAxisKey: r2 = "y" } = this._parsing, l2 = o2.axis === "x" ? a2 : r2, c2 = s2.axis === "x" ? a2 : r2, h2 = [];
          let d2, u2, f2, g2;
          for (d2 = i2, u2 = i2 + n2; d2 < u2; ++d2)
            g2 = e2[d2], f2 = {}, f2[o2.axis] = o2.parse(lt(g2, l2), d2), h2.push(ro(lt(g2, c2), f2, s2, d2));
          return h2;
        }
        updateRangeFromParsed(t2, e2, i2, n2) {
          super.updateRangeFromParsed(t2, e2, i2, n2);
          const o2 = i2._custom;
          o2 && e2 === this._cachedMeta.vScale && (t2.min = Math.min(t2.min, o2.min), t2.max = Math.max(t2.max, o2.max));
        }
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta, { iScale: i2, vScale: n2 } = e2, o2 = this.getParsed(t2), s2 = o2._custom, a2 = co(s2) ? "[" + s2.start + ", " + s2.end + "]" : "" + n2.getLabelForValue(o2[n2.axis]);
          return { label: "" + i2.getLabelForValue(o2[i2.axis]), value: a2 };
        }
        initialize() {
          const t2 = this;
          t2.enableOptionSharing = true, super.initialize();
          t2._cachedMeta.stack = t2.getDataset().stack;
        }
        update(t2) {
          const e2 = this._cachedMeta;
          this.updateElements(e2.data, 0, e2.data.length, t2);
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = n2 === "reset", a2 = o2._cachedMeta.vScale, r2 = a2.getBasePixel(), l2 = a2.isHorizontal(), c2 = o2._getRuler(), h2 = o2.resolveDataElementOptions(e2, n2), d2 = o2.getSharedOptions(h2), u2 = o2.includeOptions(n2, d2);
          o2.updateSharedOptions(d2, n2, h2);
          for (let h3 = e2; h3 < e2 + i2; h3++) {
            const e3 = o2.getParsed(h3), i3 = s2 || $(e3[a2.axis]) ? { base: r2, head: r2 } : o2._calculateBarValuePixels(h3), f2 = o2._calculateBarIndexPixels(h3, c2), g2 = (e3._stacks || {})[a2.axis], p2 = { horizontal: l2, base: i3.base, enableBorderRadius: !g2 || co(e3._custom) || o2.index === g2._top || o2.index === g2._bottom, x: l2 ? i3.head : f2.center, y: l2 ? f2.center : i3.head, height: l2 ? f2.size : void 0, width: l2 ? void 0 : f2.size };
            u2 && (p2.options = d2 || o2.resolveDataElementOptions(h3, n2)), o2.updateElement(t2[h3], h3, p2, n2);
          }
        }
        _getStacks(t2, e2) {
          const i2 = this._cachedMeta.iScale, n2 = i2.getMatchingVisibleMetas(this._type), o2 = i2.options.stacked, s2 = n2.length, a2 = [];
          let r2, l2;
          for (r2 = 0; r2 < s2; ++r2) {
            if (l2 = n2[r2], e2 !== void 0) {
              const t3 = l2.controller.getParsed(e2)[l2.controller._cachedMeta.vScale.axis];
              if ($(t3) || isNaN(t3))
                continue;
            }
            if ((o2 === false || a2.indexOf(l2.stack) === -1 || o2 === void 0 && l2.stack === void 0) && a2.push(l2.stack), l2.index === t2)
              break;
          }
          return a2.length || a2.push(void 0), a2;
        }
        _getStackCount(t2) {
          return this._getStacks(void 0, t2).length;
        }
        _getStackIndex(t2, e2, i2) {
          const n2 = this._getStacks(t2, i2), o2 = e2 !== void 0 ? n2.indexOf(e2) : -1;
          return o2 === -1 ? n2.length - 1 : o2;
        }
        _getRuler() {
          const t2 = this, e2 = t2.options, i2 = t2._cachedMeta, n2 = i2.iScale, o2 = [];
          let s2, a2;
          for (s2 = 0, a2 = i2.data.length; s2 < a2; ++s2)
            o2.push(n2.getPixelForValue(t2.getParsed(s2)[n2.axis], s2));
          const r2 = e2.barThickness;
          return { min: r2 || ao(n2), pixels: o2, start: n2._startPixel, end: n2._endPixel, stackCount: t2._getStackCount(), scale: n2, grouped: e2.grouped, ratio: r2 ? 1 : e2.categoryPercentage * e2.barPercentage };
        }
        _calculateBarValuePixels(t2) {
          const e2 = this, { vScale: i2, _stacked: n2 } = e2._cachedMeta, { base: o2, minBarLength: s2 } = e2.options, a2 = e2.getParsed(t2), r2 = a2._custom, l2 = co(r2);
          let c2, h2, d2 = a2[i2.axis], u2 = 0, f2 = n2 ? e2.applyStack(i2, a2, n2) : d2;
          f2 !== d2 && (u2 = f2 - d2, f2 = d2), l2 && (d2 = r2.barStart, f2 = r2.barEnd - r2.barStart, d2 !== 0 && Dt(d2) !== Dt(r2.barEnd) && (u2 = 0), u2 += d2);
          const g2 = $(o2) || l2 ? u2 : o2;
          let p2 = i2.getPixelForValue(g2);
          c2 = this.chart.getDataVisibility(t2) ? i2.getPixelForValue(u2 + f2) : p2, h2 = c2 - p2, s2 !== void 0 && Math.abs(h2) < s2 && (h2 = h2 < 0 ? -s2 : s2, d2 === 0 && (p2 -= h2 / 2), c2 = p2 + h2);
          const m2 = o2 || 0;
          if (p2 === i2.getPixelForValue(m2)) {
            const t3 = i2.getLineWidthForValue(m2) / 2;
            h2 > 0 ? (p2 += t3, h2 -= t3) : h2 < 0 && (p2 -= t3, h2 += t3);
          }
          return { size: h2, base: p2, head: c2, center: c2 + h2 / 2 };
        }
        _calculateBarIndexPixels(t2, e2) {
          const i2 = this, n2 = e2.scale, o2 = i2.options, s2 = o2.skipNull, a2 = K(o2.maxBarThickness, 1 / 0);
          let r2, l2;
          if (e2.grouped) {
            const n3 = s2 ? i2._getStackCount(t2) : e2.stackCount, c2 = o2.barThickness === "flex" ? function(t3, e3, i3, n4) {
              const o3 = e3.pixels, s3 = o3[t3];
              let a3 = t3 > 0 ? o3[t3 - 1] : null, r3 = t3 < o3.length - 1 ? o3[t3 + 1] : null;
              const l3 = i3.categoryPercentage;
              a3 === null && (a3 = s3 - (r3 === null ? e3.end - e3.start : r3 - s3)), r3 === null && (r3 = s3 + s3 - a3);
              const c3 = s3 - (s3 - Math.min(a3, r3)) / 2 * l3;
              return { chunk: Math.abs(r3 - a3) / 2 * l3 / n4, ratio: i3.barPercentage, start: c3 };
            }(t2, e2, o2, n3) : function(t3, e3, i3, n4) {
              const o3 = i3.barThickness;
              let s3, a3;
              return $(o3) ? (s3 = e3.min * i3.categoryPercentage, a3 = i3.barPercentage) : (s3 = o3 * n4, a3 = 1), { chunk: s3 / n4, ratio: a3, start: e3.pixels[t3] - s3 / 2 };
            }(t2, e2, o2, n3), h2 = i2._getStackIndex(i2.index, i2._cachedMeta.stack, s2 ? t2 : void 0);
            r2 = c2.start + c2.chunk * h2 + c2.chunk / 2, l2 = Math.min(a2, c2.chunk * c2.ratio);
          } else
            r2 = n2.getPixelForValue(i2.getParsed(t2)[n2.axis], t2), l2 = Math.min(a2, e2.min * e2.ratio);
          return { base: r2 - l2 / 2, head: r2 + l2 / 2, center: r2, size: l2 };
        }
        draw() {
          const t2 = this, e2 = t2.chart, i2 = t2._cachedMeta, n2 = i2.vScale, o2 = i2.data, s2 = o2.length;
          let a2 = 0;
          for (Zt(e2.ctx, e2.chartArea); a2 < s2; ++a2)
            t2.getParsed(a2)[n2.axis] !== null && o2[a2].draw(t2._ctx);
          Qt(e2.ctx);
        }
      }
      ho.id = "bar", ho.defaults = { datasetElementType: false, dataElementType: "bar", categoryPercentage: 0.8, barPercentage: 0.9, grouped: true, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }, ho.overrides = { interaction: { mode: "index" }, scales: { _index_: { type: "category", offset: true, grid: { offset: true } }, _value_: { type: "linear", beginAtZero: true } } };
      class uo extends Ri {
        initialize() {
          this.enableOptionSharing = true, super.initialize();
        }
        parseObjectData(t2, e2, i2, n2) {
          const { xScale: o2, yScale: s2 } = t2, { xAxisKey: a2 = "x", yAxisKey: r2 = "y" } = this._parsing, l2 = [];
          let c2, h2, d2;
          for (c2 = i2, h2 = i2 + n2; c2 < h2; ++c2)
            d2 = e2[c2], l2.push({ x: o2.parse(lt(d2, a2), c2), y: s2.parse(lt(d2, r2), c2), _custom: d2 && d2.r && +d2.r });
          return l2;
        }
        getMaxOverflow() {
          const { data: t2, _parsed: e2 } = this._cachedMeta;
          let i2 = 0;
          for (let n2 = t2.length - 1; n2 >= 0; --n2)
            i2 = Math.max(i2, t2[n2].size() / 2, e2[n2]._custom);
          return i2 > 0 && i2;
        }
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta, { xScale: i2, yScale: n2 } = e2, o2 = this.getParsed(t2), s2 = i2.getLabelForValue(o2.x), a2 = n2.getLabelForValue(o2.y), r2 = o2._custom;
          return { label: e2.label, value: "(" + s2 + ", " + a2 + (r2 ? ", " + r2 : "") + ")" };
        }
        update(t2) {
          const e2 = this._cachedMeta.data;
          this.updateElements(e2, 0, e2.length, t2);
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = n2 === "reset", { iScale: a2, vScale: r2 } = o2._cachedMeta, l2 = o2.resolveDataElementOptions(e2, n2), c2 = o2.getSharedOptions(l2), h2 = o2.includeOptions(n2, c2), d2 = a2.axis, u2 = r2.axis;
          for (let l3 = e2; l3 < e2 + i2; l3++) {
            const e3 = t2[l3], i3 = !s2 && o2.getParsed(l3), c3 = {}, f2 = c3[d2] = s2 ? a2.getPixelForDecimal(0.5) : a2.getPixelForValue(i3[d2]), g2 = c3[u2] = s2 ? r2.getBasePixel() : r2.getPixelForValue(i3[u2]);
            c3.skip = isNaN(f2) || isNaN(g2), h2 && (c3.options = o2.resolveDataElementOptions(l3, n2), s2 && (c3.options.radius = 0)), o2.updateElement(e3, l3, c3, n2);
          }
          o2.updateSharedOptions(c2, n2, l2);
        }
        resolveDataElementOptions(t2, e2) {
          const i2 = this.getParsed(t2);
          let n2 = super.resolveDataElementOptions(t2, e2);
          n2.$shared && (n2 = Object.assign({}, n2, { $shared: false }));
          const o2 = n2.radius;
          return e2 !== "active" && (n2.radius = 0), n2.radius += K(i2 && i2._custom, o2), n2;
        }
      }
      uo.id = "bubble", uo.defaults = { datasetElementType: false, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }, uo.overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } }, plugins: { tooltip: { callbacks: { title: () => "" } } } };
      class fo extends Ri {
        constructor(t2, e2) {
          super(t2, e2), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(t2, e2) {
          const i2 = this.getDataset().data, n2 = this._cachedMeta;
          let o2, s2;
          for (o2 = t2, s2 = t2 + e2; o2 < s2; ++o2)
            n2._parsed[o2] = +i2[o2];
        }
        _getRotation() {
          return Et(this.options.rotation - 90);
        }
        _getCircumference() {
          return Et(this.options.circumference);
        }
        _getRotationExtents() {
          let t2 = _t, e2 = -_t;
          const i2 = this;
          for (let n2 = 0; n2 < i2.chart.data.datasets.length; ++n2)
            if (i2.chart.isDatasetVisible(n2)) {
              const o2 = i2.chart.getDatasetMeta(n2).controller, s2 = o2._getRotation(), a2 = o2._getCircumference();
              t2 = Math.min(t2, s2), e2 = Math.max(e2, s2 + a2);
            }
          return { rotation: t2, circumference: e2 - t2 };
        }
        update(t2) {
          const e2 = this, i2 = e2.chart, { chartArea: n2 } = i2, o2 = e2._cachedMeta, s2 = o2.data, a2 = e2.getMaxBorderWidth() + e2.getMaxOffset(s2), r2 = Math.max((Math.min(n2.width, n2.height) - a2) / 2, 0), l2 = Math.min(G(e2.options.cutout, r2), 1), c2 = e2._getRingWeight(e2.index), { circumference: h2, rotation: d2 } = e2._getRotationExtents(), { ratioX: u2, ratioY: f2, offsetX: g2, offsetY: p2 } = function(t3, e3, i3) {
            let n3 = 1, o3 = 1, s3 = 0, a3 = 0;
            if (e3 < _t) {
              const r3 = t3, l3 = r3 + e3, c3 = Math.cos(r3), h3 = Math.sin(r3), d3 = Math.cos(l3), u3 = Math.sin(l3), f3 = (t4, e4, n4) => Ht(t4, r3, l3, true) ? 1 : Math.max(e4, e4 * i3, n4, n4 * i3), g3 = (t4, e4, n4) => Ht(t4, r3, l3, true) ? -1 : Math.min(e4, e4 * i3, n4, n4 * i3), p3 = f3(0, c3, d3), m3 = f3(Mt, h3, u3), x3 = g3(bt, c3, d3), b3 = g3(bt + Mt, h3, u3);
              n3 = (p3 - x3) / 2, o3 = (m3 - b3) / 2, s3 = -(p3 + x3) / 2, a3 = -(m3 + b3) / 2;
            }
            return { ratioX: n3, ratioY: o3, offsetX: s3, offsetY: a3 };
          }(d2, h2, l2), m2 = (n2.width - a2) / u2, x2 = (n2.height - a2) / f2, b2 = Math.max(Math.min(m2, x2) / 2, 0), _2 = Z(e2.options.radius, b2), y2 = (_2 - Math.max(_2 * l2, 0)) / e2._getVisibleDatasetWeightTotal();
          e2.offsetX = g2 * _2, e2.offsetY = p2 * _2, o2.total = e2.calculateTotal(), e2.outerRadius = _2 - y2 * e2._getRingWeightOffset(e2.index), e2.innerRadius = Math.max(e2.outerRadius - y2 * c2, 0), e2.updateElements(s2, 0, s2.length, t2);
        }
        _circumference(t2, e2) {
          const i2 = this, n2 = i2.options, o2 = i2._cachedMeta, s2 = i2._getCircumference();
          return e2 && n2.animation.animateRotate || !this.chart.getDataVisibility(t2) || o2._parsed[t2] === null ? 0 : i2.calculateCircumference(o2._parsed[t2] * s2 / _t);
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = n2 === "reset", a2 = o2.chart, r2 = a2.chartArea, l2 = a2.options.animation, c2 = (r2.left + r2.right) / 2, h2 = (r2.top + r2.bottom) / 2, d2 = s2 && l2.animateScale, u2 = d2 ? 0 : o2.innerRadius, f2 = d2 ? 0 : o2.outerRadius, g2 = o2.resolveDataElementOptions(e2, n2), p2 = o2.getSharedOptions(g2), m2 = o2.includeOptions(n2, p2);
          let x2, b2 = o2._getRotation();
          for (x2 = 0; x2 < e2; ++x2)
            b2 += o2._circumference(x2, s2);
          for (x2 = e2; x2 < e2 + i2; ++x2) {
            const e3 = o2._circumference(x2, s2), i3 = t2[x2], a3 = { x: c2 + o2.offsetX, y: h2 + o2.offsetY, startAngle: b2, endAngle: b2 + e3, circumference: e3, outerRadius: f2, innerRadius: u2 };
            m2 && (a3.options = p2 || o2.resolveDataElementOptions(x2, n2)), b2 += e3, o2.updateElement(i3, x2, a3, n2);
          }
          o2.updateSharedOptions(p2, n2, g2);
        }
        calculateTotal() {
          const t2 = this._cachedMeta, e2 = t2.data;
          let i2, n2 = 0;
          for (i2 = 0; i2 < e2.length; i2++) {
            const e3 = t2._parsed[i2];
            e3 !== null && !isNaN(e3) && this.chart.getDataVisibility(i2) && (n2 += Math.abs(e3));
          }
          return n2;
        }
        calculateCircumference(t2) {
          const e2 = this._cachedMeta.total;
          return e2 > 0 && !isNaN(t2) ? _t * (Math.abs(t2) / e2) : 0;
        }
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta, i2 = this.chart, n2 = i2.data.labels || [], o2 = zi(e2._parsed[t2], i2.options.locale);
          return { label: n2[t2] || "", value: o2 };
        }
        getMaxBorderWidth(t2) {
          const e2 = this;
          let i2 = 0;
          const n2 = e2.chart;
          let o2, s2, a2, r2, l2;
          if (!t2) {
            for (o2 = 0, s2 = n2.data.datasets.length; o2 < s2; ++o2)
              if (n2.isDatasetVisible(o2)) {
                a2 = n2.getDatasetMeta(o2), t2 = a2.data, r2 = a2.controller, r2 !== e2 && r2.configure();
                break;
              }
          }
          if (!t2)
            return 0;
          for (o2 = 0, s2 = t2.length; o2 < s2; ++o2)
            l2 = r2.resolveDataElementOptions(o2), l2.borderAlign !== "inner" && (i2 = Math.max(i2, l2.borderWidth || 0, l2.hoverBorderWidth || 0));
          return i2;
        }
        getMaxOffset(t2) {
          let e2 = 0;
          for (let i2 = 0, n2 = t2.length; i2 < n2; ++i2) {
            const t3 = this.resolveDataElementOptions(i2);
            e2 = Math.max(e2, t3.offset || 0, t3.hoverOffset || 0);
          }
          return e2;
        }
        _getRingWeightOffset(t2) {
          let e2 = 0;
          for (let i2 = 0; i2 < t2; ++i2)
            this.chart.isDatasetVisible(i2) && (e2 += this._getRingWeight(i2));
          return e2;
        }
        _getRingWeight(t2) {
          return Math.max(K(this.chart.data.datasets[t2].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      }
      fo.id = "doughnut", fo.defaults = { datasetElementType: false, dataElementType: "arc", animation: { animateRotate: true, animateScale: false }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", indexAxis: "r" }, fo.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t2) {
        const e2 = t2.data;
        return e2.labels.length && e2.datasets.length ? e2.labels.map((e3, i2) => {
          const n2 = t2.getDatasetMeta(0).controller.getStyle(i2);
          return { text: e3, fillStyle: n2.backgroundColor, strokeStyle: n2.borderColor, lineWidth: n2.borderWidth, hidden: !t2.getDataVisibility(i2), index: i2 };
        }) : [];
      } }, onClick(t2, e2, i2) {
        i2.chart.toggleDataVisibility(e2.index), i2.chart.update();
      } }, tooltip: { callbacks: { title: () => "", label(t2) {
        let e2 = t2.label;
        const i2 = ": " + t2.formattedValue;
        return Y(e2) ? (e2 = e2.slice(), e2[0] += i2) : e2 += i2, e2;
      } } } } };
      class go extends Ri {
        initialize() {
          this.enableOptionSharing = true, super.initialize();
        }
        update(t2) {
          const e2 = this, i2 = e2._cachedMeta, { dataset: n2, data: o2 = [], _dataset: s2 } = i2, a2 = e2.chart._animationsDisabled;
          let { start: r2, count: l2 } = function(t3, e3, i3) {
            const n3 = e3.length;
            let o3 = 0, s3 = n3;
            if (t3._sorted) {
              const { iScale: a3, _parsed: r3 } = t3, l3 = a3.axis, { min: c3, max: h2, minDefined: d2, maxDefined: u2 } = a3.getUserBounds();
              d2 && (o3 = Nt(Math.min(oe(r3, a3.axis, c3).lo, i3 ? n3 : oe(e3, l3, a3.getPixelForValue(c3)).lo), 0, n3 - 1)), s3 = u2 ? Nt(Math.max(oe(r3, a3.axis, h2).hi + 1, i3 ? 0 : oe(e3, l3, a3.getPixelForValue(h2)).hi + 1), o3, n3) - o3 : n3 - o3;
            }
            return { start: o3, count: s3 };
          }(i2, o2, a2);
          e2._drawStart = r2, e2._drawCount = l2, function(t3) {
            const { xScale: e3, yScale: i3, _scaleRanges: n3 } = t3, o3 = { xmin: e3.min, xmax: e3.max, ymin: i3.min, ymax: i3.max };
            if (!n3)
              return t3._scaleRanges = o3, true;
            const s3 = n3.xmin !== e3.min || n3.xmax !== e3.max || n3.ymin !== i3.min || n3.ymax !== i3.max;
            return Object.assign(n3, o3), s3;
          }(i2) && (r2 = 0, l2 = o2.length), n2._decimated = !!s2._decimated, n2.points = o2;
          const c2 = e2.resolveDatasetElementOptions(t2);
          e2.options.showLine || (c2.borderWidth = 0), c2.segment = e2.options.segment, e2.updateElement(n2, void 0, { animated: !a2, options: c2 }, t2), e2.updateElements(o2, r2, l2, t2);
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = n2 === "reset", { iScale: a2, vScale: r2, _stacked: l2 } = o2._cachedMeta, c2 = o2.resolveDataElementOptions(e2, n2), h2 = o2.getSharedOptions(c2), d2 = o2.includeOptions(n2, h2), u2 = a2.axis, f2 = r2.axis, g2 = o2.options.spanGaps, p2 = Tt(g2) ? g2 : Number.POSITIVE_INFINITY, m2 = o2.chart._animationsDisabled || s2 || n2 === "none";
          let x2 = e2 > 0 && o2.getParsed(e2 - 1);
          for (let c3 = e2; c3 < e2 + i2; ++c3) {
            const e3 = t2[c3], i3 = o2.getParsed(c3), g3 = m2 ? e3 : {}, b2 = $(i3[f2]), _2 = g3[u2] = a2.getPixelForValue(i3[u2], c3), y2 = g3[f2] = s2 || b2 ? r2.getBasePixel() : r2.getPixelForValue(l2 ? o2.applyStack(r2, i3, l2) : i3[f2], c3);
            g3.skip = isNaN(_2) || isNaN(y2) || b2, g3.stop = c3 > 0 && i3[u2] - x2[u2] > p2, g3.parsed = i3, d2 && (g3.options = h2 || o2.resolveDataElementOptions(c3, n2)), m2 || o2.updateElement(e3, c3, g3, n2), x2 = i3;
          }
          o2.updateSharedOptions(h2, n2, c2);
        }
        getMaxOverflow() {
          const t2 = this, e2 = t2._cachedMeta, i2 = e2.dataset, n2 = i2.options && i2.options.borderWidth || 0, o2 = e2.data || [];
          if (!o2.length)
            return n2;
          const s2 = o2[0].size(t2.resolveDataElementOptions(0)), a2 = o2[o2.length - 1].size(t2.resolveDataElementOptions(o2.length - 1));
          return Math.max(n2, s2, a2) / 2;
        }
        draw() {
          const t2 = this._cachedMeta;
          t2.dataset.updateControlPoints(this.chart.chartArea, t2.iScale.axis), super.draw();
        }
      }
      go.id = "line", go.defaults = { datasetElementType: "line", dataElementType: "point", showLine: true, spanGaps: false }, go.overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } };
      class po extends Ri {
        constructor(t2, e2) {
          super(t2, e2), this.innerRadius = void 0, this.outerRadius = void 0;
        }
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta, i2 = this.chart, n2 = i2.data.labels || [], o2 = zi(e2._parsed[t2].r, i2.options.locale);
          return { label: n2[t2] || "", value: o2 };
        }
        update(t2) {
          const e2 = this._cachedMeta.data;
          this._updateRadius(), this.updateElements(e2, 0, e2.length, t2);
        }
        _updateRadius() {
          const t2 = this, e2 = t2.chart, i2 = e2.chartArea, n2 = e2.options, o2 = Math.min(i2.right - i2.left, i2.bottom - i2.top), s2 = Math.max(o2 / 2, 0), a2 = (s2 - Math.max(n2.cutoutPercentage ? s2 / 100 * n2.cutoutPercentage : 1, 0)) / e2.getVisibleDatasetCount();
          t2.outerRadius = s2 - a2 * t2.index, t2.innerRadius = t2.outerRadius - a2;
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = n2 === "reset", a2 = o2.chart, r2 = o2.getDataset(), l2 = a2.options.animation, c2 = o2._cachedMeta.rScale, h2 = c2.xCenter, d2 = c2.yCenter, u2 = c2.getIndexAngle(0) - 0.5 * bt;
          let f2, g2 = u2;
          const p2 = 360 / o2.countVisibleElements();
          for (f2 = 0; f2 < e2; ++f2)
            g2 += o2._computeAngle(f2, n2, p2);
          for (f2 = e2; f2 < e2 + i2; f2++) {
            const e3 = t2[f2];
            let i3 = g2, m2 = g2 + o2._computeAngle(f2, n2, p2), x2 = a2.getDataVisibility(f2) ? c2.getDistanceFromCenterForValue(r2.data[f2]) : 0;
            g2 = m2, s2 && (l2.animateScale && (x2 = 0), l2.animateRotate && (i3 = m2 = u2));
            const b2 = { x: h2, y: d2, innerRadius: 0, outerRadius: x2, startAngle: i3, endAngle: m2, options: o2.resolveDataElementOptions(f2, n2) };
            o2.updateElement(e3, f2, b2, n2);
          }
        }
        countVisibleElements() {
          const t2 = this.getDataset(), e2 = this._cachedMeta;
          let i2 = 0;
          return e2.data.forEach((e3, n2) => {
            !isNaN(t2.data[n2]) && this.chart.getDataVisibility(n2) && i2++;
          }), i2;
        }
        _computeAngle(t2, e2, i2) {
          return this.chart.getDataVisibility(t2) ? Et(this.resolveDataElementOptions(t2, e2).angle || i2) : 0;
        }
      }
      po.id = "polarArea", po.defaults = { dataElementType: "arc", animation: { animateRotate: true, animateScale: true }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }, po.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t2) {
        const e2 = t2.data;
        return e2.labels.length && e2.datasets.length ? e2.labels.map((e3, i2) => {
          const n2 = t2.getDatasetMeta(0).controller.getStyle(i2);
          return { text: e3, fillStyle: n2.backgroundColor, strokeStyle: n2.borderColor, lineWidth: n2.borderWidth, hidden: !t2.getDataVisibility(i2), index: i2 };
        }) : [];
      } }, onClick(t2, e2, i2) {
        i2.chart.toggleDataVisibility(e2.index), i2.chart.update();
      } }, tooltip: { callbacks: { title: () => "", label: (t2) => t2.chart.data.labels[t2.dataIndex] + ": " + t2.formattedValue } } }, scales: { r: { type: "radialLinear", angleLines: { display: false }, beginAtZero: true, grid: { circular: true }, pointLabels: { display: false }, startAngle: 0 } } };
      class mo extends fo {
      }
      mo.id = "pie", mo.defaults = { cutout: 0, rotation: 0, circumference: 360, radius: "100%" };
      class xo extends Ri {
        getLabelAndValue(t2) {
          const e2 = this._cachedMeta.vScale, i2 = this.getParsed(t2);
          return { label: e2.getLabels()[t2], value: "" + e2.getLabelForValue(i2[e2.axis]) };
        }
        update(t2) {
          const e2 = this, i2 = e2._cachedMeta, n2 = i2.dataset, o2 = i2.data || [], s2 = i2.iScale.getLabels();
          if (n2.points = o2, t2 !== "resize") {
            const i3 = e2.resolveDatasetElementOptions(t2);
            e2.options.showLine || (i3.borderWidth = 0);
            const a2 = { _loop: true, _fullLoop: s2.length === o2.length, options: i3 };
            e2.updateElement(n2, void 0, a2, t2);
          }
          e2.updateElements(o2, 0, o2.length, t2);
        }
        updateElements(t2, e2, i2, n2) {
          const o2 = this, s2 = o2.getDataset(), a2 = o2._cachedMeta.rScale, r2 = n2 === "reset";
          for (let l2 = e2; l2 < e2 + i2; l2++) {
            const e3 = t2[l2], i3 = o2.resolveDataElementOptions(l2, n2), c2 = a2.getPointPositionForValue(l2, s2.data[l2]), h2 = r2 ? a2.xCenter : c2.x, d2 = r2 ? a2.yCenter : c2.y, u2 = { x: h2, y: d2, angle: c2.angle, skip: isNaN(h2) || isNaN(d2), options: i3 };
            o2.updateElement(e3, l2, u2, n2);
          }
        }
      }
      xo.id = "radar", xo.defaults = { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: true, elements: { line: { fill: "start" } } }, xo.overrides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } };
      class bo extends go {
      }
      bo.id = "scatter", bo.defaults = { showLine: false, fill: false }, bo.overrides = { interaction: { mode: "point" }, plugins: { tooltip: { callbacks: { title: () => "", label: (t2) => "(" + t2.label + ", " + t2.formattedValue + ")" } } }, scales: { x: { type: "linear" }, y: { type: "linear" } } };
      var _o = Object.freeze({ __proto__: null, BarController: ho, BubbleController: uo, DoughnutController: fo, LineController: go, PolarAreaController: po, PieController: mo, RadarController: xo, ScatterController: bo });
      function yo(t2, e2, i2) {
        const { startAngle: n2, pixelMargin: o2, x: s2, y: a2, outerRadius: r2, innerRadius: l2 } = e2;
        let c2 = o2 / r2;
        t2.beginPath(), t2.arc(s2, a2, r2, n2 - c2, i2 + c2), l2 > o2 ? (c2 = o2 / l2, t2.arc(s2, a2, l2, i2 + c2, n2 - c2, true)) : t2.arc(s2, a2, o2, i2 + Mt, n2 - Mt), t2.closePath(), t2.clip();
      }
      function vo(t2, e2, i2, n2) {
        const o2 = Re(t2.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        const s2 = (i2 - e2) / 2, a2 = Math.min(s2, n2 * e2 / 2), r2 = (t3) => {
          const e3 = (i2 - Math.min(s2, t3)) * n2 / 2;
          return Nt(t3, 0, Math.min(s2, e3));
        };
        return { outerStart: r2(o2.outerStart), outerEnd: r2(o2.outerEnd), innerStart: Nt(o2.innerStart, 0, a2), innerEnd: Nt(o2.innerEnd, 0, a2) };
      }
      function wo(t2, e2, i2, n2) {
        return { x: i2 + t2 * Math.cos(e2), y: n2 + t2 * Math.sin(e2) };
      }
      function Mo(t2, e2, i2, n2) {
        const { x: o2, y: s2, startAngle: a2, pixelMargin: r2, innerRadius: l2 } = e2, c2 = Math.max(e2.outerRadius + i2 - r2, 0), h2 = l2 > 0 ? l2 + i2 + r2 : 0, d2 = n2 - a2, u2 = (d2 - Math.max(1e-3, d2 * c2 - i2 / bt) / c2) / 2, f2 = a2 + u2, g2 = n2 - u2, { outerStart: p2, outerEnd: m2, innerStart: x2, innerEnd: b2 } = vo(e2, h2, c2, g2 - f2), _2 = c2 - p2, y2 = c2 - m2, v2 = f2 + p2 / _2, w2 = g2 - m2 / y2, M2 = h2 + x2, k2 = h2 + b2, S2 = f2 + x2 / M2, P2 = g2 - b2 / k2;
        if (t2.beginPath(), t2.arc(o2, s2, c2, v2, w2), m2 > 0) {
          const e3 = wo(y2, w2, o2, s2);
          t2.arc(e3.x, e3.y, m2, w2, g2 + Mt);
        }
        const D2 = wo(k2, g2, o2, s2);
        if (t2.lineTo(D2.x, D2.y), b2 > 0) {
          const e3 = wo(k2, P2, o2, s2);
          t2.arc(e3.x, e3.y, b2, g2 + Mt, P2 + Math.PI);
        }
        if (t2.arc(o2, s2, h2, g2 - b2 / h2, f2 + x2 / h2, true), x2 > 0) {
          const e3 = wo(M2, S2, o2, s2);
          t2.arc(e3.x, e3.y, x2, S2 + Math.PI, f2 - Mt);
        }
        const C2 = wo(_2, f2, o2, s2);
        if (t2.lineTo(C2.x, C2.y), p2 > 0) {
          const e3 = wo(_2, v2, o2, s2);
          t2.arc(e3.x, e3.y, p2, f2 - Mt, v2);
        }
        t2.closePath();
      }
      function ko(t2, e2, i2, n2) {
        const { options: o2 } = e2, s2 = o2.borderAlign === "inner";
        o2.borderWidth && (s2 ? (t2.lineWidth = 2 * o2.borderWidth, t2.lineJoin = "round") : (t2.lineWidth = o2.borderWidth, t2.lineJoin = "bevel"), e2.fullCircles && function(t3, e3, i3) {
          const { x: n3, y: o3, startAngle: s3, pixelMargin: a2, fullCircles: r2 } = e3, l2 = Math.max(e3.outerRadius - a2, 0), c2 = e3.innerRadius + a2;
          let h2;
          for (i3 && yo(t3, e3, s3 + _t), t3.beginPath(), t3.arc(n3, o3, c2, s3 + _t, s3, true), h2 = 0; h2 < r2; ++h2)
            t3.stroke();
          for (t3.beginPath(), t3.arc(n3, o3, l2, s3, s3 + _t), h2 = 0; h2 < r2; ++h2)
            t3.stroke();
        }(t2, e2, s2), s2 && yo(t2, e2, n2), Mo(t2, e2, i2, n2), t2.stroke());
      }
      class So extends Ei {
        constructor(t2) {
          super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t2 && Object.assign(this, t2);
        }
        inRange(t2, e2, i2) {
          const n2 = this.getProps(["x", "y"], i2), { angle: o2, distance: s2 } = Ft(n2, { x: t2, y: e2 }), { startAngle: a2, endAngle: r2, innerRadius: l2, outerRadius: c2, circumference: h2 } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i2);
          return (h2 >= _t || Ht(o2, a2, r2)) && (s2 >= l2 && s2 <= c2);
        }
        getCenterPoint(t2) {
          const { x: e2, y: i2, startAngle: n2, endAngle: o2, innerRadius: s2, outerRadius: a2 } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t2), r2 = (n2 + o2) / 2, l2 = (s2 + a2) / 2;
          return { x: e2 + Math.cos(r2) * l2, y: i2 + Math.sin(r2) * l2 };
        }
        tooltipPosition(t2) {
          return this.getCenterPoint(t2);
        }
        draw(t2) {
          const e2 = this, { options: i2, circumference: n2 } = e2, o2 = (i2.offset || 0) / 2;
          if (e2.pixelMargin = i2.borderAlign === "inner" ? 0.33 : 0, e2.fullCircles = n2 > _t ? Math.floor(n2 / _t) : 0, n2 === 0 || e2.innerRadius < 0 || e2.outerRadius < 0)
            return;
          t2.save();
          let s2 = 0;
          if (o2) {
            s2 = o2 / 2;
            const i3 = (e2.startAngle + e2.endAngle) / 2;
            t2.translate(Math.cos(i3) * s2, Math.sin(i3) * s2), e2.circumference >= bt && (s2 = o2);
          }
          t2.fillStyle = i2.backgroundColor, t2.strokeStyle = i2.borderColor;
          const a2 = function(t3, e3, i3) {
            const { fullCircles: n3, startAngle: o3, circumference: s3 } = e3;
            let a3 = e3.endAngle;
            if (n3) {
              Mo(t3, e3, i3, o3 + _t);
              for (let e4 = 0; e4 < n3; ++e4)
                t3.fill();
              isNaN(s3) || (a3 = o3 + s3 % _t, s3 % _t == 0 && (a3 += _t));
            }
            return Mo(t3, e3, i3, a3), t3.fill(), a3;
          }(t2, e2, s2);
          ko(t2, e2, s2, a2), t2.restore();
        }
      }
      function Po(t2, e2, i2 = e2) {
        t2.lineCap = K(i2.borderCapStyle, e2.borderCapStyle), t2.setLineDash(K(i2.borderDash, e2.borderDash)), t2.lineDashOffset = K(i2.borderDashOffset, e2.borderDashOffset), t2.lineJoin = K(i2.borderJoinStyle, e2.borderJoinStyle), t2.lineWidth = K(i2.borderWidth, e2.borderWidth), t2.strokeStyle = K(i2.borderColor, e2.borderColor);
      }
      function Do(t2, e2, i2) {
        t2.lineTo(i2.x, i2.y);
      }
      function Co(t2, e2, i2 = {}) {
        const n2 = t2.length, { start: o2 = 0, end: s2 = n2 - 1 } = i2, { start: a2, end: r2 } = e2, l2 = Math.max(o2, a2), c2 = Math.min(s2, r2), h2 = o2 < a2 && s2 < a2 || o2 > r2 && s2 > r2;
        return { count: n2, start: l2, loop: e2.loop, ilen: c2 < l2 && !h2 ? n2 + c2 - l2 : c2 - l2 };
      }
      function Oo(t2, e2, i2, n2) {
        const { points: o2, options: s2 } = e2, { count: a2, start: r2, loop: l2, ilen: c2 } = Co(o2, i2, n2), h2 = function(t3) {
          return t3.stepped ? Jt : t3.tension || t3.cubicInterpolationMode === "monotone" ? te : Do;
        }(s2);
        let d2, u2, f2, { move: g2 = true, reverse: p2 } = n2 || {};
        for (d2 = 0; d2 <= c2; ++d2)
          u2 = o2[(r2 + (p2 ? c2 - d2 : d2)) % a2], u2.skip || (g2 ? (t2.moveTo(u2.x, u2.y), g2 = false) : h2(t2, f2, u2, p2, s2.stepped), f2 = u2);
        return l2 && (u2 = o2[(r2 + (p2 ? c2 : 0)) % a2], h2(t2, f2, u2, p2, s2.stepped)), !!l2;
      }
      function To(t2, e2, i2, n2) {
        const o2 = e2.points, { count: s2, start: a2, ilen: r2 } = Co(o2, i2, n2), { move: l2 = true, reverse: c2 } = n2 || {};
        let h2, d2, u2, f2, g2, p2, m2 = 0, x2 = 0;
        const b2 = (t3) => (a2 + (c2 ? r2 - t3 : t3)) % s2, _2 = () => {
          f2 !== g2 && (t2.lineTo(m2, g2), t2.lineTo(m2, f2), t2.lineTo(m2, p2));
        };
        for (l2 && (d2 = o2[b2(0)], t2.moveTo(d2.x, d2.y)), h2 = 0; h2 <= r2; ++h2) {
          if (d2 = o2[b2(h2)], d2.skip)
            continue;
          const e3 = d2.x, i3 = d2.y, n3 = 0 | e3;
          n3 === u2 ? (i3 < f2 ? f2 = i3 : i3 > g2 && (g2 = i3), m2 = (x2 * m2 + e3) / ++x2) : (_2(), t2.lineTo(e3, i3), u2 = n3, x2 = 0, f2 = g2 = i3), p2 = i3;
        }
        _2();
      }
      function Ao(t2) {
        const e2 = t2.options, i2 = e2.borderDash && e2.borderDash.length;
        return !(t2._decimated || t2._loop || e2.tension || e2.cubicInterpolationMode === "monotone" || e2.stepped || i2) ? To : Oo;
      }
      So.id = "arc", So.defaults = { borderAlign: "center", borderColor: "#fff", borderRadius: 0, borderWidth: 2, offset: 0, angle: void 0 }, So.defaultRoutes = { backgroundColor: "backgroundColor" };
      const Lo = typeof Path2D == "function";
      function Ro(t2, e2, i2, n2) {
        Lo && e2.segments.length === 1 ? function(t3, e3, i3, n3) {
          let o2 = e3._path;
          o2 || (o2 = e3._path = new Path2D(), e3.path(o2, i3, n3) && o2.closePath()), Po(t3, e3.options), t3.stroke(o2);
        }(t2, e2, i2, n2) : function(t3, e3, i3, n3) {
          const { segments: o2, options: s2 } = e3, a2 = Ao(e3);
          for (const r2 of o2)
            Po(t3, s2, r2.style), t3.beginPath(), a2(t3, e3, r2, { start: i3, end: i3 + n3 - 1 }) && t3.closePath(), t3.stroke();
        }(t2, e2, i2, n2);
      }
      class Eo extends Ei {
        constructor(t2) {
          super(), this.animated = true, this.options = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, t2 && Object.assign(this, t2);
        }
        updateControlPoints(t2, e2) {
          const i2 = this, n2 = i2.options;
          if ((n2.tension || n2.cubicInterpolationMode === "monotone") && !n2.stepped && !i2._pointsUpdated) {
            const o2 = n2.spanGaps ? i2._loop : i2._fullLoop;
            gn(i2._points, n2, t2, o2, e2), i2._pointsUpdated = true;
          }
        }
        set points(t2) {
          const e2 = this;
          e2._points = t2, delete e2._segments, delete e2._path, e2._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = Sn(this, this.options.segment));
        }
        first() {
          const t2 = this.segments, e2 = this.points;
          return t2.length && e2[t2[0].start];
        }
        last() {
          const t2 = this.segments, e2 = this.points, i2 = t2.length;
          return i2 && e2[t2[i2 - 1].end];
        }
        interpolate(t2, e2) {
          const i2 = this, n2 = i2.options, o2 = t2[e2], s2 = i2.points, a2 = kn(i2, { property: e2, start: o2, end: o2 });
          if (!a2.length)
            return;
          const r2 = [], l2 = function(t3) {
            return t3.stepped ? mn : t3.tension || t3.cubicInterpolationMode === "monotone" ? xn : pn;
          }(n2);
          let c2, h2;
          for (c2 = 0, h2 = a2.length; c2 < h2; ++c2) {
            const { start: i3, end: h3 } = a2[c2], d2 = s2[i3], u2 = s2[h3];
            if (d2 === u2) {
              r2.push(d2);
              continue;
            }
            const f2 = l2(d2, u2, Math.abs((o2 - d2[e2]) / (u2[e2] - d2[e2])), n2.stepped);
            f2[e2] = t2[e2], r2.push(f2);
          }
          return r2.length === 1 ? r2[0] : r2;
        }
        pathSegment(t2, e2, i2) {
          return Ao(this)(t2, this, e2, i2);
        }
        path(t2, e2, i2) {
          const n2 = this, o2 = n2.segments, s2 = Ao(n2);
          let a2 = n2._loop;
          e2 = e2 || 0, i2 = i2 || n2.points.length - e2;
          for (const r2 of o2)
            a2 &= s2(t2, n2, r2, { start: e2, end: e2 + i2 - 1 });
          return !!a2;
        }
        draw(t2, e2, i2, n2) {
          const o2 = this, s2 = o2.options || {};
          (o2.points || []).length && s2.borderWidth && (t2.save(), Ro(t2, o2, i2, n2), t2.restore(), o2.animated && (o2._pointsUpdated = false, o2._path = void 0));
        }
      }
      function Io(t2, e2, i2, n2) {
        const o2 = t2.options, { [i2]: s2 } = t2.getProps([i2], n2);
        return Math.abs(e2 - s2) < o2.radius + o2.hitRadius;
      }
      Eo.id = "line", Eo.defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: true, cubicInterpolationMode: "default", fill: false, spanGaps: false, stepped: false, tension: 0 }, Eo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }, Eo.descriptors = { _scriptable: true, _indexable: (t2) => t2 !== "borderDash" && t2 !== "fill" };
      class zo extends Ei {
        constructor(t2) {
          super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t2 && Object.assign(this, t2);
        }
        inRange(t2, e2, i2) {
          const n2 = this.options, { x: o2, y: s2 } = this.getProps(["x", "y"], i2);
          return Math.pow(t2 - o2, 2) + Math.pow(e2 - s2, 2) < Math.pow(n2.hitRadius + n2.radius, 2);
        }
        inXRange(t2, e2) {
          return Io(this, t2, "x", e2);
        }
        inYRange(t2, e2) {
          return Io(this, t2, "y", e2);
        }
        getCenterPoint(t2) {
          const { x: e2, y: i2 } = this.getProps(["x", "y"], t2);
          return { x: e2, y: i2 };
        }
        size(t2) {
          let e2 = (t2 = t2 || this.options || {}).radius || 0;
          e2 = Math.max(e2, e2 && t2.hoverRadius || 0);
          return 2 * (e2 + (e2 && t2.borderWidth || 0));
        }
        draw(t2) {
          const e2 = this, i2 = e2.options;
          e2.skip || i2.radius < 0.1 || (t2.strokeStyle = i2.borderColor, t2.lineWidth = i2.borderWidth, t2.fillStyle = i2.backgroundColor, Kt(t2, i2, e2.x, e2.y));
        }
        getRange() {
          const t2 = this.options || {};
          return t2.radius + t2.hitRadius;
        }
      }
      function Fo(t2, e2) {
        const { x: i2, y: n2, base: o2, width: s2, height: a2 } = t2.getProps(["x", "y", "base", "width", "height"], e2);
        let r2, l2, c2, h2, d2;
        return t2.horizontal ? (d2 = a2 / 2, r2 = Math.min(i2, o2), l2 = Math.max(i2, o2), c2 = n2 - d2, h2 = n2 + d2) : (d2 = s2 / 2, r2 = i2 - d2, l2 = i2 + d2, c2 = Math.min(n2, o2), h2 = Math.max(n2, o2)), { left: r2, top: c2, right: l2, bottom: h2 };
      }
      function Vo(t2) {
        let e2 = t2.options.borderSkipped;
        const i2 = {};
        return e2 ? (e2 = t2.horizontal ? Bo(e2, "left", "right", t2.base > t2.x) : Bo(e2, "bottom", "top", t2.base < t2.y), i2[e2] = true, i2) : i2;
      }
      function Bo(t2, e2, i2, n2) {
        var o2, s2, a2;
        return n2 ? (a2 = i2, t2 = Wo(t2 = (o2 = t2) === (s2 = e2) ? a2 : o2 === a2 ? s2 : o2, i2, e2)) : t2 = Wo(t2, e2, i2), t2;
      }
      function Wo(t2, e2, i2) {
        return t2 === "start" ? e2 : t2 === "end" ? i2 : t2;
      }
      function Ho(t2, e2, i2, n2) {
        return t2 ? 0 : Math.max(Math.min(e2, n2), i2);
      }
      function No(t2) {
        const e2 = Fo(t2), i2 = e2.right - e2.left, n2 = e2.bottom - e2.top, o2 = function(t3, e3, i3) {
          const n3 = t3.options.borderWidth, o3 = Vo(t3), s3 = Ee(n3);
          return { t: Ho(o3.top, s3.top, 0, i3), r: Ho(o3.right, s3.right, 0, e3), b: Ho(o3.bottom, s3.bottom, 0, i3), l: Ho(o3.left, s3.left, 0, e3) };
        }(t2, i2 / 2, n2 / 2), s2 = function(t3, e3, i3) {
          const { enableBorderRadius: n3 } = t3.getProps(["enableBorderRadius"]), o3 = t3.options.borderRadius, s3 = Ie(o3), a2 = Math.min(e3, i3), r2 = Vo(t3), l2 = n3 || U(o3);
          return { topLeft: Ho(!l2 || r2.top || r2.left, s3.topLeft, 0, a2), topRight: Ho(!l2 || r2.top || r2.right, s3.topRight, 0, a2), bottomLeft: Ho(!l2 || r2.bottom || r2.left, s3.bottomLeft, 0, a2), bottomRight: Ho(!l2 || r2.bottom || r2.right, s3.bottomRight, 0, a2) };
        }(t2, i2 / 2, n2 / 2);
        return { outer: { x: e2.left, y: e2.top, w: i2, h: n2, radius: s2 }, inner: { x: e2.left + o2.l, y: e2.top + o2.t, w: i2 - o2.l - o2.r, h: n2 - o2.t - o2.b, radius: { topLeft: Math.max(0, s2.topLeft - Math.max(o2.t, o2.l)), topRight: Math.max(0, s2.topRight - Math.max(o2.t, o2.r)), bottomLeft: Math.max(0, s2.bottomLeft - Math.max(o2.b, o2.l)), bottomRight: Math.max(0, s2.bottomRight - Math.max(o2.b, o2.r)) } } };
      }
      function jo(t2, e2, i2, n2) {
        const o2 = e2 === null, s2 = i2 === null, a2 = t2 && !(o2 && s2) && Fo(t2, n2);
        return a2 && (o2 || e2 >= a2.left && e2 <= a2.right) && (s2 || i2 >= a2.top && i2 <= a2.bottom);
      }
      function $o(t2, e2) {
        t2.rect(e2.x, e2.y, e2.w, e2.h);
      }
      zo.id = "point", zo.defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }, zo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };
      class Yo extends Ei {
        constructor(t2) {
          super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, t2 && Object.assign(this, t2);
        }
        draw(t2) {
          const e2 = this.options, { inner: i2, outer: n2 } = No(this), o2 = (s2 = n2.radius).topLeft || s2.topRight || s2.bottomLeft || s2.bottomRight ? ie : $o;
          var s2;
          t2.save(), n2.w === i2.w && n2.h === i2.h || (t2.beginPath(), o2(t2, n2), t2.clip(), o2(t2, i2), t2.fillStyle = e2.borderColor, t2.fill("evenodd")), t2.beginPath(), o2(t2, i2), t2.fillStyle = e2.backgroundColor, t2.fill(), t2.restore();
        }
        inRange(t2, e2, i2) {
          return jo(this, t2, e2, i2);
        }
        inXRange(t2, e2) {
          return jo(this, t2, null, e2);
        }
        inYRange(t2, e2) {
          return jo(this, null, t2, e2);
        }
        getCenterPoint(t2) {
          const { x: e2, y: i2, base: n2, horizontal: o2 } = this.getProps(["x", "y", "base", "horizontal"], t2);
          return { x: o2 ? (e2 + n2) / 2 : e2, y: o2 ? i2 : (i2 + n2) / 2 };
        }
        getRange(t2) {
          return t2 === "x" ? this.width / 2 : this.height / 2;
        }
      }
      Yo.id = "bar", Yo.defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, enableBorderRadius: true, pointStyle: void 0 }, Yo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };
      var Uo = Object.freeze({ __proto__: null, ArcElement: So, LineElement: Eo, PointElement: zo, BarElement: Yo });
      function Xo(t2) {
        if (t2._decimated) {
          const e2 = t2._data;
          delete t2._decimated, delete t2._data, Object.defineProperty(t2, "data", { value: e2 });
        }
      }
      function qo(t2) {
        t2.data.datasets.forEach((t3) => {
          Xo(t3);
        });
      }
      var Ko = { id: "decimation", defaults: { algorithm: "min-max", enabled: false }, beforeElementsUpdate: (t2, e2, i2) => {
        if (!i2.enabled)
          return void qo(t2);
        const n2 = t2.width;
        t2.data.datasets.forEach((e3, o2) => {
          const { _data: s2, indexAxis: a2 } = e3, r2 = t2.getDatasetMeta(o2), l2 = s2 || e3.data;
          if (Ve([a2, t2.options.indexAxis]) === "y")
            return;
          if (r2.type !== "line")
            return;
          const c2 = t2.scales[r2.xAxisID];
          if (c2.type !== "linear" && c2.type !== "time")
            return;
          if (t2.options.parsing)
            return;
          let h2, { start: d2, count: u2 } = function(t3, e4) {
            const i3 = e4.length;
            let n3, o3 = 0;
            const { iScale: s3 } = t3, { min: a3, max: r3, minDefined: l3, maxDefined: c3 } = s3.getUserBounds();
            return l3 && (o3 = Nt(oe(e4, s3.axis, a3).lo, 0, i3 - 1)), n3 = c3 ? Nt(oe(e4, s3.axis, r3).hi + 1, o3, i3) - o3 : i3 - o3, { start: o3, count: n3 };
          }(r2, l2);
          if (u2 <= 4 * n2)
            Xo(e3);
          else {
            switch ($(s2) && (e3._data = l2, delete e3.data, Object.defineProperty(e3, "data", { configurable: true, enumerable: true, get: function() {
              return this._decimated;
            }, set: function(t3) {
              this._data = t3;
            } })), i2.algorithm) {
              case "lttb":
                h2 = function(t3, e4, i3, n3, o3) {
                  const s3 = o3.samples || n3;
                  if (s3 >= i3)
                    return t3.slice(e4, e4 + i3);
                  const a3 = [], r3 = (i3 - 2) / (s3 - 2);
                  let l3 = 0;
                  const c3 = e4 + i3 - 1;
                  let h3, d3, u3, f2, g2, p2 = e4;
                  for (a3[l3++] = t3[p2], h3 = 0; h3 < s3 - 2; h3++) {
                    let n4, o4 = 0, s4 = 0;
                    const c4 = Math.floor((h3 + 1) * r3) + 1 + e4, m2 = Math.min(Math.floor((h3 + 2) * r3) + 1, i3) + e4, x2 = m2 - c4;
                    for (n4 = c4; n4 < m2; n4++)
                      o4 += t3[n4].x, s4 += t3[n4].y;
                    o4 /= x2, s4 /= x2;
                    const b2 = Math.floor(h3 * r3) + 1 + e4, _2 = Math.floor((h3 + 1) * r3) + 1 + e4, { x: y2, y: v2 } = t3[p2];
                    for (u3 = f2 = -1, n4 = b2; n4 < _2; n4++)
                      f2 = 0.5 * Math.abs((y2 - o4) * (t3[n4].y - v2) - (y2 - t3[n4].x) * (s4 - v2)), f2 > u3 && (u3 = f2, d3 = t3[n4], g2 = n4);
                    a3[l3++] = d3, p2 = g2;
                  }
                  return a3[l3++] = t3[c3], a3;
                }(l2, d2, u2, n2, i2);
                break;
              case "min-max":
                h2 = function(t3, e4, i3, n3) {
                  let o3, s3, a3, r3, l3, c3, h3, d3, u3, f2, g2 = 0, p2 = 0;
                  const m2 = [], x2 = e4 + i3 - 1, b2 = t3[e4].x, _2 = t3[x2].x - b2;
                  for (o3 = e4; o3 < e4 + i3; ++o3) {
                    s3 = t3[o3], a3 = (s3.x - b2) / _2 * n3, r3 = s3.y;
                    const e5 = 0 | a3;
                    if (e5 === l3)
                      r3 < u3 ? (u3 = r3, c3 = o3) : r3 > f2 && (f2 = r3, h3 = o3), g2 = (p2 * g2 + s3.x) / ++p2;
                    else {
                      const i4 = o3 - 1;
                      if (!$(c3) && !$(h3)) {
                        const e6 = Math.min(c3, h3), n4 = Math.max(c3, h3);
                        e6 !== d3 && e6 !== i4 && m2.push({ ...t3[e6], x: g2 }), n4 !== d3 && n4 !== i4 && m2.push({ ...t3[n4], x: g2 });
                      }
                      o3 > 0 && i4 !== d3 && m2.push(t3[i4]), m2.push(s3), l3 = e5, p2 = 0, u3 = f2 = r3, c3 = h3 = d3 = o3;
                    }
                  }
                  return m2;
                }(l2, d2, u2, n2);
                break;
              default:
                throw new Error(`Unsupported decimation algorithm '${i2.algorithm}'`);
            }
            e3._decimated = h2;
          }
        });
      }, destroy(t2) {
        qo(t2);
      } };
      function Go(t2, e2, i2) {
        const n2 = function(t3) {
          const e3 = t3.options, i3 = e3.fill;
          let n3 = K(i3 && i3.target, i3);
          return n3 === void 0 && (n3 = !!e3.backgroundColor), n3 !== false && n3 !== null && (n3 === true ? "origin" : n3);
        }(t2);
        if (U(n2))
          return !isNaN(n2.value) && n2;
        let o2 = parseFloat(n2);
        return X(o2) && Math.floor(o2) === o2 ? (n2[0] !== "-" && n2[0] !== "+" || (o2 = e2 + o2), !(o2 === e2 || o2 < 0 || o2 >= i2) && o2) : ["origin", "start", "end", "stack"].indexOf(n2) >= 0 && n2;
      }
      class Zo {
        constructor(t2) {
          this.x = t2.x, this.y = t2.y, this.radius = t2.radius;
        }
        pathSegment(t2, e2, i2) {
          const { x: n2, y: o2, radius: s2 } = this;
          return e2 = e2 || { start: 0, end: _t }, t2.arc(n2, o2, s2, e2.end, e2.start, true), !i2.bounds;
        }
        interpolate(t2) {
          const { x: e2, y: i2, radius: n2 } = this, o2 = t2.angle;
          return { x: e2 + Math.cos(o2) * n2, y: i2 + Math.sin(o2) * n2, angle: o2 };
        }
      }
      function Qo(t2) {
        return (t2.scale || {}).getPointPositionForValue ? function(t3) {
          const { scale: e2, fill: i2 } = t3, n2 = e2.options, o2 = e2.getLabels().length, s2 = [], a2 = n2.reverse ? e2.max : e2.min, r2 = n2.reverse ? e2.min : e2.max;
          let l2, c2, h2;
          if (h2 = i2 === "start" ? a2 : i2 === "end" ? r2 : U(i2) ? i2.value : e2.getBaseValue(), n2.grid.circular)
            return c2 = e2.getPointPositionForValue(0, a2), new Zo({ x: c2.x, y: c2.y, radius: e2.getDistanceFromCenterForValue(h2) });
          for (l2 = 0; l2 < o2; ++l2)
            s2.push(e2.getPointPositionForValue(l2, h2));
          return s2;
        }(t2) : function(t3) {
          const { scale: e2 = {}, fill: i2 } = t3;
          let n2, o2 = null;
          return i2 === "start" ? o2 = e2.bottom : i2 === "end" ? o2 = e2.top : U(i2) ? o2 = e2.getPixelForValue(i2.value) : e2.getBasePixel && (o2 = e2.getBasePixel()), X(o2) ? (n2 = e2.isHorizontal(), { x: n2 ? o2 : null, y: n2 ? null : o2 }) : null;
        }(t2);
      }
      function Jo(t2) {
        const { chart: e2, scale: i2, index: n2, line: o2 } = t2, s2 = [], a2 = o2.segments, r2 = o2.points, l2 = function(t3, e3) {
          const i3 = [], n3 = t3.getSortedVisibleDatasetMetas();
          for (let t4 = 0; t4 < n3.length; t4++) {
            const o3 = n3[t4];
            if (o3.index === e3)
              break;
            ts(o3) && i3.unshift(o3.dataset);
          }
          return i3;
        }(e2, n2);
        l2.push(ns({ x: null, y: i2.bottom }, o2));
        for (let t3 = 0; t3 < a2.length; t3++) {
          const e3 = a2[t3];
          for (let t4 = e3.start; t4 <= e3.end; t4++)
            es(s2, r2[t4], l2);
        }
        return new Eo({ points: s2, options: {} });
      }
      const ts = (t2) => t2.type === "line" && !t2.hidden;
      function es(t2, e2, i2) {
        const n2 = [];
        for (let o2 = 0; o2 < i2.length; o2++) {
          const s2 = i2[o2], { first: a2, last: r2, point: l2 } = is(s2, e2, "x");
          if (!(!l2 || a2 && r2)) {
            if (a2)
              n2.unshift(l2);
            else if (t2.push(l2), !r2)
              break;
          }
        }
        t2.push(...n2);
      }
      function is(t2, e2, i2) {
        const n2 = t2.interpolate(e2, i2);
        if (!n2)
          return {};
        const o2 = n2[i2], s2 = t2.segments, a2 = t2.points;
        let r2 = false, l2 = false;
        for (let t3 = 0; t3 < s2.length; t3++) {
          const e3 = s2[t3], n3 = a2[e3.start][i2], c2 = a2[e3.end][i2];
          if (o2 >= n3 && o2 <= c2) {
            r2 = o2 === n3, l2 = o2 === c2;
            break;
          }
        }
        return { first: r2, last: l2, point: n2 };
      }
      function ns(t2, e2) {
        let i2 = [], n2 = false;
        return Y(t2) ? (n2 = true, i2 = t2) : i2 = function(t3, e3) {
          const { x: i3 = null, y: n3 = null } = t3 || {}, o2 = e3.points, s2 = [];
          return e3.segments.forEach((t4) => {
            const e4 = o2[t4.start], a2 = o2[t4.end];
            n3 !== null ? (s2.push({ x: e4.x, y: n3 }), s2.push({ x: a2.x, y: n3 })) : i3 !== null && (s2.push({ x: i3, y: e4.y }), s2.push({ x: i3, y: a2.y }));
          }), s2;
        }(t2, e2), i2.length ? new Eo({ points: i2, options: { tension: 0 }, _loop: n2, _fullLoop: n2 }) : null;
      }
      function os(t2, e2, i2) {
        let n2 = t2[e2].fill;
        const o2 = [e2];
        let s2;
        if (!i2)
          return n2;
        for (; n2 !== false && o2.indexOf(n2) === -1; ) {
          if (!X(n2))
            return n2;
          if (s2 = t2[n2], !s2)
            return false;
          if (s2.visible)
            return n2;
          o2.push(n2), n2 = s2.fill;
        }
        return false;
      }
      function ss(t2, e2, i2) {
        t2.beginPath(), e2.path(t2), t2.lineTo(e2.last().x, i2), t2.lineTo(e2.first().x, i2), t2.closePath(), t2.clip();
      }
      function as(t2, e2, i2, n2) {
        if (n2)
          return;
        let o2 = e2[t2], s2 = i2[t2];
        return t2 === "angle" && (o2 = Wt(o2), s2 = Wt(s2)), { property: t2, start: o2, end: s2 };
      }
      function rs(t2, e2, i2, n2) {
        return t2 && e2 ? n2(t2[i2], e2[i2]) : t2 ? t2[i2] : e2 ? e2[i2] : 0;
      }
      function ls(t2, e2, i2) {
        const { top: n2, bottom: o2 } = e2.chart.chartArea, { property: s2, start: a2, end: r2 } = i2 || {};
        s2 === "x" && (t2.beginPath(), t2.rect(a2, n2, r2 - a2, o2 - n2), t2.clip());
      }
      function cs(t2, e2, i2, n2) {
        const o2 = e2.interpolate(i2, n2);
        o2 && t2.lineTo(o2.x, o2.y);
      }
      function hs(t2, e2) {
        const { line: i2, target: n2, property: o2, color: s2, scale: a2 } = e2, r2 = function(t3, e3, i3) {
          const n3 = t3.segments, o3 = t3.points, s3 = e3.points, a3 = [];
          for (const t4 of n3) {
            const n4 = as(i3, o3[t4.start], o3[t4.end], t4.loop);
            if (!e3.segments) {
              a3.push({ source: t4, target: n4, start: o3[t4.start], end: o3[t4.end] });
              continue;
            }
            const r3 = kn(e3, n4);
            for (const e4 of r3) {
              const r4 = as(i3, s3[e4.start], s3[e4.end], e4.loop), l2 = Mn(t4, o3, r4);
              for (const t5 of l2)
                a3.push({ source: t5, target: e4, start: { [i3]: rs(n4, r4, "start", Math.max) }, end: { [i3]: rs(n4, r4, "end", Math.min) } });
            }
          }
          return a3;
        }(i2, n2, o2);
        for (const { source: e3, target: l2, start: c2, end: h2 } of r2) {
          const { style: { backgroundColor: r3 = s2 } = {} } = e3;
          t2.save(), t2.fillStyle = r3, ls(t2, a2, as(o2, c2, h2)), t2.beginPath();
          const d2 = !!i2.pathSegment(t2, e3);
          d2 ? t2.closePath() : cs(t2, n2, h2, o2);
          const u2 = !!n2.pathSegment(t2, l2, { move: d2, reverse: true }), f2 = d2 && u2;
          f2 || cs(t2, n2, c2, o2), t2.closePath(), t2.fill(f2 ? "evenodd" : "nonzero"), t2.restore();
        }
      }
      function ds(t2, e2, i2) {
        const n2 = function(t3) {
          const { chart: e3, fill: i3, line: n3 } = t3;
          if (X(i3))
            return function(t4, e4) {
              const i4 = t4.getDatasetMeta(e4);
              return i4 && t4.isDatasetVisible(e4) ? i4.dataset : null;
            }(e3, i3);
          if (i3 === "stack")
            return Jo(t3);
          const o3 = Qo(t3);
          return o3 instanceof Zo ? o3 : ns(o3, n3);
        }(e2), { line: o2, scale: s2, axis: a2 } = e2, r2 = o2.options, l2 = r2.fill, c2 = r2.backgroundColor, { above: h2 = c2, below: d2 = c2 } = l2 || {};
        n2 && o2.points.length && (Zt(t2, i2), function(t3, e3) {
          const { line: i3, target: n3, above: o3, below: s3, area: a3, scale: r3 } = e3, l3 = i3._loop ? "angle" : e3.axis;
          t3.save(), l3 === "x" && s3 !== o3 && (ss(t3, n3, a3.top), hs(t3, { line: i3, target: n3, color: o3, scale: r3, property: l3 }), t3.restore(), t3.save(), ss(t3, n3, a3.bottom)), hs(t3, { line: i3, target: n3, color: s3, scale: r3, property: l3 }), t3.restore();
        }(t2, { line: o2, target: n2, above: h2, below: d2, area: i2, scale: s2, axis: a2 }), Qt(t2));
      }
      var us = { id: "filler", afterDatasetsUpdate(t2, e2, i2) {
        const n2 = (t2.data.datasets || []).length, o2 = [];
        let s2, a2, r2, l2;
        for (a2 = 0; a2 < n2; ++a2)
          s2 = t2.getDatasetMeta(a2), r2 = s2.dataset, l2 = null, r2 && r2.options && r2 instanceof Eo && (l2 = { visible: t2.isDatasetVisible(a2), index: a2, fill: Go(r2, a2, n2), chart: t2, axis: s2.controller.options.indexAxis, scale: s2.vScale, line: r2 }), s2.$filler = l2, o2.push(l2);
        for (a2 = 0; a2 < n2; ++a2)
          l2 = o2[a2], l2 && l2.fill !== false && (l2.fill = os(o2, a2, i2.propagate));
      }, beforeDraw(t2, e2, i2) {
        const n2 = i2.drawTime === "beforeDraw", o2 = t2.getSortedVisibleDatasetMetas(), s2 = t2.chartArea;
        for (let e3 = o2.length - 1; e3 >= 0; --e3) {
          const i3 = o2[e3].$filler;
          i3 && (i3.line.updateControlPoints(s2, i3.axis), n2 && ds(t2.ctx, i3, s2));
        }
      }, beforeDatasetsDraw(t2, e2, i2) {
        if (i2.drawTime !== "beforeDatasetsDraw")
          return;
        const n2 = t2.getSortedVisibleDatasetMetas();
        for (let e3 = n2.length - 1; e3 >= 0; --e3) {
          const i3 = n2[e3].$filler;
          i3 && ds(t2.ctx, i3, t2.chartArea);
        }
      }, beforeDatasetDraw(t2, e2, i2) {
        const n2 = e2.meta.$filler;
        n2 && n2.fill !== false && i2.drawTime === "beforeDatasetDraw" && ds(t2.ctx, n2, t2.chartArea);
      }, defaults: { propagate: true, drawTime: "beforeDatasetDraw" } };
      const fs = (t2, e2) => {
        let { boxHeight: i2 = e2, boxWidth: n2 = e2 } = t2;
        return t2.usePointStyle && (i2 = Math.min(i2, e2), n2 = Math.min(n2, e2)), { boxWidth: n2, boxHeight: i2, itemHeight: Math.max(e2, i2) };
      };
      class gs extends Ei {
        constructor(t2) {
          super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = t2.chart, this.options = t2.options, this.ctx = t2.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
        }
        update(t2, e2, i2) {
          const n2 = this;
          n2.maxWidth = t2, n2.maxHeight = e2, n2._margins = i2, n2.setDimensions(), n2.buildLabels(), n2.fit();
        }
        setDimensions() {
          const t2 = this;
          t2.isHorizontal() ? (t2.width = t2.maxWidth, t2.left = 0, t2.right = t2.width) : (t2.height = t2.maxHeight, t2.top = 0, t2.bottom = t2.height);
        }
        buildLabels() {
          const t2 = this, e2 = t2.options.labels || {};
          let i2 = Q(e2.generateLabels, [t2.chart], t2) || [];
          e2.filter && (i2 = i2.filter((i3) => e2.filter(i3, t2.chart.data))), e2.sort && (i2 = i2.sort((i3, n2) => e2.sort(i3, n2, t2.chart.data))), t2.options.reverse && i2.reverse(), t2.legendItems = i2;
        }
        fit() {
          const t2 = this, { options: e2, ctx: i2 } = t2;
          if (!e2.display)
            return void (t2.width = t2.height = 0);
          const n2 = e2.labels, o2 = Fe(n2.font), s2 = o2.size, a2 = t2._computeTitleHeight(), { boxWidth: r2, itemHeight: l2 } = fs(n2, s2);
          let c2, h2;
          i2.font = o2.string, t2.isHorizontal() ? (c2 = t2.maxWidth, h2 = t2._fitRows(a2, s2, r2, l2) + 10) : (h2 = t2.maxHeight, c2 = t2._fitCols(a2, s2, r2, l2) + 10), t2.width = Math.min(c2, e2.maxWidth || t2.maxWidth), t2.height = Math.min(h2, e2.maxHeight || t2.maxHeight);
        }
        _fitRows(t2, e2, i2, n2) {
          const o2 = this, { ctx: s2, maxWidth: a2, options: { labels: { padding: r2 } } } = o2, l2 = o2.legendHitBoxes = [], c2 = o2.lineWidths = [0], h2 = n2 + r2;
          let d2 = t2;
          s2.textAlign = "left", s2.textBaseline = "middle";
          let u2 = -1, f2 = -h2;
          return o2.legendItems.forEach((t3, o3) => {
            const g2 = i2 + e2 / 2 + s2.measureText(t3.text).width;
            (o3 === 0 || c2[c2.length - 1] + g2 + 2 * r2 > a2) && (d2 += h2, c2[c2.length - (o3 > 0 ? 0 : 1)] = 0, f2 += h2, u2++), l2[o3] = { left: 0, top: f2, row: u2, width: g2, height: n2 }, c2[c2.length - 1] += g2 + r2;
          }), d2;
        }
        _fitCols(t2, e2, i2, n2) {
          const o2 = this, { ctx: s2, maxHeight: a2, options: { labels: { padding: r2 } } } = o2, l2 = o2.legendHitBoxes = [], c2 = o2.columnSizes = [], h2 = a2 - t2;
          let d2 = r2, u2 = 0, f2 = 0, g2 = 0, p2 = 0, m2 = 0;
          return o2.legendItems.forEach((t3, o3) => {
            const a3 = i2 + e2 / 2 + s2.measureText(t3.text).width;
            o3 > 0 && f2 + e2 + 2 * r2 > h2 && (d2 += u2 + r2, c2.push({ width: u2, height: f2 }), g2 += u2 + r2, m2++, p2 = 0, u2 = f2 = 0), u2 = Math.max(u2, a3), f2 += e2 + r2, l2[o3] = { left: g2, top: p2, col: m2, width: a3, height: n2 }, p2 += n2 + r2;
          }), d2 += u2, c2.push({ width: u2, height: f2 }), d2;
        }
        adjustHitBoxes() {
          const t2 = this;
          if (!t2.options.display)
            return;
          const e2 = t2._computeTitleHeight(), { legendHitBoxes: i2, options: { align: n2, labels: { padding: s2 } } } = t2;
          if (this.isHorizontal()) {
            let a2 = 0, r2 = o(n2, t2.left + s2, t2.right - t2.lineWidths[a2]);
            for (const l2 of i2)
              a2 !== l2.row && (a2 = l2.row, r2 = o(n2, t2.left + s2, t2.right - t2.lineWidths[a2])), l2.top += t2.top + e2 + s2, l2.left = r2, r2 += l2.width + s2;
          } else {
            let a2 = 0, r2 = o(n2, t2.top + e2 + s2, t2.bottom - t2.columnSizes[a2].height);
            for (const l2 of i2)
              l2.col !== a2 && (a2 = l2.col, r2 = o(n2, t2.top + e2 + s2, t2.bottom - t2.columnSizes[a2].height)), l2.top = r2, l2.left += t2.left + s2, r2 += l2.height + s2;
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          const t2 = this;
          if (t2.options.display) {
            const e2 = t2.ctx;
            Zt(e2, t2), t2._draw(), Qt(e2);
          }
        }
        _draw() {
          const t2 = this, { options: e2, columnSizes: i2, lineWidths: n2, ctx: a2 } = t2, { align: r2, labels: l2 } = e2, c2 = xt.color, h2 = bn(e2.rtl, t2.left, t2.width), d2 = Fe(l2.font), { color: u2, padding: f2 } = l2, g2 = d2.size, p2 = g2 / 2;
          let m2;
          t2.drawTitle(), a2.textAlign = h2.textAlign("left"), a2.textBaseline = "middle", a2.lineWidth = 0.5, a2.font = d2.string;
          const { boxWidth: x2, boxHeight: b2, itemHeight: _2 } = fs(l2, g2), y2 = t2.isHorizontal(), v2 = this._computeTitleHeight();
          m2 = y2 ? { x: o(r2, t2.left + f2, t2.right - n2[0]), y: t2.top + f2 + v2, line: 0 } : { x: t2.left + f2, y: o(r2, t2.top + v2 + f2, t2.bottom - i2[0].height), line: 0 }, _n(t2.ctx, e2.textDirection);
          const w2 = _2 + f2;
          t2.legendItems.forEach((e3, M2) => {
            a2.strokeStyle = e3.fontColor || u2, a2.fillStyle = e3.fontColor || u2;
            const k2 = a2.measureText(e3.text).width, S2 = h2.textAlign(e3.textAlign || (e3.textAlign = l2.textAlign)), P2 = x2 + g2 / 2 + k2;
            let D2 = m2.x, C2 = m2.y;
            h2.setWidth(t2.width), y2 ? M2 > 0 && D2 + P2 + f2 > t2.right && (C2 = m2.y += w2, m2.line++, D2 = m2.x = o(r2, t2.left + f2, t2.right - n2[m2.line])) : M2 > 0 && C2 + w2 > t2.bottom && (D2 = m2.x = D2 + i2[m2.line].width + f2, m2.line++, C2 = m2.y = o(r2, t2.top + v2 + f2, t2.bottom - i2[m2.line].height));
            !function(t3, e4, i3) {
              if (isNaN(x2) || x2 <= 0 || isNaN(b2) || b2 < 0)
                return;
              a2.save();
              const n3 = K(i3.lineWidth, 1);
              if (a2.fillStyle = K(i3.fillStyle, c2), a2.lineCap = K(i3.lineCap, "butt"), a2.lineDashOffset = K(i3.lineDashOffset, 0), a2.lineJoin = K(i3.lineJoin, "miter"), a2.lineWidth = n3, a2.strokeStyle = K(i3.strokeStyle, c2), a2.setLineDash(K(i3.lineDash, [])), l2.usePointStyle) {
                const o2 = { radius: x2 * Math.SQRT2 / 2, pointStyle: i3.pointStyle, rotation: i3.rotation, borderWidth: n3 }, s2 = h2.xPlus(t3, x2 / 2);
                Kt(a2, o2, s2, e4 + p2);
              } else {
                const o2 = e4 + Math.max((g2 - b2) / 2, 0), s2 = h2.leftForLtr(t3, x2), r3 = Ie(i3.borderRadius);
                a2.beginPath(), Object.values(r3).some((t4) => t4 !== 0) ? ie(a2, { x: s2, y: o2, w: x2, h: b2, radius: r3 }) : a2.rect(s2, o2, x2, b2), a2.fill(), n3 !== 0 && a2.stroke();
              }
              a2.restore();
            }(h2.x(D2), C2, e3), D2 = s(S2, D2 + x2 + p2, t2.right), function(t3, e4, i3) {
              ee(a2, i3.text, t3, e4 + _2 / 2, d2, { strikethrough: i3.hidden, textAlign: i3.textAlign });
            }(h2.x(D2), C2, e3), y2 ? m2.x += P2 + f2 : m2.y += w2;
          }), yn(t2.ctx, e2.textDirection);
        }
        drawTitle() {
          const t2 = this, e2 = t2.options, i2 = e2.title, s2 = Fe(i2.font), a2 = ze(i2.padding);
          if (!i2.display)
            return;
          const r2 = bn(e2.rtl, t2.left, t2.width), l2 = t2.ctx, c2 = i2.position, h2 = s2.size / 2, d2 = a2.top + h2;
          let u2, f2 = t2.left, g2 = t2.width;
          if (this.isHorizontal())
            g2 = Math.max(...t2.lineWidths), u2 = t2.top + d2, f2 = o(e2.align, f2, t2.right - g2);
          else {
            const i3 = t2.columnSizes.reduce((t3, e3) => Math.max(t3, e3.height), 0);
            u2 = d2 + o(e2.align, t2.top, t2.bottom - i3 - e2.labels.padding - t2._computeTitleHeight());
          }
          const p2 = o(c2, f2, f2 + g2);
          l2.textAlign = r2.textAlign(n(c2)), l2.textBaseline = "middle", l2.strokeStyle = i2.color, l2.fillStyle = i2.color, l2.font = s2.string, ee(l2, i2.text, p2, u2, s2);
        }
        _computeTitleHeight() {
          const t2 = this.options.title, e2 = Fe(t2.font), i2 = ze(t2.padding);
          return t2.display ? e2.lineHeight + i2.height : 0;
        }
        _getLegendItemAt(t2, e2) {
          const i2 = this;
          let n2, o2, s2;
          if (t2 >= i2.left && t2 <= i2.right && e2 >= i2.top && e2 <= i2.bottom) {
            for (s2 = i2.legendHitBoxes, n2 = 0; n2 < s2.length; ++n2)
              if (o2 = s2[n2], t2 >= o2.left && t2 <= o2.left + o2.width && e2 >= o2.top && e2 <= o2.top + o2.height)
                return i2.legendItems[n2];
          }
          return null;
        }
        handleEvent(t2) {
          const e2 = this, i2 = e2.options;
          if (!function(t3, e3) {
            if (t3 === "mousemove" && (e3.onHover || e3.onLeave))
              return true;
            if (e3.onClick && (t3 === "click" || t3 === "mouseup"))
              return true;
            return false;
          }(t2.type, i2))
            return;
          const n2 = e2._getLegendItemAt(t2.x, t2.y);
          if (t2.type === "mousemove") {
            const a2 = e2._hoveredItem, r2 = (s2 = n2, (o2 = a2) !== null && s2 !== null && o2.datasetIndex === s2.datasetIndex && o2.index === s2.index);
            a2 && !r2 && Q(i2.onLeave, [t2, a2, e2], e2), e2._hoveredItem = n2, n2 && !r2 && Q(i2.onHover, [t2, n2, e2], e2);
          } else
            n2 && Q(i2.onClick, [t2, n2, e2], e2);
          var o2, s2;
        }
      }
      var ps = { id: "legend", _element: gs, start(t2, e2, i2) {
        const n2 = t2.legend = new gs({ ctx: t2.ctx, options: i2, chart: t2 });
        Ge.configure(t2, n2, i2), Ge.addBox(t2, n2);
      }, stop(t2) {
        Ge.removeBox(t2, t2.legend), delete t2.legend;
      }, beforeUpdate(t2, e2, i2) {
        const n2 = t2.legend;
        Ge.configure(t2, n2, i2), n2.options = i2;
      }, afterUpdate(t2) {
        const e2 = t2.legend;
        e2.buildLabels(), e2.adjustHitBoxes();
      }, afterEvent(t2, e2) {
        e2.replay || t2.legend.handleEvent(e2.event);
      }, defaults: { display: true, position: "top", align: "center", fullSize: true, reverse: false, weight: 1e3, onClick(t2, e2, i2) {
        const n2 = e2.datasetIndex, o2 = i2.chart;
        o2.isDatasetVisible(n2) ? (o2.hide(n2), e2.hidden = true) : (o2.show(n2), e2.hidden = false);
      }, onHover: null, onLeave: null, labels: { color: (t2) => t2.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t2) {
        const e2 = t2.data.datasets, { labels: { usePointStyle: i2, pointStyle: n2, textAlign: o2, color: s2 } } = t2.legend.options;
        return t2._getSortedDatasetMetas().map((t3) => {
          const a2 = t3.controller.getStyle(i2 ? 0 : void 0), r2 = ze(a2.borderWidth);
          return { text: e2[t3.index].label, fillStyle: a2.backgroundColor, fontColor: s2, hidden: !t3.visible, lineCap: a2.borderCapStyle, lineDash: a2.borderDash, lineDashOffset: a2.borderDashOffset, lineJoin: a2.borderJoinStyle, lineWidth: (r2.width + r2.height) / 4, strokeStyle: a2.borderColor, pointStyle: n2 || a2.pointStyle, rotation: a2.rotation, textAlign: o2 || a2.textAlign, borderRadius: 0, datasetIndex: t3.index };
        }, this);
      } }, title: { color: (t2) => t2.chart.options.color, display: false, position: "center", text: "" } }, descriptors: { _scriptable: (t2) => !t2.startsWith("on"), labels: { _scriptable: (t2) => !["generateLabels", "filter", "sort"].includes(t2) } } };
      class ms extends Ei {
        constructor(t2) {
          super(), this.chart = t2.chart, this.options = t2.options, this.ctx = t2.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
        }
        update(t2, e2) {
          const i2 = this, n2 = i2.options;
          if (i2.left = 0, i2.top = 0, !n2.display)
            return void (i2.width = i2.height = i2.right = i2.bottom = 0);
          i2.width = i2.right = t2, i2.height = i2.bottom = e2;
          const o2 = Y(n2.text) ? n2.text.length : 1;
          i2._padding = ze(n2.padding);
          const s2 = o2 * Fe(n2.font).lineHeight + i2._padding.height;
          i2.isHorizontal() ? i2.height = s2 : i2.width = s2;
        }
        isHorizontal() {
          const t2 = this.options.position;
          return t2 === "top" || t2 === "bottom";
        }
        _drawArgs(t2) {
          const { top: e2, left: i2, bottom: n2, right: s2, options: a2 } = this, r2 = a2.align;
          let l2, c2, h2, d2 = 0;
          return this.isHorizontal() ? (c2 = o(r2, i2, s2), h2 = e2 + t2, l2 = s2 - i2) : (a2.position === "left" ? (c2 = i2 + t2, h2 = o(r2, n2, e2), d2 = -0.5 * bt) : (c2 = s2 - t2, h2 = o(r2, e2, n2), d2 = 0.5 * bt), l2 = n2 - e2), { titleX: c2, titleY: h2, maxWidth: l2, rotation: d2 };
        }
        draw() {
          const t2 = this, e2 = t2.ctx, i2 = t2.options;
          if (!i2.display)
            return;
          const o2 = Fe(i2.font), s2 = o2.lineHeight / 2 + t2._padding.top, { titleX: a2, titleY: r2, maxWidth: l2, rotation: c2 } = t2._drawArgs(s2);
          ee(e2, i2.text, 0, 0, o2, { color: i2.color, maxWidth: l2, rotation: c2, textAlign: n(i2.align), textBaseline: "middle", translation: [a2, r2] });
        }
      }
      var xs = { id: "title", _element: ms, start(t2, e2, i2) {
        !function(t3, e3) {
          const i3 = new ms({ ctx: t3.ctx, options: e3, chart: t3 });
          Ge.configure(t3, i3, e3), Ge.addBox(t3, i3), t3.titleBlock = i3;
        }(t2, i2);
      }, stop(t2) {
        const e2 = t2.titleBlock;
        Ge.removeBox(t2, e2), delete t2.titleBlock;
      }, beforeUpdate(t2, e2, i2) {
        const n2 = t2.titleBlock;
        Ge.configure(t2, n2, i2), n2.options = i2;
      }, defaults: { align: "center", display: false, font: { weight: "bold" }, fullSize: true, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: true, _indexable: false } };
      const bs = { average(t2) {
        if (!t2.length)
          return false;
        let e2, i2, n2 = 0, o2 = 0, s2 = 0;
        for (e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
          const i3 = t2[e2].element;
          if (i3 && i3.hasValue()) {
            const t3 = i3.tooltipPosition();
            n2 += t3.x, o2 += t3.y, ++s2;
          }
        }
        return { x: n2 / s2, y: o2 / s2 };
      }, nearest(t2, e2) {
        if (!t2.length)
          return false;
        let i2, n2, o2, s2 = e2.x, a2 = e2.y, r2 = Number.POSITIVE_INFINITY;
        for (i2 = 0, n2 = t2.length; i2 < n2; ++i2) {
          const n3 = t2[i2].element;
          if (n3 && n3.hasValue()) {
            const t3 = Vt(e2, n3.getCenterPoint());
            t3 < r2 && (r2 = t3, o2 = n3);
          }
        }
        if (o2) {
          const t3 = o2.tooltipPosition();
          s2 = t3.x, a2 = t3.y;
        }
        return { x: s2, y: a2 };
      } };
      function _s(t2, e2) {
        return e2 && (Y(e2) ? Array.prototype.push.apply(t2, e2) : t2.push(e2)), t2;
      }
      function ys(t2) {
        return (typeof t2 == "string" || t2 instanceof String) && t2.indexOf("\n") > -1 ? t2.split("\n") : t2;
      }
      function vs(t2, e2) {
        const { element: i2, datasetIndex: n2, index: o2 } = e2, s2 = t2.getDatasetMeta(n2).controller, { label: a2, value: r2 } = s2.getLabelAndValue(o2);
        return { chart: t2, label: a2, parsed: s2.getParsed(o2), raw: t2.data.datasets[n2].data[o2], formattedValue: r2, dataset: s2.getDataset(), dataIndex: o2, datasetIndex: n2, element: i2 };
      }
      function ws(t2, e2) {
        const i2 = t2._chart.ctx, { body: n2, footer: o2, title: s2 } = t2, { boxWidth: a2, boxHeight: r2 } = e2, l2 = Fe(e2.bodyFont), c2 = Fe(e2.titleFont), h2 = Fe(e2.footerFont), d2 = s2.length, u2 = o2.length, f2 = n2.length, g2 = ze(e2.padding);
        let p2 = g2.height, m2 = 0, x2 = n2.reduce((t3, e3) => t3 + e3.before.length + e3.lines.length + e3.after.length, 0);
        if (x2 += t2.beforeBody.length + t2.afterBody.length, d2 && (p2 += d2 * c2.lineHeight + (d2 - 1) * e2.titleSpacing + e2.titleMarginBottom), x2) {
          p2 += f2 * (e2.displayColors ? Math.max(r2, l2.lineHeight) : l2.lineHeight) + (x2 - f2) * l2.lineHeight + (x2 - 1) * e2.bodySpacing;
        }
        u2 && (p2 += e2.footerMarginTop + u2 * h2.lineHeight + (u2 - 1) * e2.footerSpacing);
        let b2 = 0;
        const _2 = function(t3) {
          m2 = Math.max(m2, i2.measureText(t3).width + b2);
        };
        return i2.save(), i2.font = c2.string, J(t2.title, _2), i2.font = l2.string, J(t2.beforeBody.concat(t2.afterBody), _2), b2 = e2.displayColors ? a2 + 2 : 0, J(n2, (t3) => {
          J(t3.before, _2), J(t3.lines, _2), J(t3.after, _2);
        }), b2 = 0, i2.font = h2.string, J(t2.footer, _2), i2.restore(), m2 += g2.width, { width: m2, height: p2 };
      }
      function Ms(t2, e2, i2, n2) {
        const { x: o2, width: s2 } = i2, { width: a2, chartArea: { left: r2, right: l2 } } = t2;
        let c2 = "center";
        return n2 === "center" ? c2 = o2 <= (r2 + l2) / 2 ? "left" : "right" : o2 <= s2 / 2 ? c2 = "left" : o2 >= a2 - s2 / 2 && (c2 = "right"), function(t3, e3, i3, n3) {
          const { x: o3, width: s3 } = n3, a3 = i3.caretSize + i3.caretPadding;
          return t3 === "left" && o3 + s3 + a3 > e3.width || t3 === "right" && o3 - s3 - a3 < 0 || void 0;
        }(c2, t2, e2, i2) && (c2 = "center"), c2;
      }
      function ks(t2, e2, i2) {
        const n2 = e2.yAlign || function(t3, e3) {
          const { y: i3, height: n3 } = e3;
          return i3 < n3 / 2 ? "top" : i3 > t3.height - n3 / 2 ? "bottom" : "center";
        }(t2, i2);
        return { xAlign: e2.xAlign || Ms(t2, e2, i2, n2), yAlign: n2 };
      }
      function Ss(t2, e2, i2, n2) {
        const { caretSize: o2, caretPadding: s2, cornerRadius: a2 } = t2, { xAlign: r2, yAlign: l2 } = i2, c2 = o2 + s2, h2 = a2 + s2;
        let d2 = function(t3, e3) {
          let { x: i3, width: n3 } = t3;
          return e3 === "right" ? i3 -= n3 : e3 === "center" && (i3 -= n3 / 2), i3;
        }(e2, r2);
        const u2 = function(t3, e3, i3) {
          let { y: n3, height: o3 } = t3;
          return e3 === "top" ? n3 += i3 : n3 -= e3 === "bottom" ? o3 + i3 : o3 / 2, n3;
        }(e2, l2, c2);
        return l2 === "center" ? r2 === "left" ? d2 += c2 : r2 === "right" && (d2 -= c2) : r2 === "left" ? d2 -= h2 : r2 === "right" && (d2 += h2), { x: Nt(d2, 0, n2.width - e2.width), y: Nt(u2, 0, n2.height - e2.height) };
      }
      function Ps(t2, e2, i2) {
        const n2 = ze(i2.padding);
        return e2 === "center" ? t2.x + t2.width / 2 : e2 === "right" ? t2.x + t2.width - n2.right : t2.x + n2.left;
      }
      function Ds(t2) {
        return _s([], ys(t2));
      }
      function Cs(t2, e2) {
        const i2 = e2 && e2.dataset && e2.dataset.tooltip && e2.dataset.tooltip.callbacks;
        return i2 ? t2.override(i2) : t2;
      }
      class Os extends Ei {
        constructor(t2) {
          super(), this.opacity = 0, this._active = [], this._chart = t2._chart, this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.options = t2.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
        }
        initialize(t2) {
          this.options = t2, this._cachedAnimations = void 0, this.$context = void 0;
        }
        _resolveAnimations() {
          const t2 = this, e2 = t2._cachedAnimations;
          if (e2)
            return e2;
          const i2 = t2._chart, n2 = t2.options.setContext(t2.getContext()), o2 = n2.enabled && i2.options.animation && n2.animations, s2 = new vi(t2._chart, o2);
          return o2._cacheable && (t2._cachedAnimations = Object.freeze(s2)), s2;
        }
        getContext() {
          const t2 = this;
          return t2.$context || (t2.$context = (e2 = t2._chart.getContext(), i2 = t2, n2 = t2._tooltipItems, Object.assign(Object.create(e2), { tooltip: i2, tooltipItems: n2, type: "tooltip" })));
          var e2, i2, n2;
        }
        getTitle(t2, e2) {
          const i2 = this, { callbacks: n2 } = e2, o2 = n2.beforeTitle.apply(i2, [t2]), s2 = n2.title.apply(i2, [t2]), a2 = n2.afterTitle.apply(i2, [t2]);
          let r2 = [];
          return r2 = _s(r2, ys(o2)), r2 = _s(r2, ys(s2)), r2 = _s(r2, ys(a2)), r2;
        }
        getBeforeBody(t2, e2) {
          return Ds(e2.callbacks.beforeBody.apply(this, [t2]));
        }
        getBody(t2, e2) {
          const i2 = this, { callbacks: n2 } = e2, o2 = [];
          return J(t2, (t3) => {
            const e3 = { before: [], lines: [], after: [] }, s2 = Cs(n2, t3);
            _s(e3.before, ys(s2.beforeLabel.call(i2, t3))), _s(e3.lines, s2.label.call(i2, t3)), _s(e3.after, ys(s2.afterLabel.call(i2, t3))), o2.push(e3);
          }), o2;
        }
        getAfterBody(t2, e2) {
          return Ds(e2.callbacks.afterBody.apply(this, [t2]));
        }
        getFooter(t2, e2) {
          const i2 = this, { callbacks: n2 } = e2, o2 = n2.beforeFooter.apply(i2, [t2]), s2 = n2.footer.apply(i2, [t2]), a2 = n2.afterFooter.apply(i2, [t2]);
          let r2 = [];
          return r2 = _s(r2, ys(o2)), r2 = _s(r2, ys(s2)), r2 = _s(r2, ys(a2)), r2;
        }
        _createItems(t2) {
          const e2 = this, i2 = e2._active, n2 = e2._chart.data, o2 = [], s2 = [], a2 = [];
          let r2, l2, c2 = [];
          for (r2 = 0, l2 = i2.length; r2 < l2; ++r2)
            c2.push(vs(e2._chart, i2[r2]));
          return t2.filter && (c2 = c2.filter((e3, i3, o3) => t2.filter(e3, i3, o3, n2))), t2.itemSort && (c2 = c2.sort((e3, i3) => t2.itemSort(e3, i3, n2))), J(c2, (i3) => {
            const n3 = Cs(t2.callbacks, i3);
            o2.push(n3.labelColor.call(e2, i3)), s2.push(n3.labelPointStyle.call(e2, i3)), a2.push(n3.labelTextColor.call(e2, i3));
          }), e2.labelColors = o2, e2.labelPointStyles = s2, e2.labelTextColors = a2, e2.dataPoints = c2, c2;
        }
        update(t2, e2) {
          const i2 = this, n2 = i2.options.setContext(i2.getContext()), o2 = i2._active;
          let s2, a2 = [];
          if (o2.length) {
            const t3 = bs[n2.position].call(i2, o2, i2._eventPosition);
            a2 = i2._createItems(n2), i2.title = i2.getTitle(a2, n2), i2.beforeBody = i2.getBeforeBody(a2, n2), i2.body = i2.getBody(a2, n2), i2.afterBody = i2.getAfterBody(a2, n2), i2.footer = i2.getFooter(a2, n2);
            const e3 = i2._size = ws(i2, n2), r2 = Object.assign({}, t3, e3), l2 = ks(i2._chart, n2, r2), c2 = Ss(n2, r2, l2, i2._chart);
            i2.xAlign = l2.xAlign, i2.yAlign = l2.yAlign, s2 = { opacity: 1, x: c2.x, y: c2.y, width: e3.width, height: e3.height, caretX: t3.x, caretY: t3.y };
          } else
            i2.opacity !== 0 && (s2 = { opacity: 0 });
          i2._tooltipItems = a2, i2.$context = void 0, s2 && i2._resolveAnimations().update(i2, s2), t2 && n2.external && n2.external.call(i2, { chart: i2._chart, tooltip: i2, replay: e2 });
        }
        drawCaret(t2, e2, i2, n2) {
          const o2 = this.getCaretPosition(t2, i2, n2);
          e2.lineTo(o2.x1, o2.y1), e2.lineTo(o2.x2, o2.y2), e2.lineTo(o2.x3, o2.y3);
        }
        getCaretPosition(t2, e2, i2) {
          const { xAlign: n2, yAlign: o2 } = this, { cornerRadius: s2, caretSize: a2 } = i2, { x: r2, y: l2 } = t2, { width: c2, height: h2 } = e2;
          let d2, u2, f2, g2, p2, m2;
          return o2 === "center" ? (p2 = l2 + h2 / 2, n2 === "left" ? (d2 = r2, u2 = d2 - a2, g2 = p2 + a2, m2 = p2 - a2) : (d2 = r2 + c2, u2 = d2 + a2, g2 = p2 - a2, m2 = p2 + a2), f2 = d2) : (u2 = n2 === "left" ? r2 + s2 + a2 : n2 === "right" ? r2 + c2 - s2 - a2 : this.caretX, o2 === "top" ? (g2 = l2, p2 = g2 - a2, d2 = u2 - a2, f2 = u2 + a2) : (g2 = l2 + h2, p2 = g2 + a2, d2 = u2 + a2, f2 = u2 - a2), m2 = g2), { x1: d2, x2: u2, x3: f2, y1: g2, y2: p2, y3: m2 };
        }
        drawTitle(t2, e2, i2) {
          const n2 = this, o2 = n2.title, s2 = o2.length;
          let a2, r2, l2;
          if (s2) {
            const c2 = bn(i2.rtl, n2.x, n2.width);
            for (t2.x = Ps(n2, i2.titleAlign, i2), e2.textAlign = c2.textAlign(i2.titleAlign), e2.textBaseline = "middle", a2 = Fe(i2.titleFont), r2 = i2.titleSpacing, e2.fillStyle = i2.titleColor, e2.font = a2.string, l2 = 0; l2 < s2; ++l2)
              e2.fillText(o2[l2], c2.x(t2.x), t2.y + a2.lineHeight / 2), t2.y += a2.lineHeight + r2, l2 + 1 === s2 && (t2.y += i2.titleMarginBottom - r2);
          }
        }
        _drawColorBox(t2, e2, i2, n2, o2) {
          const s2 = this, a2 = s2.labelColors[i2], r2 = s2.labelPointStyles[i2], { boxHeight: l2, boxWidth: c2 } = o2, h2 = Fe(o2.bodyFont), d2 = Ps(s2, "left", o2), u2 = n2.x(d2), f2 = l2 < h2.lineHeight ? (h2.lineHeight - l2) / 2 : 0, g2 = e2.y + f2;
          if (o2.usePointStyle) {
            const e3 = { radius: Math.min(c2, l2) / 2, pointStyle: r2.pointStyle, rotation: r2.rotation, borderWidth: 1 }, i3 = n2.leftForLtr(u2, c2) + c2 / 2, s3 = g2 + l2 / 2;
            t2.strokeStyle = o2.multiKeyBackground, t2.fillStyle = o2.multiKeyBackground, Kt(t2, e3, i3, s3), t2.strokeStyle = a2.borderColor, t2.fillStyle = a2.backgroundColor, Kt(t2, e3, i3, s3);
          } else {
            t2.lineWidth = a2.borderWidth || 1, t2.strokeStyle = a2.borderColor, t2.setLineDash(a2.borderDash || []), t2.lineDashOffset = a2.borderDashOffset || 0;
            const e3 = n2.leftForLtr(u2, c2), i3 = n2.leftForLtr(n2.xPlus(u2, 1), c2 - 2), s3 = Ie(a2.borderRadius);
            Object.values(s3).some((t3) => t3 !== 0) ? (t2.beginPath(), t2.fillStyle = o2.multiKeyBackground, ie(t2, { x: e3, y: g2, w: c2, h: l2, radius: s3 }), t2.fill(), t2.stroke(), t2.fillStyle = a2.backgroundColor, t2.beginPath(), ie(t2, { x: i3, y: g2 + 1, w: c2 - 2, h: l2 - 2, radius: s3 }), t2.fill()) : (t2.fillStyle = o2.multiKeyBackground, t2.fillRect(e3, g2, c2, l2), t2.strokeRect(e3, g2, c2, l2), t2.fillStyle = a2.backgroundColor, t2.fillRect(i3, g2 + 1, c2 - 2, l2 - 2));
          }
          t2.fillStyle = s2.labelTextColors[i2];
        }
        drawBody(t2, e2, i2) {
          const n2 = this, { body: o2 } = n2, { bodySpacing: s2, bodyAlign: a2, displayColors: r2, boxHeight: l2, boxWidth: c2 } = i2, h2 = Fe(i2.bodyFont);
          let d2 = h2.lineHeight, u2 = 0;
          const f2 = bn(i2.rtl, n2.x, n2.width), g2 = function(i3) {
            e2.fillText(i3, f2.x(t2.x + u2), t2.y + d2 / 2), t2.y += d2 + s2;
          }, p2 = f2.textAlign(a2);
          let m2, x2, b2, _2, y2, v2, w2;
          for (e2.textAlign = a2, e2.textBaseline = "middle", e2.font = h2.string, t2.x = Ps(n2, p2, i2), e2.fillStyle = i2.bodyColor, J(n2.beforeBody, g2), u2 = r2 && p2 !== "right" ? a2 === "center" ? c2 / 2 + 1 : c2 + 2 : 0, _2 = 0, v2 = o2.length; _2 < v2; ++_2) {
            for (m2 = o2[_2], x2 = n2.labelTextColors[_2], e2.fillStyle = x2, J(m2.before, g2), b2 = m2.lines, r2 && b2.length && (n2._drawColorBox(e2, t2, _2, f2, i2), d2 = Math.max(h2.lineHeight, l2)), y2 = 0, w2 = b2.length; y2 < w2; ++y2)
              g2(b2[y2]), d2 = h2.lineHeight;
            J(m2.after, g2);
          }
          u2 = 0, d2 = h2.lineHeight, J(n2.afterBody, g2), t2.y -= s2;
        }
        drawFooter(t2, e2, i2) {
          const n2 = this, o2 = n2.footer, s2 = o2.length;
          let a2, r2;
          if (s2) {
            const l2 = bn(i2.rtl, n2.x, n2.width);
            for (t2.x = Ps(n2, i2.footerAlign, i2), t2.y += i2.footerMarginTop, e2.textAlign = l2.textAlign(i2.footerAlign), e2.textBaseline = "middle", a2 = Fe(i2.footerFont), e2.fillStyle = i2.footerColor, e2.font = a2.string, r2 = 0; r2 < s2; ++r2)
              e2.fillText(o2[r2], l2.x(t2.x), t2.y + a2.lineHeight / 2), t2.y += a2.lineHeight + i2.footerSpacing;
          }
        }
        drawBackground(t2, e2, i2, n2) {
          const { xAlign: o2, yAlign: s2 } = this, { x: a2, y: r2 } = t2, { width: l2, height: c2 } = i2, h2 = n2.cornerRadius;
          e2.fillStyle = n2.backgroundColor, e2.strokeStyle = n2.borderColor, e2.lineWidth = n2.borderWidth, e2.beginPath(), e2.moveTo(a2 + h2, r2), s2 === "top" && this.drawCaret(t2, e2, i2, n2), e2.lineTo(a2 + l2 - h2, r2), e2.quadraticCurveTo(a2 + l2, r2, a2 + l2, r2 + h2), s2 === "center" && o2 === "right" && this.drawCaret(t2, e2, i2, n2), e2.lineTo(a2 + l2, r2 + c2 - h2), e2.quadraticCurveTo(a2 + l2, r2 + c2, a2 + l2 - h2, r2 + c2), s2 === "bottom" && this.drawCaret(t2, e2, i2, n2), e2.lineTo(a2 + h2, r2 + c2), e2.quadraticCurveTo(a2, r2 + c2, a2, r2 + c2 - h2), s2 === "center" && o2 === "left" && this.drawCaret(t2, e2, i2, n2), e2.lineTo(a2, r2 + h2), e2.quadraticCurveTo(a2, r2, a2 + h2, r2), e2.closePath(), e2.fill(), n2.borderWidth > 0 && e2.stroke();
        }
        _updateAnimationTarget(t2) {
          const e2 = this, i2 = e2._chart, n2 = e2.$animations, o2 = n2 && n2.x, s2 = n2 && n2.y;
          if (o2 || s2) {
            const n3 = bs[t2.position].call(e2, e2._active, e2._eventPosition);
            if (!n3)
              return;
            const a2 = e2._size = ws(e2, t2), r2 = Object.assign({}, n3, e2._size), l2 = ks(i2, t2, r2), c2 = Ss(t2, r2, l2, i2);
            o2._to === c2.x && s2._to === c2.y || (e2.xAlign = l2.xAlign, e2.yAlign = l2.yAlign, e2.width = a2.width, e2.height = a2.height, e2.caretX = n3.x, e2.caretY = n3.y, e2._resolveAnimations().update(e2, c2));
          }
        }
        draw(t2) {
          const e2 = this, i2 = e2.options.setContext(e2.getContext());
          let n2 = e2.opacity;
          if (!n2)
            return;
          e2._updateAnimationTarget(i2);
          const o2 = { width: e2.width, height: e2.height }, s2 = { x: e2.x, y: e2.y };
          n2 = Math.abs(n2) < 1e-3 ? 0 : n2;
          const a2 = ze(i2.padding), r2 = e2.title.length || e2.beforeBody.length || e2.body.length || e2.afterBody.length || e2.footer.length;
          i2.enabled && r2 && (t2.save(), t2.globalAlpha = n2, e2.drawBackground(s2, t2, o2, i2), _n(t2, i2.textDirection), s2.y += a2.top, e2.drawTitle(s2, t2, i2), e2.drawBody(s2, t2, i2), e2.drawFooter(s2, t2, i2), yn(t2, i2.textDirection), t2.restore());
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(t2, e2) {
          const i2 = this, n2 = i2._active, o2 = t2.map(({ datasetIndex: t3, index: e3 }) => {
            const n3 = i2._chart.getDatasetMeta(t3);
            if (!n3)
              throw new Error("Cannot find a dataset at index " + t3);
            return { datasetIndex: t3, element: n3.data[e3], index: e3 };
          }), s2 = !tt(n2, o2), a2 = i2._positionChanged(o2, e2);
          (s2 || a2) && (i2._active = o2, i2._eventPosition = e2, i2.update(true));
        }
        handleEvent(t2, e2) {
          const i2 = this, n2 = i2.options, o2 = i2._active || [];
          let s2 = false, a2 = [];
          t2.type !== "mouseout" && (a2 = i2._chart.getElementsAtEventForMode(t2, n2.mode, n2, e2), n2.reverse && a2.reverse());
          const r2 = i2._positionChanged(a2, t2);
          return s2 = e2 || !tt(a2, o2) || r2, s2 && (i2._active = a2, (n2.enabled || n2.external) && (i2._eventPosition = { x: t2.x, y: t2.y }, i2.update(true, e2))), s2;
        }
        _positionChanged(t2, e2) {
          const { caretX: i2, caretY: n2, options: o2 } = this, s2 = bs[o2.position].call(this, t2, e2);
          return s2 !== false && (i2 !== s2.x || n2 !== s2.y);
        }
      }
      Os.positioners = bs;
      var Ts = { id: "tooltip", _element: Os, positioners: bs, afterInit(t2, e2, i2) {
        i2 && (t2.tooltip = new Os({ _chart: t2, options: i2 }));
      }, beforeUpdate(t2, e2, i2) {
        t2.tooltip && t2.tooltip.initialize(i2);
      }, reset(t2, e2, i2) {
        t2.tooltip && t2.tooltip.initialize(i2);
      }, afterDraw(t2) {
        const e2 = t2.tooltip, i2 = { tooltip: e2 };
        t2.notifyPlugins("beforeTooltipDraw", i2) !== false && (e2 && e2.draw(t2.ctx), t2.notifyPlugins("afterTooltipDraw", i2));
      }, afterEvent(t2, e2) {
        if (t2.tooltip) {
          const i2 = e2.replay;
          t2.tooltip.handleEvent(e2.event, i2) && (e2.changed = true);
        }
      }, defaults: { enabled: true, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t2, e2) => e2.bodyFont.size, boxWidth: (t2, e2) => e2.bodyFont.size, multiKeyBackground: "#fff", displayColors: true, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: { beforeTitle: N, title(t2) {
        if (t2.length > 0) {
          const e2 = t2[0], i2 = e2.chart.data.labels, n2 = i2 ? i2.length : 0;
          if (this && this.options && this.options.mode === "dataset")
            return e2.dataset.label || "";
          if (e2.label)
            return e2.label;
          if (n2 > 0 && e2.dataIndex < n2)
            return i2[e2.dataIndex];
        }
        return "";
      }, afterTitle: N, beforeBody: N, beforeLabel: N, label(t2) {
        if (this && this.options && this.options.mode === "dataset")
          return t2.label + ": " + t2.formattedValue || t2.formattedValue;
        let e2 = t2.dataset.label || "";
        e2 && (e2 += ": ");
        const i2 = t2.formattedValue;
        return $(i2) || (e2 += i2), e2;
      }, labelColor(t2) {
        const e2 = t2.chart.getDatasetMeta(t2.datasetIndex).controller.getStyle(t2.dataIndex);
        return { borderColor: e2.borderColor, backgroundColor: e2.backgroundColor, borderWidth: e2.borderWidth, borderDash: e2.borderDash, borderDashOffset: e2.borderDashOffset, borderRadius: 0 };
      }, labelTextColor() {
        return this.options.bodyColor;
      }, labelPointStyle(t2) {
        const e2 = t2.chart.getDatasetMeta(t2.datasetIndex).controller.getStyle(t2.dataIndex);
        return { pointStyle: e2.pointStyle, rotation: e2.rotation };
      }, afterLabel: N, afterBody: N, beforeFooter: N, footer: N, afterFooter: N } }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: (t2) => t2 !== "filter" && t2 !== "itemSort" && t2 !== "external", _indexable: false, callbacks: { _scriptable: false, _indexable: false }, animation: { _fallback: false }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, As = Object.freeze({ __proto__: null, Decimation: Ko, Filler: us, Legend: ps, Title: xs, Tooltip: Ts });
      function Ls(t2, e2, i2) {
        const n2 = t2.indexOf(e2);
        if (n2 === -1)
          return ((t3, e3, i3) => typeof e3 == "string" ? t3.push(e3) - 1 : isNaN(e3) ? null : i3)(t2, e2, i2);
        return n2 !== t2.lastIndexOf(e2) ? i2 : n2;
      }
      class Rs extends Xi {
        constructor(t2) {
          super(t2), this._startValue = void 0, this._valueRange = 0;
        }
        parse(t2, e2) {
          if ($(t2))
            return null;
          const i2 = this.getLabels();
          return ((t3, e3) => t3 === null ? null : Nt(Math.round(t3), 0, e3))(e2 = isFinite(e2) && i2[e2] === t2 ? e2 : Ls(i2, t2, K(e2, t2)), i2.length - 1);
        }
        determineDataLimits() {
          const t2 = this, { minDefined: e2, maxDefined: i2 } = t2.getUserBounds();
          let { min: n2, max: o2 } = t2.getMinMax(true);
          t2.options.bounds === "ticks" && (e2 || (n2 = 0), i2 || (o2 = t2.getLabels().length - 1)), t2.min = n2, t2.max = o2;
        }
        buildTicks() {
          const t2 = this, e2 = t2.min, i2 = t2.max, n2 = t2.options.offset, o2 = [];
          let s2 = t2.getLabels();
          s2 = e2 === 0 && i2 === s2.length - 1 ? s2 : s2.slice(e2, i2 + 1), t2._valueRange = Math.max(s2.length - (n2 ? 0 : 1), 1), t2._startValue = t2.min - (n2 ? 0.5 : 0);
          for (let t3 = e2; t3 <= i2; t3++)
            o2.push({ value: t3 });
          return o2;
        }
        getLabelForValue(t2) {
          const e2 = this.getLabels();
          return t2 >= 0 && t2 < e2.length ? e2[t2] : t2;
        }
        configure() {
          const t2 = this;
          super.configure(), t2.isHorizontal() || (t2._reversePixels = !t2._reversePixels);
        }
        getPixelForValue(t2) {
          const e2 = this;
          return typeof t2 != "number" && (t2 = e2.parse(t2)), t2 === null ? NaN : e2.getPixelForDecimal((t2 - e2._startValue) / e2._valueRange);
        }
        getPixelForTick(t2) {
          const e2 = this.ticks;
          return t2 < 0 || t2 > e2.length - 1 ? null : this.getPixelForValue(e2[t2].value);
        }
        getValueForPixel(t2) {
          const e2 = this;
          return Math.round(e2._startValue + e2.getDecimalForPixel(t2) * e2._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      function Es(t2, e2, { horizontal: i2, minRotation: n2 }) {
        const o2 = Et(n2), s2 = (i2 ? Math.sin(o2) : Math.cos(o2)) || 1e-3, a2 = 0.75 * e2 * ("" + t2).length;
        return Math.min(e2 / s2, a2);
      }
      Rs.id = "category", Rs.defaults = { ticks: { callback: Rs.prototype.getLabelForValue } };
      class Is extends Xi {
        constructor(t2) {
          super(t2), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
        }
        parse(t2, e2) {
          return $(t2) || (typeof t2 == "number" || t2 instanceof Number) && !isFinite(+t2) ? null : +t2;
        }
        handleTickRangeOptions() {
          const t2 = this, { beginAtZero: e2 } = t2.options, { minDefined: i2, maxDefined: n2 } = t2.getUserBounds();
          let { min: o2, max: s2 } = t2;
          const a2 = (t3) => o2 = i2 ? o2 : t3, r2 = (t3) => s2 = n2 ? s2 : t3;
          if (e2) {
            const t3 = Dt(o2), e3 = Dt(s2);
            t3 < 0 && e3 < 0 ? r2(0) : t3 > 0 && e3 > 0 && a2(0);
          }
          o2 === s2 && (r2(s2 + 1), e2 || a2(o2 - 1)), t2.min = o2, t2.max = s2;
        }
        getTickLimit() {
          const t2 = this, e2 = t2.options.ticks;
          let i2, { maxTicksLimit: n2, stepSize: o2 } = e2;
          return o2 ? i2 = Math.ceil(t2.max / o2) - Math.floor(t2.min / o2) + 1 : (i2 = t2.computeTickLimit(), n2 = n2 || 11), n2 && (i2 = Math.min(n2, i2)), i2;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const t2 = this, e2 = t2.options, i2 = e2.ticks;
          let n2 = t2.getTickLimit();
          n2 = Math.max(2, n2);
          const o2 = function(t3, e3) {
            const i3 = [], { bounds: n3, step: o3, min: s2, max: a2, precision: r2, count: l2, maxTicks: c2, maxDigits: h2, includeBounds: d2 } = t3, u2 = o3 || 1, f2 = c2 - 1, { min: g2, max: p2 } = e3, m2 = !$(s2), x2 = !$(a2), b2 = !$(l2), _2 = (p2 - g2) / (h2 + 1);
            let y2, v2, w2, M2, k2 = Ct((p2 - g2) / f2 / u2) * u2;
            if (k2 < 1e-14 && !m2 && !x2)
              return [{ value: g2 }, { value: p2 }];
            M2 = Math.ceil(p2 / k2) - Math.floor(g2 / k2), M2 > f2 && (k2 = Ct(M2 * k2 / f2 / u2) * u2), $(r2) || (y2 = Math.pow(10, r2), k2 = Math.ceil(k2 * y2) / y2), n3 === "ticks" ? (v2 = Math.floor(g2 / k2) * k2, w2 = Math.ceil(p2 / k2) * k2) : (v2 = g2, w2 = p2), m2 && x2 && o3 && Lt((a2 - s2) / o3, k2 / 1e3) ? (M2 = Math.min((a2 - s2) / k2, c2), k2 = (a2 - s2) / M2, v2 = s2, w2 = a2) : b2 ? (v2 = m2 ? s2 : v2, w2 = x2 ? a2 : w2, M2 = l2 - 1, k2 = (w2 - v2) / M2) : (M2 = (w2 - v2) / k2, M2 = At(M2, Math.round(M2), k2 / 1e3) ? Math.round(M2) : Math.ceil(M2));
            const S2 = Math.max(zt(k2), zt(v2));
            y2 = Math.pow(10, $(r2) ? S2 : r2), v2 = Math.round(v2 * y2) / y2, w2 = Math.round(w2 * y2) / y2;
            let P2 = 0;
            for (m2 && (d2 && v2 !== s2 ? (i3.push({ value: s2 }), v2 < s2 && P2++, At(Math.round((v2 + P2 * k2) * y2) / y2, s2, Es(s2, _2, t3)) && P2++) : v2 < s2 && P2++); P2 < M2; ++P2)
              i3.push({ value: Math.round((v2 + P2 * k2) * y2) / y2 });
            return x2 && d2 && w2 !== a2 ? At(i3[i3.length - 1].value, a2, Es(a2, _2, t3)) ? i3[i3.length - 1].value = a2 : i3.push({ value: a2 }) : x2 && w2 !== a2 || i3.push({ value: w2 }), i3;
          }({ maxTicks: n2, bounds: e2.bounds, min: e2.min, max: e2.max, precision: i2.precision, step: i2.stepSize, count: i2.count, maxDigits: t2._maxDigits(), horizontal: t2.isHorizontal(), minRotation: i2.minRotation || 0, includeBounds: i2.includeBounds !== false }, t2._range || t2);
          return e2.bounds === "ticks" && Rt(o2, t2, "value"), e2.reverse ? (o2.reverse(), t2.start = t2.max, t2.end = t2.min) : (t2.start = t2.min, t2.end = t2.max), o2;
        }
        configure() {
          const t2 = this, e2 = t2.ticks;
          let i2 = t2.min, n2 = t2.max;
          if (super.configure(), t2.options.offset && e2.length) {
            const t3 = (n2 - i2) / Math.max(e2.length - 1, 1) / 2;
            i2 -= t3, n2 += t3;
          }
          t2._startValue = i2, t2._endValue = n2, t2._valueRange = n2 - i2;
        }
        getLabelForValue(t2) {
          return zi(t2, this.chart.options.locale);
        }
      }
      class zs extends Is {
        determineDataLimits() {
          const t2 = this, { min: e2, max: i2 } = t2.getMinMax(true);
          t2.min = X(e2) ? e2 : 0, t2.max = X(i2) ? i2 : 1, t2.handleTickRangeOptions();
        }
        computeTickLimit() {
          const t2 = this, e2 = t2.isHorizontal(), i2 = e2 ? t2.width : t2.height, n2 = Et(t2.options.ticks.minRotation), o2 = (e2 ? Math.sin(n2) : Math.cos(n2)) || 1e-3, s2 = t2._resolveTickFontOptions(0);
          return Math.ceil(i2 / Math.min(40, s2.lineHeight / o2));
        }
        getPixelForValue(t2) {
          return t2 === null ? NaN : this.getPixelForDecimal((t2 - this._startValue) / this._valueRange);
        }
        getValueForPixel(t2) {
          return this._startValue + this.getDecimalForPixel(t2) * this._valueRange;
        }
      }
      function Fs(t2) {
        return t2 / Math.pow(10, Math.floor(Pt(t2))) === 1;
      }
      zs.id = "linear", zs.defaults = { ticks: { callback: Vi.formatters.numeric } };
      class Vs extends Xi {
        constructor(t2) {
          super(t2), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
        }
        parse(t2, e2) {
          const i2 = Is.prototype.parse.apply(this, [t2, e2]);
          if (i2 !== 0)
            return X(i2) && i2 > 0 ? i2 : null;
          this._zero = true;
        }
        determineDataLimits() {
          const t2 = this, { min: e2, max: i2 } = t2.getMinMax(true);
          t2.min = X(e2) ? Math.max(0, e2) : null, t2.max = X(i2) ? Math.max(0, i2) : null, t2.options.beginAtZero && (t2._zero = true), t2.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const t2 = this, { minDefined: e2, maxDefined: i2 } = t2.getUserBounds();
          let n2 = t2.min, o2 = t2.max;
          const s2 = (t3) => n2 = e2 ? n2 : t3, a2 = (t3) => o2 = i2 ? o2 : t3, r2 = (t3, e3) => Math.pow(10, Math.floor(Pt(t3)) + e3);
          n2 === o2 && (n2 <= 0 ? (s2(1), a2(10)) : (s2(r2(n2, -1)), a2(r2(o2, 1)))), n2 <= 0 && s2(r2(o2, -1)), o2 <= 0 && a2(r2(n2, 1)), t2._zero && t2.min !== t2._suggestedMin && n2 === r2(t2.min, 0) && s2(r2(n2, -1)), t2.min = n2, t2.max = o2;
        }
        buildTicks() {
          const t2 = this, e2 = t2.options, i2 = function(t3, e3) {
            const i3 = Math.floor(Pt(e3.max)), n2 = Math.ceil(e3.max / Math.pow(10, i3)), o2 = [];
            let s2 = q(t3.min, Math.pow(10, Math.floor(Pt(e3.min)))), a2 = Math.floor(Pt(s2)), r2 = Math.floor(s2 / Math.pow(10, a2)), l2 = a2 < 0 ? Math.pow(10, Math.abs(a2)) : 1;
            do {
              o2.push({ value: s2, major: Fs(s2) }), ++r2, r2 === 10 && (r2 = 1, ++a2, l2 = a2 >= 0 ? 1 : l2), s2 = Math.round(r2 * Math.pow(10, a2) * l2) / l2;
            } while (a2 < i3 || a2 === i3 && r2 < n2);
            const c2 = q(t3.max, s2);
            return o2.push({ value: c2, major: Fs(s2) }), o2;
          }({ min: t2._userMin, max: t2._userMax }, t2);
          return e2.bounds === "ticks" && Rt(i2, t2, "value"), e2.reverse ? (i2.reverse(), t2.start = t2.max, t2.end = t2.min) : (t2.start = t2.min, t2.end = t2.max), i2;
        }
        getLabelForValue(t2) {
          return t2 === void 0 ? "0" : zi(t2, this.chart.options.locale);
        }
        configure() {
          const t2 = this, e2 = t2.min;
          super.configure(), t2._startValue = Pt(e2), t2._valueRange = Pt(t2.max) - Pt(e2);
        }
        getPixelForValue(t2) {
          const e2 = this;
          return t2 !== void 0 && t2 !== 0 || (t2 = e2.min), t2 === null || isNaN(t2) ? NaN : e2.getPixelForDecimal(t2 === e2.min ? 0 : (Pt(t2) - e2._startValue) / e2._valueRange);
        }
        getValueForPixel(t2) {
          const e2 = this, i2 = e2.getDecimalForPixel(t2);
          return Math.pow(10, e2._startValue + i2 * e2._valueRange);
        }
      }
      function Bs(t2) {
        const e2 = t2.ticks;
        if (e2.display && t2.display) {
          const t3 = ze(e2.backdropPadding);
          return K(e2.font && e2.font.size, xt.font.size) + t3.height;
        }
        return 0;
      }
      function Ws(t2, e2, i2, n2, o2) {
        return t2 === n2 || t2 === o2 ? { start: e2 - i2 / 2, end: e2 + i2 / 2 } : t2 < n2 || t2 > o2 ? { start: e2 - i2, end: e2 } : { start: e2, end: e2 + i2 };
      }
      function Hs(t2) {
        return t2 === 0 || t2 === 180 ? "center" : t2 < 180 ? "left" : "right";
      }
      function Ns(t2, e2, i2) {
        t2 === 90 || t2 === 270 ? i2.y -= e2.h / 2 : (t2 > 270 || t2 < 90) && (i2.y -= e2.h);
      }
      function js(t2, e2, i2, n2) {
        const { ctx: o2 } = t2;
        if (i2)
          o2.arc(t2.xCenter, t2.yCenter, e2, 0, _t);
        else {
          let i3 = t2.getPointPosition(0, e2);
          o2.moveTo(i3.x, i3.y);
          for (let s2 = 1; s2 < n2; s2++)
            i3 = t2.getPointPosition(s2, e2), o2.lineTo(i3.x, i3.y);
        }
      }
      function $s(t2) {
        return Tt(t2) ? t2 : 0;
      }
      Vs.id = "logarithmic", Vs.defaults = { ticks: { callback: Vi.formatters.logarithmic, major: { enabled: true } } };
      class Ys extends Is {
        constructor(t2) {
          super(t2), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
        }
        setDimensions() {
          const t2 = this;
          t2.width = t2.maxWidth, t2.height = t2.maxHeight, t2.paddingTop = Bs(t2.options) / 2, t2.xCenter = Math.floor(t2.width / 2), t2.yCenter = Math.floor((t2.height - t2.paddingTop) / 2), t2.drawingArea = Math.min(t2.height - t2.paddingTop, t2.width) / 2;
        }
        determineDataLimits() {
          const t2 = this, { min: e2, max: i2 } = t2.getMinMax(false);
          t2.min = X(e2) && !isNaN(e2) ? e2 : 0, t2.max = X(i2) && !isNaN(i2) ? i2 : 0, t2.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / Bs(this.options));
        }
        generateTickLabels(t2) {
          const e2 = this;
          Is.prototype.generateTickLabels.call(e2, t2), e2._pointLabels = e2.getLabels().map((t3, i2) => {
            const n2 = Q(e2.options.pointLabels.callback, [t3, i2], e2);
            return n2 || n2 === 0 ? n2 : "";
          });
        }
        fit() {
          const t2 = this, e2 = t2.options;
          e2.display && e2.pointLabels.display ? function(t3) {
            const e3 = { l: 0, r: t3.width, t: 0, b: t3.height - t3.paddingTop }, i2 = {};
            let n2, o2, s2;
            const a2 = [], r2 = [], l2 = t3.getLabels().length;
            for (n2 = 0; n2 < l2; n2++) {
              const l3 = t3.options.pointLabels.setContext(t3.getContext(n2));
              r2[n2] = l3.padding, s2 = t3.getPointPosition(n2, t3.drawingArea + r2[n2]);
              const u3 = Fe(l3.font);
              t3.ctx.font = u3.string, c2 = t3.ctx, h2 = u3.lineHeight, o2 = Y(d2 = t3._pointLabels[n2]) ? { w: Ut(c2, c2.font, d2), h: d2.length * h2 } : { w: c2.measureText(d2).width, h: h2 }, a2[n2] = o2;
              const f3 = t3.getIndexAngle(n2), g3 = It(f3), p2 = Ws(g3, s2.x, o2.w, 0, 180), m2 = Ws(g3, s2.y, o2.h, 90, 270);
              p2.start < e3.l && (e3.l = p2.start, i2.l = f3), p2.end > e3.r && (e3.r = p2.end, i2.r = f3), m2.start < e3.t && (e3.t = m2.start, i2.t = f3), m2.end > e3.b && (e3.b = m2.end, i2.b = f3);
            }
            var c2, h2, d2;
            t3._setReductions(t3.drawingArea, e3, i2), t3._pointLabelItems = [];
            const u2 = t3.options, f2 = Bs(u2), g2 = t3.getDistanceFromCenterForValue(u2.ticks.reverse ? t3.min : t3.max);
            for (n2 = 0; n2 < l2; n2++) {
              const e4 = n2 === 0 ? f2 / 2 : 0, i3 = t3.getPointPosition(n2, g2 + e4 + r2[n2]), o3 = It(t3.getIndexAngle(n2)), s3 = a2[n2];
              Ns(o3, s3, i3);
              const l3 = Hs(o3);
              let c3;
              c3 = l3 === "left" ? i3.x : l3 === "center" ? i3.x - s3.w / 2 : i3.x - s3.w;
              const h3 = c3 + s3.w;
              t3._pointLabelItems[n2] = { x: i3.x, y: i3.y, textAlign: l3, left: c3, top: i3.y, right: h3, bottom: i3.y + s3.h };
            }
          }(t2) : t2.setCenterPoint(0, 0, 0, 0);
        }
        _setReductions(t2, e2, i2) {
          const n2 = this;
          let o2 = e2.l / Math.sin(i2.l), s2 = Math.max(e2.r - n2.width, 0) / Math.sin(i2.r), a2 = -e2.t / Math.cos(i2.t), r2 = -Math.max(e2.b - (n2.height - n2.paddingTop), 0) / Math.cos(i2.b);
          o2 = $s(o2), s2 = $s(s2), a2 = $s(a2), r2 = $s(r2), n2.drawingArea = Math.max(t2 / 2, Math.min(Math.floor(t2 - (o2 + s2) / 2), Math.floor(t2 - (a2 + r2) / 2))), n2.setCenterPoint(o2, s2, a2, r2);
        }
        setCenterPoint(t2, e2, i2, n2) {
          const o2 = this, s2 = o2.width - e2 - o2.drawingArea, a2 = t2 + o2.drawingArea, r2 = i2 + o2.drawingArea, l2 = o2.height - o2.paddingTop - n2 - o2.drawingArea;
          o2.xCenter = Math.floor((a2 + s2) / 2 + o2.left), o2.yCenter = Math.floor((r2 + l2) / 2 + o2.top + o2.paddingTop);
        }
        getIndexAngle(t2) {
          return Wt(t2 * (_t / this.getLabels().length) + Et(this.options.startAngle || 0));
        }
        getDistanceFromCenterForValue(t2) {
          const e2 = this;
          if ($(t2))
            return NaN;
          const i2 = e2.drawingArea / (e2.max - e2.min);
          return e2.options.reverse ? (e2.max - t2) * i2 : (t2 - e2.min) * i2;
        }
        getValueForDistanceFromCenter(t2) {
          if ($(t2))
            return NaN;
          const e2 = this, i2 = t2 / (e2.drawingArea / (e2.max - e2.min));
          return e2.options.reverse ? e2.max - i2 : e2.min + i2;
        }
        getPointPosition(t2, e2) {
          const i2 = this, n2 = i2.getIndexAngle(t2) - Mt;
          return { x: Math.cos(n2) * e2 + i2.xCenter, y: Math.sin(n2) * e2 + i2.yCenter, angle: n2 };
        }
        getPointPositionForValue(t2, e2) {
          return this.getPointPosition(t2, this.getDistanceFromCenterForValue(e2));
        }
        getBasePosition(t2) {
          return this.getPointPositionForValue(t2 || 0, this.getBaseValue());
        }
        getPointLabelPosition(t2) {
          const { left: e2, top: i2, right: n2, bottom: o2 } = this._pointLabelItems[t2];
          return { left: e2, top: i2, right: n2, bottom: o2 };
        }
        drawBackground() {
          const t2 = this, { backgroundColor: e2, grid: { circular: i2 } } = t2.options;
          if (e2) {
            const n2 = t2.ctx;
            n2.save(), n2.beginPath(), js(t2, t2.getDistanceFromCenterForValue(t2._endValue), i2, t2.getLabels().length), n2.closePath(), n2.fillStyle = e2, n2.fill(), n2.restore();
          }
        }
        drawGrid() {
          const t2 = this, e2 = t2.ctx, i2 = t2.options, { angleLines: n2, grid: o2 } = i2, s2 = t2.getLabels().length;
          let a2, r2, l2;
          if (i2.pointLabels.display && function(t3, e3) {
            const { ctx: i3, options: { pointLabels: n3 } } = t3;
            for (let o3 = e3 - 1; o3 >= 0; o3--) {
              const e4 = n3.setContext(t3.getContext(o3)), s3 = Fe(e4.font), { x: a3, y: r3, textAlign: l3, left: c2, top: h2, right: d2, bottom: u2 } = t3._pointLabelItems[o3], { backdropColor: f2 } = e4;
              if (!$(f2)) {
                const t4 = ze(e4.backdropPadding);
                i3.fillStyle = f2, i3.fillRect(c2 - t4.left, h2 - t4.top, d2 - c2 + t4.width, u2 - h2 + t4.height);
              }
              ee(i3, t3._pointLabels[o3], a3, r3 + s3.lineHeight / 2, s3, { color: e4.color, textAlign: l3, textBaseline: "middle" });
            }
          }(t2, s2), o2.display && t2.ticks.forEach((e3, i3) => {
            if (i3 !== 0) {
              r2 = t2.getDistanceFromCenterForValue(e3.value);
              const n3 = o2.setContext(t2.getContext(i3 - 1));
              !function(t3, e4, i4, n4) {
                const o3 = t3.ctx, s3 = e4.circular, { color: a3, lineWidth: r3 } = e4;
                !s3 && !n4 || !a3 || !r3 || i4 < 0 || (o3.save(), o3.strokeStyle = a3, o3.lineWidth = r3, o3.setLineDash(e4.borderDash), o3.lineDashOffset = e4.borderDashOffset, o3.beginPath(), js(t3, i4, s3, n4), o3.closePath(), o3.stroke(), o3.restore());
              }(t2, n3, r2, s2);
            }
          }), n2.display) {
            for (e2.save(), a2 = t2.getLabels().length - 1; a2 >= 0; a2--) {
              const o3 = n2.setContext(t2.getContext(a2)), { color: s3, lineWidth: c2 } = o3;
              c2 && s3 && (e2.lineWidth = c2, e2.strokeStyle = s3, e2.setLineDash(o3.borderDash), e2.lineDashOffset = o3.borderDashOffset, r2 = t2.getDistanceFromCenterForValue(i2.ticks.reverse ? t2.min : t2.max), l2 = t2.getPointPosition(a2, r2), e2.beginPath(), e2.moveTo(t2.xCenter, t2.yCenter), e2.lineTo(l2.x, l2.y), e2.stroke());
            }
            e2.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const t2 = this, e2 = t2.ctx, i2 = t2.options, n2 = i2.ticks;
          if (!n2.display)
            return;
          const o2 = t2.getIndexAngle(0);
          let s2, a2;
          e2.save(), e2.translate(t2.xCenter, t2.yCenter), e2.rotate(o2), e2.textAlign = "center", e2.textBaseline = "middle", t2.ticks.forEach((o3, r2) => {
            if (r2 === 0 && !i2.reverse)
              return;
            const l2 = n2.setContext(t2.getContext(r2)), c2 = Fe(l2.font);
            if (s2 = t2.getDistanceFromCenterForValue(t2.ticks[r2].value), l2.showLabelBackdrop) {
              a2 = e2.measureText(o3.label).width, e2.fillStyle = l2.backdropColor;
              const t3 = ze(l2.backdropPadding);
              e2.fillRect(-a2 / 2 - t3.left, -s2 - c2.size / 2 - t3.top, a2 + t3.width, c2.size + t3.height);
            }
            ee(e2, o3.label, 0, -s2, c2, { color: l2.color });
          }), e2.restore();
        }
        drawTitle() {
        }
      }
      Ys.id = "radialLinear", Ys.defaults = { display: true, animate: true, position: "chartArea", angleLines: { display: true, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: false }, startAngle: 0, ticks: { showLabelBackdrop: true, callback: Vi.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: true, font: { size: 10 }, callback: (t2) => t2, padding: 5 } }, Ys.defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }, Ys.descriptors = { angleLines: { _fallback: "grid" } };
      const Us = { millisecond: { common: true, size: 1, steps: 1e3 }, second: { common: true, size: 1e3, steps: 60 }, minute: { common: true, size: 6e4, steps: 60 }, hour: { common: true, size: 36e5, steps: 24 }, day: { common: true, size: 864e5, steps: 30 }, week: { common: false, size: 6048e5, steps: 4 }, month: { common: true, size: 2628e6, steps: 12 }, quarter: { common: false, size: 7884e6, steps: 4 }, year: { common: true, size: 3154e7 } }, Xs = Object.keys(Us);
      function qs(t2, e2) {
        return t2 - e2;
      }
      function Ks(t2, e2) {
        if ($(e2))
          return null;
        const i2 = t2._adapter, { parser: n2, round: o2, isoWeekday: s2 } = t2._parseOpts;
        let a2 = e2;
        return typeof n2 == "function" && (a2 = n2(a2)), X(a2) || (a2 = typeof n2 == "string" ? i2.parse(a2, n2) : i2.parse(a2)), a2 === null ? null : (o2 && (a2 = o2 !== "week" || !Tt(s2) && s2 !== true ? i2.startOf(a2, o2) : i2.startOf(a2, "isoWeek", s2)), +a2);
      }
      function Gs(t2, e2, i2, n2) {
        const o2 = Xs.length;
        for (let s2 = Xs.indexOf(t2); s2 < o2 - 1; ++s2) {
          const t3 = Us[Xs[s2]], o3 = t3.steps ? t3.steps : Number.MAX_SAFE_INTEGER;
          if (t3.common && Math.ceil((i2 - e2) / (o3 * t3.size)) <= n2)
            return Xs[s2];
        }
        return Xs[o2 - 1];
      }
      function Zs(t2, e2, i2) {
        if (i2) {
          if (i2.length) {
            const { lo: n2, hi: o2 } = ne(i2, e2);
            t2[i2[n2] >= e2 ? i2[n2] : i2[o2]] = true;
          }
        } else
          t2[e2] = true;
      }
      function Qs(t2, e2, i2) {
        const n2 = [], o2 = {}, s2 = e2.length;
        let a2, r2;
        for (a2 = 0; a2 < s2; ++a2)
          r2 = e2[a2], o2[r2] = a2, n2.push({ value: r2, major: false });
        return s2 !== 0 && i2 ? function(t3, e3, i3, n3) {
          const o3 = t3._adapter, s3 = +o3.startOf(e3[0].value, n3), a3 = e3[e3.length - 1].value;
          let r3, l2;
          for (r3 = s3; r3 <= a3; r3 = +o3.add(r3, 1, n3))
            l2 = i3[r3], l2 >= 0 && (e3[l2].major = true);
          return e3;
        }(t2, n2, o2, i2) : n2;
      }
      class Js extends Xi {
        constructor(t2) {
          super(t2), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
        }
        init(t2, e2) {
          const i2 = t2.time || (t2.time = {}), n2 = this._adapter = new so._date(t2.adapters.date);
          st(i2.displayFormats, n2.formats()), this._parseOpts = { parser: i2.parser, round: i2.round, isoWeekday: i2.isoWeekday }, super.init(t2), this._normalized = e2.normalized;
        }
        parse(t2, e2) {
          return t2 === void 0 ? null : Ks(this, t2);
        }
        beforeLayout() {
          super.beforeLayout(), this._cache = { data: [], labels: [], all: [] };
        }
        determineDataLimits() {
          const t2 = this, e2 = t2.options, i2 = t2._adapter, n2 = e2.time.unit || "day";
          let { min: o2, max: s2, minDefined: a2, maxDefined: r2 } = t2.getUserBounds();
          function l2(t3) {
            a2 || isNaN(t3.min) || (o2 = Math.min(o2, t3.min)), r2 || isNaN(t3.max) || (s2 = Math.max(s2, t3.max));
          }
          a2 && r2 || (l2(t2._getLabelBounds()), e2.bounds === "ticks" && e2.ticks.source === "labels" || l2(t2.getMinMax(false))), o2 = X(o2) && !isNaN(o2) ? o2 : +i2.startOf(Date.now(), n2), s2 = X(s2) && !isNaN(s2) ? s2 : +i2.endOf(Date.now(), n2) + 1, t2.min = Math.min(o2, s2 - 1), t2.max = Math.max(o2 + 1, s2);
        }
        _getLabelBounds() {
          const t2 = this.getLabelTimestamps();
          let e2 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
          return t2.length && (e2 = t2[0], i2 = t2[t2.length - 1]), { min: e2, max: i2 };
        }
        buildTicks() {
          const t2 = this, e2 = t2.options, i2 = e2.time, n2 = e2.ticks, o2 = n2.source === "labels" ? t2.getLabelTimestamps() : t2._generate();
          e2.bounds === "ticks" && o2.length && (t2.min = t2._userMin || o2[0], t2.max = t2._userMax || o2[o2.length - 1]);
          const s2 = t2.min, a2 = ae(o2, s2, t2.max);
          return t2._unit = i2.unit || (n2.autoSkip ? Gs(i2.minUnit, t2.min, t2.max, t2._getLabelCapacity(s2)) : function(t3, e3, i3, n3, o3) {
            for (let s3 = Xs.length - 1; s3 >= Xs.indexOf(i3); s3--) {
              const i4 = Xs[s3];
              if (Us[i4].common && t3._adapter.diff(o3, n3, i4) >= e3 - 1)
                return i4;
            }
            return Xs[i3 ? Xs.indexOf(i3) : 0];
          }(t2, a2.length, i2.minUnit, t2.min, t2.max)), t2._majorUnit = n2.major.enabled && t2._unit !== "year" ? function(t3) {
            for (let e3 = Xs.indexOf(t3) + 1, i3 = Xs.length; e3 < i3; ++e3)
              if (Us[Xs[e3]].common)
                return Xs[e3];
          }(t2._unit) : void 0, t2.initOffsets(o2), e2.reverse && a2.reverse(), Qs(t2, a2, t2._majorUnit);
        }
        initOffsets(t2) {
          const e2 = this;
          let i2, n2, o2 = 0, s2 = 0;
          e2.options.offset && t2.length && (i2 = e2.getDecimalForValue(t2[0]), o2 = t2.length === 1 ? 1 - i2 : (e2.getDecimalForValue(t2[1]) - i2) / 2, n2 = e2.getDecimalForValue(t2[t2.length - 1]), s2 = t2.length === 1 ? n2 : (n2 - e2.getDecimalForValue(t2[t2.length - 2])) / 2);
          const a2 = t2.length < 3 ? 0.5 : 0.25;
          o2 = Nt(o2, 0, a2), s2 = Nt(s2, 0, a2), e2._offsets = { start: o2, end: s2, factor: 1 / (o2 + 1 + s2) };
        }
        _generate() {
          const t2 = this, e2 = t2._adapter, i2 = t2.min, n2 = t2.max, o2 = t2.options, s2 = o2.time, a2 = s2.unit || Gs(s2.minUnit, i2, n2, t2._getLabelCapacity(i2)), r2 = K(s2.stepSize, 1), l2 = a2 === "week" && s2.isoWeekday, c2 = Tt(l2) || l2 === true, h2 = {};
          let d2, u2, f2 = i2;
          if (c2 && (f2 = +e2.startOf(f2, "isoWeek", l2)), f2 = +e2.startOf(f2, c2 ? "day" : a2), e2.diff(n2, i2, a2) > 1e5 * r2)
            throw new Error(i2 + " and " + n2 + " are too far apart with stepSize of " + r2 + " " + a2);
          const g2 = o2.ticks.source === "data" && t2.getDataTimestamps();
          for (d2 = f2, u2 = 0; d2 < n2; d2 = +e2.add(d2, r2, a2), u2++)
            Zs(h2, d2, g2);
          return d2 !== n2 && o2.bounds !== "ticks" && u2 !== 1 || Zs(h2, d2, g2), Object.keys(h2).sort((t3, e3) => t3 - e3).map((t3) => +t3);
        }
        getLabelForValue(t2) {
          const e2 = this._adapter, i2 = this.options.time;
          return i2.tooltipFormat ? e2.format(t2, i2.tooltipFormat) : e2.format(t2, i2.displayFormats.datetime);
        }
        _tickFormatFunction(t2, e2, i2, n2) {
          const o2 = this, s2 = o2.options, a2 = s2.time.displayFormats, r2 = o2._unit, l2 = o2._majorUnit, c2 = r2 && a2[r2], h2 = l2 && a2[l2], d2 = i2[e2], u2 = l2 && h2 && d2 && d2.major, f2 = o2._adapter.format(t2, n2 || (u2 ? h2 : c2)), g2 = s2.ticks.callback;
          return g2 ? Q(g2, [f2, e2, i2], o2) : f2;
        }
        generateTickLabels(t2) {
          let e2, i2, n2;
          for (e2 = 0, i2 = t2.length; e2 < i2; ++e2)
            n2 = t2[e2], n2.label = this._tickFormatFunction(n2.value, e2, t2);
        }
        getDecimalForValue(t2) {
          const e2 = this;
          return t2 === null ? NaN : (t2 - e2.min) / (e2.max - e2.min);
        }
        getPixelForValue(t2) {
          const e2 = this, i2 = e2._offsets, n2 = e2.getDecimalForValue(t2);
          return e2.getPixelForDecimal((i2.start + n2) * i2.factor);
        }
        getValueForPixel(t2) {
          const e2 = this, i2 = e2._offsets, n2 = e2.getDecimalForPixel(t2) / i2.factor - i2.end;
          return e2.min + n2 * (e2.max - e2.min);
        }
        _getLabelSize(t2) {
          const e2 = this, i2 = e2.options.ticks, n2 = e2.ctx.measureText(t2).width, o2 = Et(e2.isHorizontal() ? i2.maxRotation : i2.minRotation), s2 = Math.cos(o2), a2 = Math.sin(o2), r2 = e2._resolveTickFontOptions(0).size;
          return { w: n2 * s2 + r2 * a2, h: n2 * a2 + r2 * s2 };
        }
        _getLabelCapacity(t2) {
          const e2 = this, i2 = e2.options.time, n2 = i2.displayFormats, o2 = n2[i2.unit] || n2.millisecond, s2 = e2._tickFormatFunction(t2, 0, Qs(e2, [t2], e2._majorUnit), o2), a2 = e2._getLabelSize(s2), r2 = Math.floor(e2.isHorizontal() ? e2.width / a2.w : e2.height / a2.h) - 1;
          return r2 > 0 ? r2 : 1;
        }
        getDataTimestamps() {
          const t2 = this;
          let e2, i2, n2 = t2._cache.data || [];
          if (n2.length)
            return n2;
          const o2 = t2.getMatchingVisibleMetas();
          if (t2._normalized && o2.length)
            return t2._cache.data = o2[0].controller.getAllParsedValues(t2);
          for (e2 = 0, i2 = o2.length; e2 < i2; ++e2)
            n2 = n2.concat(o2[e2].controller.getAllParsedValues(t2));
          return t2._cache.data = t2.normalize(n2);
        }
        getLabelTimestamps() {
          const t2 = this, e2 = t2._cache.labels || [];
          let i2, n2;
          if (e2.length)
            return e2;
          const o2 = t2.getLabels();
          for (i2 = 0, n2 = o2.length; i2 < n2; ++i2)
            e2.push(Ks(t2, o2[i2]));
          return t2._cache.labels = t2._normalized ? e2 : t2.normalize(e2);
        }
        normalize(t2) {
          return he(t2.sort(qs));
        }
      }
      function ta(t2, e2, i2) {
        let n2, o2, s2, a2;
        if (i2)
          n2 = Math.floor(e2), o2 = Math.ceil(e2), s2 = t2[n2], a2 = t2[o2];
        else {
          const i3 = ne(t2, e2);
          s2 = i3.lo, a2 = i3.hi, n2 = t2[s2], o2 = t2[a2];
        }
        const r2 = o2 - n2;
        return r2 ? s2 + (a2 - s2) * (e2 - n2) / r2 : s2;
      }
      Js.id = "time", Js.defaults = { bounds: "data", adapters: {}, time: { parser: false, unit: false, round: false, isoWeekday: false, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", major: { enabled: false } } };
      class ea extends Js {
        constructor(t2) {
          super(t2), this._table = [], this._maxIndex = void 0;
        }
        initOffsets() {
          const t2 = this, e2 = t2._getTimestampsForTable();
          t2._table = t2.buildLookupTable(e2), t2._maxIndex = t2._table.length - 1, super.initOffsets(e2);
        }
        buildLookupTable(t2) {
          const { min: e2, max: i2 } = this;
          if (!t2.length)
            return [{ time: e2, pos: 0 }, { time: i2, pos: 1 }];
          const n2 = [e2];
          let o2, s2, a2;
          for (o2 = 0, s2 = t2.length; o2 < s2; ++o2)
            a2 = t2[o2], a2 > e2 && a2 < i2 && n2.push(a2);
          return n2.push(i2), n2;
        }
        _getTimestampsForTable() {
          const t2 = this;
          let e2 = t2._cache.all || [];
          if (e2.length)
            return e2;
          const i2 = t2.getDataTimestamps(), n2 = t2.getLabelTimestamps();
          return e2 = i2.length && n2.length ? t2.normalize(i2.concat(n2)) : i2.length ? i2 : n2, e2 = t2._cache.all = e2, e2;
        }
        getPixelForValue(t2, e2) {
          const i2 = this, n2 = i2._offsets, o2 = i2._normalized && i2._maxIndex > 0 && !$(e2) ? e2 / i2._maxIndex : i2.getDecimalForValue(t2);
          return i2.getPixelForDecimal((n2.start + o2) * n2.factor);
        }
        getDecimalForValue(t2) {
          return ta(this._table, t2) / this._maxIndex;
        }
        getValueForPixel(t2) {
          const e2 = this, i2 = e2._offsets, n2 = e2.getDecimalForPixel(t2) / i2.factor - i2.end;
          return ta(e2._table, n2 * this._maxIndex, true);
        }
      }
      ea.id = "timeseries", ea.defaults = Js.defaults;
      var ia = Object.freeze({ __proto__: null, CategoryScale: Rs, LinearScale: zs, LogarithmicScale: Vs, RadialLinearScale: Ys, TimeScale: Js, TimeSeriesScale: ea });
      return to.register(_o, ia, Uo, As), to.helpers = { ...On }, to._adapters = so, to.Animation = _i, to.Animations = vi, to.animator = a, to.controllers = An.controllers.items, to.DatasetController = Ri, to.Element = Ei, to.elements = Uo, to.Interaction = Oe, to.layouts = Ge, to.platforms = ui, to.Scale = Xi, to.Ticks = Vi, Object.assign(to, _o, ia, Uo, As, ui), to.Chart = to, typeof window != "undefined" && (window.Chart = to), to;
    });
  }
});

// dep:chart_js_dist_chart_min_js
var chart_js_dist_chart_min_js_default = require_chart_min();
export {
  chart_js_dist_chart_min_js_default as default
};
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.3.2
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
//# sourceMappingURL=chart_js_dist_chart_min_js.js.map
